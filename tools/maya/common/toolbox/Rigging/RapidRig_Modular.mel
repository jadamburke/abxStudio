//CopyRight Dustin Nelson 2010-2014. Please do not distribute
//http://www.creativecrash.com/maya/script/-rapid-rig-modular-procedural-auto-rig-for-maya
//Script for Modular Character Rigging.
//VERSION 1.5.2
//NOVEMBER 27, 2014
//FILE IS NOT INTENDED TO BE HARMFUL, HOWEVER USE AT YOUR OWN RISK
/*/////////////////////////////////////////////////////////////////////////////
// 
//	INSTRUCTIONS:
//	1. INSTALLATION
//	TYPE IN THE FOLLOWING COMMAND IN MAYA TO GET YOUR SCRIPT DIRECTORY:
//
//	internalVar -userScriptDir;
//
//	2. PUT THE RapidRig_Modular.mel file in that directoy.
//
//	3. START UP MAYA, ENTER THE FOLLOWING COMMAND INTO
//	THE COMMAND LINE OR THE SCRIPT EDITOR:
//
//	RapidRig_Modular;
//
//	4. TO HAVE EASY ACCESS TO SCRIPT, CREATE A SHELF BUTTON             
//	WITH ONLY THAT COMMAND. EVERY TIME YOU HIT THE BUTTON,              
//	THE RAPID RIGrp INTERFACE WILL POP UP. HAPPY ANIMATING!               
//                                                                      
////////////////////////////////////////////////////////////////////////*/

global proc int RRM_CheckName(string $validate)
{
	string $nameMatch = `match "^[a-zA-Z][0-9a-zA-Z_]*$" $validate`;
	int $goodMatch = ! `strcmp $nameMatch $validate`;
	
	return $goodMatch;
}

global proc RRM_CreateProxyModuleProxy(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	if ($crntUnit != "cm")
	{
		//changeLinearUnit "centimeter"
	}
	
	//CREATE PROXY BASE
	circle -n RRM_Base -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.25 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
	duplicate -rr -n RRM_BaseB;
	rotate 90 0 0 RRM_BaseB;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_BaseB;
	duplicate -rr -n RRM_BaseCtrl;
	rotate 0 90 0 RRM_BaseCtrl; 
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_BaseCtrl;
	
	spaceLocator -n RRM_BaseD;
	setAttr "RRM_BaseDShape.localScaleZ" .25;
	setAttr "RRM_BaseDShape.localScaleX" .25;
	setAttr "RRM_BaseDShape.localScaleY" .25;
	if ($crntUnit == "m")
	{
		setAttr "RRM_BaseDShape.localScaleZ" .0025;
		setAttr "RRM_BaseDShape.localScaleX" .0025;
		setAttr "RRM_BaseDShape.localScaleY" .0025;
	}
		

	parent -r -s RRM_BaseBShape RRM_BaseCtrlShape RRM_BaseDShape RRM_Base;
	delete RRM_BaseB RRM_BaseCtrl RRM_BaseD;
	select RRM_Base;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_Base;
	delete -ch RRM_Base;
	
	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_Base;
	setAttr -e-keyable true RRM_Base.core;
	
	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_Base;
	setAttr -e-keyable true RRM_Base.ext;

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_Base;
	setAttr -e-keyable true RRM_Base.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_Base;
	setAttr -e-keyable true RRM_Base.modName;
	
	setAttr -lock true -keyable false -channelBox false "RRM_Base.v";

	if ($crntUnit != "cm")
	{
		//changeLinearUnit "centimeter"
	}
		changeLinearUnit $crntUnit;
}

global proc RRM_CreateProxyBaseUpProxy(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	if ($crntUnit != "cm")
	{
		//changeLinearUnit "centimeter"
	}

	circle -n RRM_BaseUp -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
	circle -n RRM_BaseUpB -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
	circle -n RRM_BaseUpCtrl -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
	curve -n RRM_BaseUpD -d 1 -p 0 -1 0 -p 0 3 0 -k 0 -k 1 ;
	pickWalk -d down;
	rename RRM_BaseUpDShape;
	curve -n RRM_BaseUpE -d 1 -p 0 2.5 0.5 -p 0 3 0 -p 0 2.5 -0.5 -k 0 -k 1 -k 2 ;
	pickWalk -d down;
	rename RRM_BaseUpEShape;
	curve -n RRM_BaseUpF -d 1 -p -0.5 2.5 0 -p 0 3 0 -p 0.5 2.5 0 -k 0 -k 1 -k 2 ;
	pickWalk -d down;
	rename RRM_BaseUpFShape;
	circle -n RRM_BaseUpGrp -c 0 2.5 0 -nr 0 1 0 -sw 360 -r 0.5 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
	pickWalk -d down;
	rename RRM_BaseUpGShape;
	
	spaceLocator -n RRM_BaseUpH;
	setAttr "RRM_BaseUpHShape.localScaleZ" .25;
	setAttr "RRM_BaseUpHShape.localScaleX" .25;
	setAttr "RRM_BaseUpHShape.localScaleY" .25;	
	if ($crntUnit == "m")
	{
		setAttr "RRM_BaseUpHShape.localScaleZ" .0025;
		setAttr "RRM_BaseUpHShape.localScaleX" .0025;
		setAttr "RRM_BaseUpHShape.localScaleY" .0025;
	}
	
	parent -r -s RRM_BaseUpBShape RRM_BaseUpCtrlShape RRM_BaseUpDShape RRM_BaseUpEShape RRM_BaseUpFShape RRM_BaseUpGShape RRM_BaseUpHShape RRM_BaseUp;
	delete RRM_BaseUpB RRM_BaseUpCtrl RRM_BaseUpD RRM_BaseUpE RRM_BaseUpF RRM_BaseUpGrp RRM_BaseUpH;
	select RRM_BaseUp;
	scale -r 0.25 0.25 0.25 RRM_BaseUp;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_BaseUp;
	
	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_BaseUp;
	setAttr -e-keyable true RRM_BaseUp.core;

	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_BaseUp;
	setAttr -e-keyable true RRM_BaseUp.ext;
	
	//ADD CORE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_BaseUp;
	setAttr -e-keyable true RRM_BaseUp.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_BaseUp;
	setAttr -e-keyable true RRM_BaseUp.modName;

	setAttr -lock true -keyable false -channelBox false "RRM_BaseUp.v";


}

global proc RRM_CreateProxyRootProxy(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	if ($crntUnit != "cm")
	{
		//changeLinearUnit "centimeter"
	}
		
	//CREATE PROXY BASE
	RRM_CreateProxyModuleProxy($crntUnit);
	rename RRM_Base RRM_ROOT;
	
	curve -n RRM_ROOTE -d 1 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5
	-p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	pickWalk -d down;
	rename RRM_ROOTEShape;
	parent -r -s RRM_ROOTEShape RRM_ROOT;
	delete RRM_ROOTE;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_ROOT;
	delete -ch RRM_ROOT;


	setAttr -lock true -keyable false -channelBox false "RRM_ROOT.v";


}

global proc RRM_CreateProxyCOG_C(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	if ($crntUnit != "cm")
	{
		//changeLinearUnit "centimeter"
	}
	
	circle -n RRM_OuterCOG_Ctrl -r 6 -nr 0 1 0;
	circle -n RRM_InnerCOG_Ctrl -r 3 -nr 0 1 0;
	rotate -r -os 0 -18 0 RRM_InnerCOG_Ctrl;
	curve -n RRM_XConnectorCOG_Ctrl -d 1 -p 6 0 0 -p -6 0 0 -k 0 -k 1 ;
	pickWalk -d down;
	rename RRM_XConnectorCOG_CtrlShape;
	curve -n RRM_YConnectorCOG_Ctrl -d 1 -p 0 0 -6 -p 0 0 6 -k 0 -k 1 ;
	pickWalk -d down;
	rename RRM_YConnectorCOG_CtrlShape;
	
	$transforms = `ls RRM_InnerCOG_Ctrl RRM_XConnectorCOG_Ctrl RRM_YConnectorCOG_Ctrl`;
	//pickWalk -d down;
	$curves = `listRelatives -c $transforms`;
	parent -r -s $curves RRM_OuterCOG_Ctrl;
	delete $transforms;
	rename RRM_OuterCOG_Ctrl RRM_COG;
	
	setAttr -lock true -keyable false -channelBox false "RRM_COG.v";

	setAttr -l 1 -k 0 "RRM_COG.v";
}


global proc RRM_CreateProxyParentProxy(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	if ($crntUnit != "cm")
	{
		//changeLinearUnit "centimeter"
	}
		
	//CREATE PROXY PARENT
	curve -n RRM_Parent -d 1 -p 0.5 1 0.5 -p 0.5 1 -0.5 -p -0.5 1 -0.5 -p -0.5 1 0.5 -p -0.5 0.1 0.5 -p 0.5 0.1 0.5 -p 0.5 1 0.5 -p -0.5 1 0.5
	-p -0.5 1 -0.5 -p -0.5 0.1 -0.5 -p 0.5 0.1 -0.5 -p 0.5 1 -0.5 -p 0.5 1 0.5 -p 0.5 0.1 0.5 -p 0.5 0.1 -0.5 -p -0.5 0.1 -0.5 -p -0.5 0.1 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	pickWalk -d down;
	rename RRM_ParentShape;
	scale -r 0.8 1.25 0.8 RRM_Parent;
	makeIdentity -apply true -s 1 RRM_Parent;
	
	curve -n RRM_ParentB -d 1 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5
	-p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	pickWalk -d down;
	rename RRM_ParentBShape;
	scale -r 0.25 0.75 0.25 RRM_Parent;
	scale -r 0.5 0.5 0.5 RRM_ParentB;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_Parent RRM_ParentB;		

	spaceLocator -n RRM_ParentCtrl;
	setAttr "RRM_ParentCtrlShape.localScaleZ" .25;
	setAttr "RRM_ParentCtrlShape.localScaleX" .25;
	setAttr "RRM_ParentCtrlShape.localScaleY" .25;
	if ($crntUnit == "m")
	{
		setAttr "RRM_ParentCtrlShape.localScaleZ" .0025;
		setAttr "RRM_ParentCtrlShape.localScaleX" .0025;
		setAttr "RRM_ParentCtrlShape.localScaleY" .0025;
	}
	
	parent -r -s RRM_ParentBShape RRM_ParentCtrlShape RRM_Parent;
	delete RRM_ParentB RRM_ParentCtrl;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_Parent;
	delete -ch RRM_Parent;

	//ADD PARENT ATTRIBUTE
	addAttr -ln "parent"  -dt "string" RRM_Parent;
	setAttr -e-keyable true RRM_Parent.parent;

	addAttr -ln "attachNode"  -dt "string" RRM_Parent;
	setAttr -e-keyable true RRM_Parent.attachNode;
	
	//ADD PINNED ATTRIBUTE
	addAttr -ln "pinned"  -at bool RRM_Parent;
	setAttr -e-keyable true RRM_Parent.pinned;
	setAttr RRM_Parent.pinned 0;
	setAttr -lock true RRM_Parent.pinned;
	
	//ADD CONNECTOR VIZ ATTRIBUTE
	addAttr -ln "connectors"  -at bool RRM_Parent;
	setAttr -e-keyable true RRM_Parent.connectors;
	setAttr RRM_Parent.connectors 1;
	
	//SET SO CAN'T ATTACH TO PARENT OBJECT
	addAttr -ln "noAttach"  -dt "string" RRM_Parent;
	setAttr -e-keyable true RRM_Parent.noAttach;
	

	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_Parent;
	setAttr -e-keyable true RRM_Parent.core;

	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_Parent;
	setAttr -e-keyable true RRM_Parent.ext;

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_Parent;
	setAttr -e-keyable true RRM_Parent.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_Parent;
	setAttr -e-keyable true RRM_Parent.modName;

	setAttr -lock true -keyable false -channelBox false "RRM_Parent.v";


}

global proc RRM_CreateProxyEndProxy(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	if ($crntUnit != "cm")
	{
		//changeLinearUnit "centimeter"
	}
		
	//CREATE PROXY END
	circle -n RRM_End -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.25 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
	duplicate -rr -n RRM_EndB;
	rotate 90 0 0;
	makeIdentity -apply true -t 1 -r 1 -s 1;
	duplicate -rr -n RRM_EndCtrl;
	rotate 0 90 0 ;
	makeIdentity -apply true -t 1 -r 1 -s 1;
	curve -n RRM_EndD -d 1 -p 0.375 -0.25 -0.375 -p 0 0.5 0 -p 0.375 -0.25 0.375 -p 0.375 -0.25 -0.375 -p -0.375 -0.25 -0.375 -p 0 0.5 0 -p -0.375 -0.25 0.375
	-p -0.375 -0.25 -0.375 -p -0.375 -0.25 0.375 -p 0.375 -0.25 0.375 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 ;
	pickWalk -d down;
	rename RRM_EndDShape;

	spaceLocator -n RRM_EndE;
	setAttr "RRM_EndEShape.localScaleZ" .25;
	setAttr "RRM_EndEShape.localScaleX" .25;
	setAttr "RRM_EndEShape.localScaleY" .25;
	if ($crntUnit == "m")
	{
		setAttr "RRM_EndEShape.localScaleZ" .0025;
		setAttr "RRM_EndEShape.localScaleX" .0025;
		setAttr "RRM_EndEShape.localScaleY" .0025;
	}
	
	parent -r -s RRM_EndBShape RRM_EndCtrlShape RRM_EndDShape RRM_EndEShape RRM_End;
	delete RRM_EndB RRM_EndCtrl RRM_EndD RRM_EndE;
	select RRM_End;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_End;
	delete -ch RRM_End;

	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_End;
	setAttr -e-keyable true RRM_End.core;

	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_End;
	setAttr -e-keyable true RRM_End.ext;

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_End;
	setAttr -e-keyable true RRM_End.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_End;
	setAttr -e-keyable true RRM_End.modName;

	setAttr -lock true -keyable false -channelBox false "RRM_End.v";


}


global proc RRM_ProxyLockNodes(string $modNodes[])
{
	lockNode $modNodes;
}

global proc RRM_ProxyLimits(string $xforms[])
{
	for ($each in $xforms)
	{
		transformLimits -sx 0.01 1 -esx 1 0 $each;
		transformLimits -sy 0.01 1 -esy 1 0 $each;
		transformLimits -sz 0.01 1 -esz 1 0 $each;
	}
}
	

global proc RRM_ProxyConnectors(string $modName, string $prfx, string $node1, string $node2)
{


	$selection = `ls -sl`;
	$node1Loc = `xform -q -ws -rp $node1`;
	$node2Loc = `xform -q -ws -rp $node2`;
	
	if ($prfx == "r_")
	{
		if (`objExists ($node1 + ".pair")`&&`objExists ($node2 + ".parent")`)
		{
			$rightAttachPoint = `getAttr ($node1 + ".opposite")`;
			$node1 = ("RRM_" + $rightAttachPoint);
			$node1Loc = `xform -q -ws -rp $node1`;
		}
		else if (`objExists ($node1 + ".pair")`&&`objExists ($node2 + ".modType")`)
		{
			$rightAttachPoint = `getAttr ($node1 + ".opposite")`;
			$node1 = ("RRM_" + $rightAttachPoint);
			$node1Loc = `xform -q -ws -rp $node1`;
		}
		
	}
	
	
	//NEW
	curve -n ($node1 + "_" + $node2 + "Ctrl") -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1 ;
	pickWalk -d down;
	rename  ($node1 + "_" + $node2 + "CtrlShape");
	spaceLocator -n ($node1 + "_" + $node2 + "_AimLctr");
	spaceLocator -n ($node1 + "_" + $node2 + "_TargetLctr");
	parent ($node1 + "_" + $node2 + "_TargetLctr") ($node1 + "_" + $node2 + "_AimLctr");
	pointConstraint $node1 ($node1 + "_" + $node2 + "_AimLctr");
	aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $node2 ($node1 + "_" + $node2 + "_AimLctr");
	pointConstraint $node2 ($node1 + "_" + $node2 + "_TargetLctr");
	connectAttr -f ($node1 + "_" + $node2 + "_AimLctr.translate") ($node1 + "_" + $node2 + "Ctrl.translate");
	connectAttr -f ($node1 + "_" + $node2 + "_AimLctr.rotate") ($node1 + "_" + $node2 + "Ctrl.rotate");
	connectAttr -f ($node1 + "_" + $node2 + "_TargetLctr.tx") ($node1 + "_" + $node2 + "Ctrl.sx");
	setAttr ($node1 + "_" + $node2 + "_AimLctr.v") 0;
	
	//ONLY TEMPLATE IF IT IS NOT A PARENT NODE
	if (!`objExists ($node2 + ".parent")` && !`objExists ($node2 + ".modType")`)
	{
		setAttr ($node1 + "_" + $node2 + "Ctrl.template") 1;
	}
	else
	{
		setAttr ($node1 + "_" + $node2 + "Ctrl.overrideEnabled") 1;
		setAttr ($node1 + "_" + $node2 + "Ctrl.overrideColor") 6;
	}
	
	if (!`objExists ("RRM_" + $prfx + $modName + "_ConnectorGrp")`)
	{
		group -em -n ("RRM_" + $prfx + $modName + "_ConnectorGrp"); xform -os -piv 0 0 0;
		setAttr ("RRM_" + $prfx + $modName + "_ConnectorGrp.inheritsTransform") 0;
		parent ("RRM_" + $prfx + $modName + "_ConnectorGrp") ("RRM_" + $prfx + $modName);
		
		if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
		{
			connectAttr -f  ("RRM_" + $prfx + $modName + "_Parent.connectors") ("RRM_" + $prfx + $modName + "_ConnectorGrp.v");
		}
		else
		{
			connectAttr -f  ("RRM_" + $prfx + $modName + "_Aux.connectors") ("RRM_" + $prfx + $modName + "_ConnectorGrp.v");
		}
	}
	parent ($node1 + "_" + $node2 + "Ctrl") ($node1 + "_" + $node2 + "_AimLctr") ("RRM_" + $prfx + $modName + "_ConnectorGrp");
	setAttr (($node1 + "_" + $node2 + "_AimLctr.scale"), 1,1,1);
	
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.tx");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.ty");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.tz");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.rx");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.ry");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.rz");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.sx");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.sy");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.sz");
	setAttr -lock true -keyable false -channelBox false ($node1 + "_" + $node2 + "Ctrl.v");	
	
	
	$modNodes = `ls -sl`;
	RRM_ProxyLockNodes($modNodes);
	select $selection;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;	
}
	

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////MAIN & ROOT/////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyMainProxy(int $checkTemplate)
{

	
	if (`objExists "RRM_MAIN"`)
	{
		string $selectControl = `confirmDialog
			-title "A Proxy Rig Already Exists In This Scene"
			-message "You must either delete the existing Proxy rig or RRM_Generate a final rig before creating a new Proxy rig."
			-button "OK"
			-defaultButton "OK"
			-icon "information"`;
	}
	else
	{
		//SET UNITS TO CENTIMETERS
		string $crntUnit = `currentUnit -query -linear`;

		//if ($crntUnit != "cm")
		//{
		//	//changeLinearUnit "centimeter"
		//}
		
		curve -n RRM_MAIN -d 1 -p 0 0 11 -p 2 0 9 -p 2 0 7 -p 7 0 7 -p 7 0 2 -p 9 0 2 -p 10 0 0 -p 9 0 -2 -p 7 0 -2 -p 7 0 -7 -p 2 0 -7 -p 2 0 -9 -p 0 0 -10 -p -2 0 -9 -p -2 0 -7 -p -7 0 -7 -p -7 0 -2 -p -9 0 -2 -p -10 0 0 -p -9 0 2 -p -7 0 2 -p -7 0 7 -p -2 0 7 -p -2 0 9 -p 0 0 11 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 ;
		pickWalk -d down;
		rename RRM_MAINShape;
		
		curve -n RRM_MAIN2 -d 1 -p 6.5 0 6.5 -p 6.5 0 -6.5 -p -6.5 0 -6.5 -p -6.5 0 6.5 -p 6.5 0 6.5 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		pickWalk -d down;
		rename RRM_MAINShape2;
		parent -r -s RRM_MAINShape2 RRM_MAIN;
		delete RRM_MAIN2;
		delete -ch RRM_MAIN;

		setAttr -lock true -keyable false -channelBox false "RRM_MAIN.tx";
		setAttr -lock true -keyable false -channelBox false "RRM_MAIN.ty";
		setAttr -lock true -keyable false -channelBox false "RRM_MAIN.tz";
		setAttr -lock true -keyable false -channelBox false "RRM_MAIN.rx";
		setAttr -lock true -keyable false -channelBox false "RRM_MAIN.ry";
		setAttr -lock true -keyable false -channelBox false "RRM_MAIN.rz";
		setAttr -lock true -keyable false -channelBox false "RRM_MAIN.v";
    	
		transformLimits -sx 0.01 1 -esx 1 0 RRM_MAIN;
		transformLimits -sy 0.01 1 -esy 1 0 RRM_MAIN;
		transformLimits -sz 0.01 1 -esz 1 0 RRM_MAIN;
		
		RRM_CreateProxyRootProxy($crntUnit);
    	
		transformLimits -sx 0.01 1 -esx 1 0 RRM_ROOT;
		transformLimits -sy 0.01 1 -esy 1 0 RRM_ROOT;
		transformLimits -sz 0.01 1 -esz 1 0 RRM_ROOT;

		setAttr -lock true -keyable false -channelBox false "RRM_ROOT.v";
    	
		setAttr "RRM_ROOT.overrideEnabled" 1;
		setAttr "RRM_ROOT.overrideColor" 17;
		
		parent RRM_ROOT RRM_MAIN;
    	
		addAttr -ln "core" -dt "string" RRM_MAIN;
		setAttr -e-keyable true RRM_MAIN.core;
		setAttr -type "string" RRM_MAIN.core "MAIN";
		setAttr -l true "RRM_MAIN.core";	
    	
		setAttr -type "string" RRM_ROOT.core "ROOT";
		setAttr -l true "RRM_ROOT.core";
		
		RRM_CreateProxyCOG_C($crntUnit);
		//ADD CORE ATTRIBUTE
		addAttr -ln "core" -dt "string" RRM_COG;
		setAttr -e-keyable true RRM_COG.core;
		
		//ADD EXT ATTRIBUTE
		addAttr -ln "ext" -dt "string" RRM_COG;
		setAttr -e-keyable true RRM_COG.ext;
	
		//ADD CLONE ATTRIBUTE
		addAttr -ln "clone" -dt "string" RRM_COG;
		setAttr -e-keyable true RRM_COG.clone;
	
		//ADD MODNAME ATTRIBUTE
		addAttr -ln "modName" -dt "string" RRM_COG;
		setAttr -e-keyable true RRM_COG.modName;

		setAttr -type "string" RRM_COG.core "COG_Ctrl";
		setAttr -l true "RRM_COG.core";

		parent RRM_COG RRM_ROOT;
		
		addAttr -ln "template_COG_Ctrl"  -at bool  RRM_ROOT;
		setAttr -e-keyable true RRM_ROOT.template_COG_Ctrl;
		setAttr RRM_ROOT.template_COG_Ctrl 1;
		connectAttr -f RRM_ROOT.template_COG_Ctrl RRM_COG.template;	
		
		setAttr -lock true -keyable false -channelBox false RRM_ROOT.v;
		
		
		//LAYER
		if (!`objExists RRM_ProxiesLayer`)
		{
			select RRM_MAIN;
			createDisplayLayer -n RRM_ProxiesLayer -number 1 -nr;
		}
		
		//PRESETS
		if ($checkTemplate == 1)
		{
			$RRM_TemplateType = `optionMenu -q -sl RRM_TemplateType`;
			if ($RRM_TemplateType == 1)
			{//HUMAN BIPED
				move -r -os -wd 0 16 0 RRM_ROOT;
				select RRM_ROOT;
				RRM_CreateProxySpline("Spine", 4, 0);
				move -r -os -wd 0 4 0 RRM_Spine_Top;
				//ARMS
				select RRM_Spine_Top;
				RRM_CreateProxyArm("Arm", 0, 0, 0, 1, 2);
				//HANDS
				select RRM_l_Arm_Wrist;
				RRM_CreateProxyFKChain("Finger", 4, 4, 1, 0, 1);
				select RRM_l_Arm_Wrist;
				RRM_CreateProxyFKChain("Thumb", 1, 4, 3, 0, 1);
				move -r -os -wd 1 0 -1 RRM_l_Thumb_01_01;
				move -r -os -wd -1 0 -1 RRM_r_Thumb_01_01;
				//HEAD
				select RRM_Spine_Top;
				RRM_CreateProxySpline("Neck", 2, 0);
				move -r -os -wd 0 -4.5 0 RRM_Neck_Top;
				select RRM_Neck_Top;
				RRM_CreateProxyHead("Head", 1, 0);
				select RRM_Head_Top;
				RRM_CreateProxyLookAt("Eye", 1, 3, 0, 1);
				move -r -os -wd 0 -1 0 RRM_l_Eye_Parent RRM_r_Eye_Parent;
				//LEGS
				select RRM_ROOT;
				RRM_CreateProxyLeg("Leg", 0, 0, 0, 1, 2);
			}
			else if ($RRM_TemplateType == 2)
			{//QUADRUPED
				move -r -os -wd 0 10 -7 RRM_ROOT;
				rotate -r 0 0 0 RRM_ROOT;
				select RRM_ROOT;
				RRM_CreateProxySpline("Spine", 4, 0);
				rotate -r -os 90 0 0 RRM_Spine_Parent;
				move -r -os -wd 0 4 0 RRM_Spine_Top;
				//HIND LEGS
				select RRM_ROOT;
				RRM_CreateProxyLeg("HindLeg", 0, 0, 0, 2, 2);
				//FRONT LEGS
				select RRM_Spine_Top;
				RRM_CreateProxyFKChain("Clavicle", 1, 1, 1, 0, 1);
				move -r -os -wd -3 0 0 RRM_l_Clavicle_01_01;
				move -r -os -wd -.5 0 0 RRM_l_Clavicle_Parent;
				select RRM_l_Clavicle_01_01;
				RRM_CreateProxyLeg("FrontLeg", 0, 0, 0, 1, 2);
				rotate -r -os -90 0 0 RRM_l_FrontLeg_Parent;
				move -r -os -wd -1 0 0 RRM_l_FrontLeg_Hip;
				//HEAD
				select RRM_Spine_Top;
				RRM_CreateProxySpline("Neck", 2, 0);
				rotate -r -90 0 0 RRM_Neck_Parent;
				move -r 0 -4 0 RRM_Neck_Top;
				select RRM_Neck_Top;
				RRM_CreateProxyHead("Head", 1, 0);
				select RRM_Head_Top;
				RRM_CreateProxyLookAt("Eye", 1, 3, 0, 1);
				move -r -os -wd 0 -1 0 RRM_l_Eye_Parent RRM_r_Eye_Parent;	
				RRM_LeftToRightProxies(3);
			}
			else if ($RRM_TemplateType == 3)
			{//ARACHNID
				setAttr RRM_ROOT.ty 2;
				//FRONT LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg("FrontLeg", 0, 0, 0, 2, 2);
				setAttr ("RRM_l_FrontLeg_Parent.translate", 0.625, 0, 1.1);
				setAttr ("RRM_l_FrontLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_FrontLeg_Hip.ry" 37;
				setAttr ("RRM_l_FrontLeg_Ground.translate", 9.45, 0, 11.8);
				setAttr ("RRM_l_FrontLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_FrontLeg_Ankle.translate",  -1.96, 1.86, -0.1);
				setAttr ("RRM_l_FrontLeg_Ankle.rotate", 45, 58.7, 0);
				setAttr "RRM_l_FrontLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_FrontLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_FrontLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_FrontLeg_Toe.tz" -1;
				setAttr ("RRM_l_FrontLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_FrontLeg_Knee1.translate", 0, 1.6, 3.75);
				//MIDFRONT LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg("MidFrontLeg", 0, 0, 0, 2, 2);
				setAttr ("RRM_l_MidFrontLeg_Parent.translate", 0.86, 0, 0.36);
				setAttr ("RRM_l_MidFrontLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_MidFrontLeg_Hip.ry" 60;
				setAttr ("RRM_l_MidFrontLeg_Ground.translate", 13.706, 0, 7.152);
				setAttr ("RRM_l_MidFrontLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_MidFrontLeg_Ankle.translate", -2.9, 1.8, 0.8);
				setAttr ("RRM_l_MidFrontLeg_Ankle.rotate", 46, 37.6, 0);
				setAttr "RRM_l_MidFrontLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_MidFrontLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_MidFrontLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_MidFrontLeg_Toe.tz" -1;
				setAttr ("RRM_l_MidFrontLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_MidFrontLeg_Knee1.translate", 0, 1.6, 3.75);
				//MID BACK LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg("MidBackLeg", 0, 0, 0, 2, 2);
				setAttr ("RRM_l_MidBackLeg_Parent.translate", 0.91, 0, -.431);
				setAttr ("RRM_l_MidBackLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_MidBackLeg_Hip.ry" 99.25;
				setAttr ("RRM_l_MidBackLeg_Ground.translate", 15.47, 0, -3.2);
				setAttr ("RRM_l_MidBackLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_MidBackLeg_Ankle.translate", -3.3, 1.85, 3);
				setAttr ("RRM_l_MidBackLeg_Ankle.rotate", -5.55, 5.57, -45);
				setAttr "RRM_l_MidBackLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_MidBackLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_MidBackLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_MidBackLeg_Toe.tz" -1;
				setAttr ("RRM_l_MidBackLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_MidBackLeg_Knee1.translate", 0, 1.6, 3.75);
				//BACK LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg("BackLeg", 0, 0, 0, 2, 2);
				setAttr ("RRM_l_BackLeg_Parent.translate", 0.493, 0, -1.112);
				setAttr ("RRM_l_BackLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_BackLeg_Hip.ry" 152.5;
				setAttr ("RRM_l_BackLeg_Ground.translate", 7.25, 0, -14.65);
				setAttr ("RRM_l_BackLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_BackLeg_Ankle.translate", -1.49, 1.85, 5.6);
				setAttr ("RRM_l_BackLeg_Ankle.rotate", -57.74, 40.14, -67.9);
				setAttr "RRM_l_BackLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_BackLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_BackLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_BackLeg_Toe.tz" -1;
				setAttr ("RRM_l_BackLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_BackLeg_Knee1.translate", 0, 1.6, 3.75);
				//ABDOMEN
				select RRM_ROOT;
				RRM_CreateProxyFKChain("Abdomen", 1, 5, 0, 3, 0);
				setAttr "RRM_Abdomen_Parent.tz" -0.73;
				setAttr ("RRM_Abdomen_Parent.scale", 0.76, 0.76, 0.76);
				setAttr "RRM_Abdomen_01_01.tz" 2.44;
				setAttr "RRM_Abdomen_01_01.rx" 26.7;
				setAttr "RRM_Abdomen_01_02.rx" -9.45;
				setAttr "RRM_Abdomen_01_03.rx" -9.45;
				setAttr "RRM_Abdomen_01_04.rx" -9.45;
				setAttr "RRM_Abdomen_01_05.rx" -9.45;
				//EYES
				select RRM_ROOT;
				RRM_CreateProxyLookAt("Eye", 1, 3, 0, 1);
				setAttr ("RRM_l_Eye_Parent.scale", 0.6, 0.6, 0.6);
				setAttr ("RRM_l_Eye_Parent.translate", 0.41, 0.77, 0.84);
				setAttr "RRM_l_Eye_01.tz" -.315;
				//PEDIPALPS
				select RRM_ROOT;
				RRM_CreateProxyFKChain("Pedipalp", 1, 6, 0, 0, 1);
				setAttr ("RRM_l_Pedipalp_Parent.translate", 0.72, -.025, 1.27);
				setAttr "RRM_l_Pedipalp_Parent.ry" 22;
				setAttr ("RRM_l_Pedipalp_Parent.scale", 0.6, 0.6, 0.6);
				setAttr "RRM_l_Pedipalp_01_01.tz" -2.864;
				setAttr ("RRM_l_Pedipalp_01_02.translate", 0, -0.078, -0.026);
				setAttr "RRM_l_Pedipalp_01_02.rx" 19;
				setAttr "RRM_l_Pedipalp_01_03.ty" -.53;
				setAttr "RRM_l_Pedipalp_01_03.rx" 31.68;
				setAttr ("RRM_l_Pedipalp_01_04.translate", 0, -0.205, -0.491);
				setAttr "RRM_l_Pedipalp_01_04.rx" 32;
				setAttr ("RRM_l_Pedipalp_01_05.translate", 0, -0.225, -0.228);
				setAttr "RRM_l_Pedipalp_01_05.rx" 20.7;
				setAttr "RRM_l_Pedipalp_01_05.sz" 0.825;
				setAttr ("RRM_l_Pedipalp_01_06.translate", 0, -0.06, -0.5);
				setAttr "RRM_l_Pedipalp_01_06.rx" 2.5;
				//CHELICERAE
				select RRM_ROOT;
				RRM_CreateProxyFKChain("Chelicera", 1, 3, 0, 0, 1);
				setAttr ("RRM_l_Chelicera_Parent.translate", 0.33, -0.13, 1.5);
				setAttr ("RRM_l_Chelicera_Parent.scale", 0.4, 0.4, 0.4);
				setAttr "RRM_l_Chelicera_01_01.tz" -2.14;
				setAttr "RRM_l_Chelicera_01_01.rx" 70;
				setAttr ("RRM_l_Chelicera_01_02.translate", 0, -0.188, -0.185);
				setAttr "RRM_l_Chelicera_01_02.rx" 32.5;
				setAttr ("RRM_l_Chelicera_01_03.translate", 0, -0.165, 0.095);
				setAttr "RRM_l_Chelicera_01_03.rx" 9;
				RRM_LeftToRightProxies(3);
			}
			else if ($RRM_TemplateType == 4)
			{//BIRD
				move -r -os -wd 0 10 -3 RRM_ROOT;
				rotate -r 90 0 0 RRM_ROOT;
				setAttr "RRM_ROOT.template_COG_Ctrl" 0;
				setAttr ("RRM_COG.translate", 0, 5, 0);
				setAttr ("RRM_COG.scale", 0.5, 0.5, 0.5);
				setAttr "RRM_ROOT.template_COG_Ctrl" 1;
				
				select RRM_ROOT;
				//LEGS
				RRM_CreateProxyLeg("Leg", 0, 0, 0, 1, 2);
				rotate -r -90 0 0 "RRM_l_Leg_Parent";
				move -r -os -wd 0 0.5 1 "RRM_l_Leg_Knee";
				move -r -os -wd 0 0.75 0 "RRM_l_Leg_Ankle";
				move -r -os -wd 0 0.5 -1.5 "RRM_l_Leg_Ball";
				move -r -os -wd 0 0 -2.5 "RRM_l_Leg_Toe";
				//TOES
				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain("InnerToe", 1, 4, 3, 0, 1);
				setAttr ("RRM_l_InnerToe_Parent.translate", -.45, 0.2, 0.4);
				setAttr ("RRM_l_InnerToe_Parent.rotate", 0, -25, 0);
				setAttr ("RRM_l_InnerToe_Parent.scale", 0.6, 0.6, 0.6);
				setAttr ("RRM_l_InnerToe_01_01.translate", 0, 0, -3);
				
				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain("MiddleToe", 1, 5, 3, 0, 1);
				setAttr ("RRM_l_MiddleToe_Parent.translate", 0, 0.2, 0.5);
				setAttr ("RRM_l_MiddleToe_Parent.scale", 0.5, 0.5, 0.5);
				setAttr ("RRM_l_MiddleToe_01_01.translate", 0, 0, -3);
				
				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain("OuterToe", 1, 6, 3, 0, 1);
				setAttr ("RRM_l_OuterToe_Parent.translate", .55, 0.2, 0.15);
				setAttr ("RRM_l_OuterToe_Parent.rotate", 0, 25, 0);
				setAttr ("RRM_l_OuterToe_Parent.scale", 0.5, 0.5, 0.5);
				setAttr ("RRM_l_OuterToe_01_01.translate", 0,0,-3);

				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain("HindToe", 1, 5, 0, 3, 1);
				setAttr ("RRM_l_HindToe_Parent.translate", 0, 0.2, -0.5);
				setAttr ("RRM_l_HindToe_Parent.scale", 0.5, 0.5, 0.5);
				setAttr ("RRM_l_HindToe_01_01.translate", 0, 0, 3);

				//TAIL
				select RRM_ROOT;
				RRM_CreateProxyFKChain("Tail", 1, 4, 0, 2, 0);
				setAttr ("RRM_Tail_Parent.scale", 0.75, 0.75, 0.75);
				setAttr ("RRM_Tail_Parent.translate", 0, 2, 0);
				
				//SPINE
				select RRM_ROOT;
				RRM_CreateProxySpline("Spine", 4, 0);
				setAttr ("RRM_Spine_Top.translate", 0, -1, 0); 
				
				//WINGS
				select "RRM_Spine_Top";
				RRM_CreateProxyArm("Wing", 0, 0, 0, 2, 2);
				setAttr ("RRM_l_Wing_Parent.translate", 0, 0, 1.75);

				setAttr ("RRM_l_Wing_Clavicle.translate", -.85, 0, 0.6);
				
				setAttr ("RRM_l_Wing_Shoulder.translate", -1.5, 0, -2.5);
				setAttr ("RRM_l_Wing_Shoulder.rotate", 90, 0, 0);
				
				setAttr ("RRM_l_Wing_Shoulder.translate", -1.5, 0, -2.5);
				setAttr ("RRM_l_Wing_Shoulder.rotate", 90, 0, 0);
				
				setAttr ("RRM_l_Wing_Elbow1.translate", 0, 0, 0.1);
				setAttr ("RRM_l_Wing_Elbow2.translate", 0.6, 0, 0);
				
				setAttr ("RRM_l_Wing_Wrist.translate", -1.5, 0, -2.5);
				
				//DIGITS
				select "RRM_l_Wing_Elbow2";
				RRM_CreateProxyFKChain("Alula", 1, 2, 1, 0, 1);
				setAttr ("RRM_l_Alula_Parent.translate", 0.5, 0, -0.5);
				setAttr ("RRM_l_Alula_Parent.rotate", 90, 0, 0);
				setAttr ("RRM_l_Alula_Parent.scale", 0.5, 0.5, 0.5);
				
				setAttr ("RRM_l_Alula_01_01.translate", -3, 0, 0);
				
				select "RRM_l_Wing_Wrist";
				RRM_CreateProxyFKChain("Digit", 1, 2, 1, 0, 1);
				setAttr ("RRM_l_Digit_01_01.translate", -2.5, 0, 0);
				
				//NECK
				select "RRM_Spine_Top";
				RRM_CreateProxySpline("Neck", 6, 0);
				setAttr ("RRM_Neck_Top.translate", 0, -5.5, -5.5);
				setAttr ("RRM_Neck_Top.rotate", -90, 0, 0);
				
				setAttr ("RRM_Neck_01.translate", 0, 0.845, 0.563);
				setAttr ("RRM_Neck_01.rotate", -20, 0, 0);

				setAttr ("RRM_Neck_02.translate", 0, 1.314, 0.77);
				setAttr ("RRM_Neck_02.rotate", -57, 0, 0);

				setAttr ("RRM_Neck_03.translate", 0, 1.352, 0.582);
				setAttr ("RRM_Neck_03.rotate", -90, 0, 0);

				setAttr ("RRM_Neck_04.translate", 0, 1.014, 0.376);
				setAttr ("RRM_Neck_04.rotate", -100, 0, 0);

				setAttr ("RRM_Neck_05.translate", 0, 0.563, 0.207);
				setAttr ("RRM_Neck_05.rotate", -101, 0, 0);

				setAttr ("RRM_Neck_06.translate", 0, 0.225, 0.075);
				setAttr ("RRM_Neck_06.rotate", -90, 0, 0);
				
				//HEAD
				select "RRM_Neck_Top";
				RRM_CreateProxyHead("Head", 1, 0);
				setAttr ("RRM_Head_Top.translate", 0, 2, 0);
				setAttr ("RRM_Head_Jaw.translate", 0, 0.5, 0.4);
				setAttr ("RRM_Head_JawEnd.translate", 0, 0, 2.5);
				setAttr ("RRM_Head_JawEnd.rotate", 90, 0, 0);
				
				select "RRM_Head_Top";
				RRM_CreateProxyLookAt("Eye", 1, 1, 0, 1);
				setAttr ("RRM_l_Eye_Parent.translate", 0.2, -0.6, 1);
				setAttr ("RRM_l_Eye_Parent.scale", 0.75, 0.75, 0.75);
				setAttr ("RRM_l_Eye_01.translate", -1, 0, 0);

				RRM_LeftToRightProxies(3);
			}
		}
		
		//if ($crntUnit == "m")
		//{
		//	setAttr ("RRM_MAIN.scale", 10,10,10);
		//}
    	
		$modNodes = `ls RRM_ROOT RRM_MAIN`;
		RRM_ProxyLockNodes($modNodes);
		select RRM_ROOT;
    	
		//REVERT UNITS
		if ($crntUnit != "cm")
		{
			//changeLinearUnit "centimeter"
		}
		changeLinearUnit $crntUnit;
	}
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;	
}

//ATTACH TO RIG
global proc RRM_AttachToRig(string $attachMod, string $modName, string $prfx, string $crntSide, string $oppSide, string $attachModCore, int $mirrorMod, int $mirrorCheck)
{

	if ($mirrorMod == $mirrorCheck)
	{
		if (`objExists ($attachMod + ".pair")`)
		{
			string $side = `getAttr ($attachMod + ".pair")`;
			if ($side == $crntSide)
			{
				parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
				scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
				setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;
				
				//ADD ATTACH NODE NAME
				if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
				}
				else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
				}
			}
			else if ($side == $oppSide)
			{
				//print ("RRM_" + $prfx + $modName + " is opposite\n");
				$sideCheck = `getAttr ($attachMod + ".opposite")`;
				parentConstraint ("RRM_" + $sideCheck) "RRM_MAIN" ("RRM_" + $prfx + $modName);
				scaleConstraint ("RRM_" + $sideCheck) "RRM_MAIN" ("RRM_" + $prfx + $modName);
				setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;

				//ADD ATTACH NODE NAME
				if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $sideCheck;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
				}
				else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $sideCheck;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
				}
			}
		}
		else
		{
			parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
			scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
			setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
			setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;			

			//ADD ATTACH NODE NAME
			if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
			{
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
			}
			else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
			{
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
			}
		}
	
	}
	else
	{
		parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
		scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
		setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
		setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;

		//ADD ATTACH NODE NAME
		if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
		}
		else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
		}
	}

	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////SPLINE////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxySpline2(string $modName, int $mirrorMod, string $prfx, string $oppPrfx, int $splineNum, string $crntUnit)
{
	$i1 = 1;
	$i2 = $splineNum;
	string $nPd = "_0";
	string $nPdPrev = "_0";
	
	while ($i1 <= $splineNum)
	{
		if ($i1 >= 10)
		{$nPd = "_";}
		if ($i1 >= 11)
		{$nPdPrev = "_";}
	
		//SET SPLINE NUM IN PARENT NODE
		lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.splineNum");
		setAttr ("RRM_" + $prfx + $modName + "_Parent.splineNum") $splineNum;
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.splineNum");
		//SET SPLINE NUM IN TOP NODE
		lockNode -lock off ("RRM_" + $modName);
		setAttr -l false ("RRM_" + $modName + ".jointsNum");
		setAttr ("RRM_" + $modName + ".jointsNum") $splineNum;
		setAttr -l true ("RRM_" + $modName + ".jointsNum");

		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + $nPd + $i1);
		group -n ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp") ("RRM_" + $prfx + $modName + $nPd + $i1); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".core") ($prfx + $modName + $nPd + $i1);
		setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".ext") ($nPd + $i1);
		setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".ext");

		if ($mirrorMod == 1)
		{
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + $nPd + $i1);
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite") ($oppPrfx + $modName + $nPd + $i1);
			setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite");
		}
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top")  ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp");
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ParentW0") $i2;
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_TopW1") $i1;		
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + ".overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + ".overrideColor") 29;
		
		//CONNECTORS
		int $prev = ($i1 -1);
		if ($i1 == 1){
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + $nPd + $i1));
		}
		else if ($i1 != $splineNum){
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + $nPdPrev + $prev), ("RRM_" + $prfx + $modName + $nPd + $i1));
		}
		else{
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + $nPdPrev + $prev), ("RRM_" + $prfx + $modName + $nPd + $i1));
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + $nPd + $i1), ("RRM_" + $prfx + $modName + "_Top"));
		}
			

			
		$i1++;
		$i2--;
		
	}
}
		
global proc RRM_CreateProxySpline(string $modName, int $splineNum, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	$attachModNum = `size $attachMod`;

	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$posOffset = 0;
		}
		
		if (`objExists ($attachMod[0] + (".opposite"))`)
		{
			$posOffset = 0;
		}
		
		//CREATE JOINT BASE
		RRM_CreateProxyParentProxy($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		move -r $posOffset 0 0 ("RRM_" + $prfx + $modName + "_Parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "spline";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 29;
		
		//ADD SPINE NUMBERS TO PARENT
		addAttr -ln "splineNum"  -at long -dv 1 ("RRM_" + $prfx + $modName + "_Parent");

		
		RRM_CreateProxyEndProxy($crntUnit);
		rename RRM_End ("RRM_" + $prfx + $modName + "_Top");
		parent ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Top");
		move -r 0 7 0 ("RRM_" + $prfx + $modName + "_Top");
		makeIdentity -apply true -t 1 ("RRM_" + $prfx + $modName + "_Top");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.core") ($prfx + $modName + "_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.core");
			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.ext") ("_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Top.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Top.overrideColor") 29;
	
		if ($mirrorMod == 1)
		{
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");
	
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Top.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.opposite") ($oppPrfx + $modName + "_Top");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.opposite");

			//ADD EXTRA ATTRIBUTES
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable true ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
		}	
	
		//ADD SPINE NUMBERS TO TOP GROUP
		if ($i == 0)
		{
			addAttr -ln "jointsNum"  -at long -dv 1 ("RRM_" + $modName);
		}

		RRM_CreateProxySpline2($modName, $mirrorMod, $prfx, $oppPrfx, $splineNum, $crntUnit);
	
		//ADD EXTRA ATTRIBUTES
		if ($mirrorMod == 1)
		{
			select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top")
			("RRM_" + $prfx + $modName + "_??");
			
			$RRM_Splines = `ls -sl`;
			string $crntMod;
			for ($crntMod in $RRM_Splines)
			{
				//PAIR AND TYPE
				addAttr -ln "pair"  -dt "string"  $crntMod;
				setAttr -e-keyable true ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
			}
		}
			

		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
	
		select ("RRM_" + $prfx + $modName + "_*Grp");
		select -d ("RRM_" + $prfx + $modName + "_ConnectorGrp");
		$modGroups = `ls-sl`;
		string $selectedModGroup;
		for ($selectedModGroup in $modGroups)
		{
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".tx");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".ty");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".tz");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".rx");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".ry");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".rz");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".sx");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".sy");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".sz");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + ".v");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + "_pointConstraint1.nds");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + "_pointConstraint1.ox");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + "_pointConstraint1.oy");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + "_pointConstraint1.oz");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + "_pointConstraint1.w0");
		setAttr -lock true -keyable false -channelBox false ($selectedModGroup + "_pointConstraint1.w1");
		}

		if (!`objExists ("RRM_" + $modName + ".top")`)
		{
			//ADD TOP ATTRIBUTE
			addAttr -ln "top"  -dt "string" ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".top");
			setAttr -type "string" ("RRM_" + $modName + ".top") "spline";
			setAttr -l true ("RRM_" + $modName + ".top");
			
			//ADD PARENT ATTRIBUTE
			$parentCore = `getAttr ($attachMod[0] + ".core")`;
			addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".parent");
			setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
			setAttr -l true ("RRM_" + $modName + ".parent");
			
			//ADD CORE NAME ATTRIBUTE
			addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".core");
			setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
			setAttr -l true ("RRM_" + $modName + ".core");


			parent ("RRM_" + $modName) $attachMod[0];
		}
		select ("RRM_" + $prfx + $modName + "_Parent");
		
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}
		
	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	
	RRM_ProxyLimits($xforms);
	
	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);
		
	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_SplinePrompts(string $modName, int $splineNum, int $mirrorMod)
{
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Rig's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique modName.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldSplineName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "A module already exists with this name. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			$attachModNum = `size $attachMod`;
			if ($attachModNum == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ($attachModNum > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxySpline($modName, $splineNum, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxySpline($modName, $splineNum, $mirrorMod);
				}
			}
		}
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////ARMS////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyArm2(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, string $crntUnit)
{
	//SET ARM NUM'S IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.upperRollNum") $upperArmNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum") $lowerArmNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.elbowNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.elbowNum") $elbowJoints;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.elbowNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.midRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.midRollNum") $elbowNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.midRollNum");
	
	
	//ELBOW
	if ($elbowJoints == 1)
	{
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Elbow");
		curve -n ("RRM_" + $prfx + $modName + "_ElbowAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_ElbowAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_ElbowAimShape") ("RRM_" + $prfx + $modName + "_Elbow");
		delete ("RRM_" + $prfx + $modName + "_ElbowAim");
		group -n ("RRM_" + $prfx + $modName + "_ElbowGrp") ("RRM_" + $prfx + $modName + "_Elbow"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ElbowGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ElbowGrp");		
		move -r ($multiplier * 6.45) 0 0 ("RRM_" + $prfx + $modName + "_ElbowGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ElbowGrp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.core") ($prfx + $modName + "_Elbow");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.ext") ("_Elbow");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Elbow.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow.overrideColor") 7;
	}
	else
	{
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Elbow1");
		curve -n ("RRM_" + $prfx + $modName + "_Elbow1Aim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Elbow1AimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_Elbow1AimShape") ("RRM_" + $prfx + $modName + "_Elbow1");
		delete ("RRM_" + $prfx + $modName + "_Elbow1Aim");
		group -n ("RRM_" + $prfx + $modName + "_Elbow1Grp") ("RRM_" + $prfx + $modName + "_Elbow1"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_Elbow1Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow1Grp");		
		move -r ($multiplier * 6.45) 0 0 ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow1Grp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.core") ($prfx + $modName + "_Elbow1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow1.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.ext") ("_Elbow1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow1.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1.overrideColor") 7;
		
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Elbow2");
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow2");
		curve -n ("RRM_" + $prfx + $modName + "_Elbow2Aim") -d 1 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 1 -p 0.5 0 1 -p 0 0 1.5 -p -0.5 0 1 -p -0.25 0 1 -p -0.25 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Elbow2AimShape");
		rotate -r 0 0 ($multiplier * 90) ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		parent -r -s ("RRM_" + $prfx + $modName + "_Elbow2AimShape") ("RRM_" + $prfx + $modName + "_Elbow2");
		delete ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		group -n ("RRM_" + $prfx + $modName + "_Elbow2Grp") ("RRM_" + $prfx + $modName + "_Elbow2"); xform -os -piv 0 0 0;
		parent ("RRM_" + $prfx + $modName + "_Elbow2Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow2Grp");
        
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.core") ($prfx + $modName + "_Elbow2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow2.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.ext") ("_Elbow2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow2.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Elbow2.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2.overrideColor") 7;
	}
	
	//ARM CONSTRAINTS
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_ElbowGrp");
		setAttr ("RRM_" + $prfx + $modName + "_ElbowGrp_pointConstraint1.offsetZ") -.0001;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		parent ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_ElbowGrp");
		
		pointConstraint -skip y -skip z ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector -1 0 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector -1 0 0
		-skip y -skip z ("RRM_" + $prfx + $modName + "_ElbowAimLctr") ("RRM_" + $prfx + $modName + "_Elbow");
		
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Clavicle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Clavicle"), ("RRM_" + $prfx + $modName + "_Shoulder"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Shoulder"), ("RRM_" + $prfx + $modName + "_Elbow"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow"), ("RRM_" + $prfx + $modName + "_Wrist"));
	}
	else
	{
		//CONNECT ELBOW 2
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" -skip x ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2Grp_pointConstraint1." + "RRM_" + $prfx + $modName + "_WristW1") 2;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
    
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
		parent ("RRM_" + $prfx + $modName + "_Elbow2AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_Elbow2AimLctr") ("RRM_" + $prfx + $modName + "_Elbow2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2AimLctr.v") 0;
        
		//CONNECT ELBOW 1
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1Grp_pointConstraint1.offsetZ") -.0001;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		parent ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		
		pointConstraint -skip y -skip z ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 1 0 0
		-skip y -skip z ("RRM_" + $prfx + $modName + "_ElbowAimLctr") ("RRM_" + $prfx + $modName + "_Elbow1");

		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Clavicle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Clavicle"), ("RRM_" + $prfx + $modName + "_Shoulder"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Shoulder"), ("RRM_" + $prfx + $modName + "_Elbow1"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow1"), ("RRM_" + $prfx + $modName + "_Elbow2"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow2"), ("RRM_" + $prfx + $modName + "_Wrist"));
	}	
	
	//UPPER ARM JOINTS
	if ($upperArmNum > 0)
	{
		$shoulderInf = $upperArmNum;
		$elbowInf = 1;
		$crntInt = 1;
		while ($crntInt <= $upperArmNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core") ($prfx + $modName + "_Upper" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext") ("_Upper" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Upper" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleZ") .125; 
			setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleX") .125;
			setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleY") .125;
			if ($crntUnit == "m")
			{
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleZ") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleX") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleY") .00125;
			}
			
			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ShoulderW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ElbowW1") $elbowInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ShoulderW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow1W1") $elbowInf;
			}

			//LOCK ATTRIBUTES
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sz");			

			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ty");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sz");		

			$shoulderInf--;
			$elbowInf++;
			$crntInt++;
		}
	}
		
	//LOWER ARM JOINTS
	if ($lowerArmNum > 0)                                                         
	{
		$elbowInf = $lowerArmNum;
		$wristInf = 1;
		$crntInt = 1;
		while ($crntInt <= $lowerArmNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core") ($prfx + $modName + "_Lower" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext") ("_Lower" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Lower" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleZ") .125;
			setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleX") .125;
			setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleY") .125;
			if ($crntUnit == "m")
			{
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleZ") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleX") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleY") .00125;
			}

			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ElbowW0") $elbowInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_WristW1") $wristInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow2W0") $elbowInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_WristW1") $wristInf;
			}

			//LOCK ATTRIBUTES
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sz");			

			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ty");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sz");		

			$elbowInf--;
			$wristInf++;
			$crntInt++;
		}
	}
	
	//ELBOW JOINTS
	if ($elbowJoints == 2)
	{
		if ($elbowNum > 0)
		{
			$elbow1Inf = $elbowNum;
			$elbow2Inf = 1;
			$crntInt = 1;
			while ($crntInt <= $elbowNum)
			{
				RRM_CreateProxyModuleProxy($crntUnit);
				rename RRM_Base ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				group -n ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				parent ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
				scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");

				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core") ($prfx + $modName + "_Middle" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext") ("_Middle" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext");
				if ($mirrorMod == 2)
				{
					addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair") ($crntSide);
					addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Middle" + $crntInt);
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair");
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite");
				}
				//SCALE LOCATOR
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleZ") .125;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleX") .125;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleY") .125;
				if ($crntUnit == "m")
				{
					setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleZ") .00125;
					setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleX") .00125;
					setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleY") .00125;
				}
				connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".template");
				
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow1W0") $elbow1Inf;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow2W1") $elbow2Inf;
				
				//LOCK ATTRIBUTES
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ry");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rz");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sy");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sz");			

				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ty");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tz");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ry");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rz");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sy");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sz");	
				
				$elbow1Inf--;
				$elbow2Inf++;
				$crntInt++;
			}
		}
	}
	
	//LOCK CHANNELS
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow.rx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow.ry");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow.rz");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow.sx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow.sy");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow.sz");
	}
	else
	{
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow1.rx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow1.ry");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow1.rz");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow1.sx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow1.sy");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow1.sz");
    
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow2.ry");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow2.rz");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow2.sx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow2.sy");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Elbow2.sz");
	}

	//ADD EXTRA ATTRIBUTES
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
		{
			select ("RRM_" + $prfx + $modName + "_Elbow");
		}
		else
		{
			select ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Elbow2");
		}
		
		$armMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $armMods)
		{
			//PAIR AND TYPE
			addAttr -ln "pair"  -dt "string"  $crntMod;
			setAttr -e-keyable true ($crntMod + ".pair");
			setAttr -type "string" ($crntMod + ".pair") $crntSide;
			setAttr -l true ($crntMod + ".pair");
			//OPPOSITE NAME
			addAttr -ln "opposite" -dt "string"  $crntMod;
			setAttr -e-keyable true ($crntMod + ".opposite");
		}
		if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.opposite") ($oppPrfx + $modName + "_Elbow");
		}
		else
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.opposite") ($oppPrfx + $modName + "_Elbow1");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.opposite") ($oppPrfx + $modName + "_Elbow2");
		}
		
		for ($crntMod in $armMods)
		{
			setAttr -l true ($crntMod + ".opposite");
		}
	}

	setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v")      0;
	setAttr ("RRM_" + $prfx + $modName + "_ElbowAimLctr.v") 0;
}

global proc RRM_CreateProxyArm(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	$attachModNum = `size $attachMod`;

	//ARM
	while ($i !=2)
	{	
		if ($mirrorMod != 2)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		if ($mirrorMod == 3)
		{
			$crntSide = "right";
			$oppSide = "left"; 
			$multiplier = -1;
		}
			
			
		//ATTACH NODE
		RRM_CreateProxyParentProxy($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		rotate -r 0 0 ($multiplier * -90) ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "arm";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 7;
		
		addAttr -ln "upperRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "lowerRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "elbowNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "midRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		
		//TEMPLATE ROLL JOINTS
		addAttr -ln "templateRollJoints"  -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -keyable 1 ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints");

		//CLAVICLE		
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Clavicle");
		group -n ("RRM_" + $prfx + $modName + "_ClavicleGrp") ("RRM_" + $prfx + $modName + "_Clavicle"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ClavicleGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		move -r ($multiplier * 1.25) 0 0 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.core") ($prfx + $modName + "_Clavicle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Clavicle.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.ext") ("_Clavicle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Clavicle.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Clavicle.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Clavicle.overrideColor") 7;
		
		//SHOULDER		
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Shoulder");
		group -n ("RRM_" + $prfx + $modName + "_ShoulderGrp") ("RRM_" + $prfx + $modName + "_Shoulder"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ShoulderGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ShoulderGrp");		
		move -r ($multiplier * 2.95) 0 0 ("RRM_" + $prfx + $modName + "_ShoulderGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ShoulderGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.core") ($prfx + $modName + "_Shoulder");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Shoulder.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.ext") ("_Shoulder");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Shoulder.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Shoulder.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Shoulder.overrideColor") 7;

		//WRIST
		RRM_CreateProxyEndProxy($crntUnit);		
		rename RRM_End ("RRM_" + $prfx + $modName + "_Wrist");
		rotate -r 0 0 ($multiplier * -90) ("RRM_" + $prfx + $modName + "_Wrist");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Wrist");
		group -n ("RRM_" + $prfx + $modName + "_WristGrp") ("RRM_" + $prfx + $modName + "_Wrist"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_WristGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_WristGrp");		
		move -r ($multiplier * 9.95) 0 0 ("RRM_" + $prfx + $modName + "_WristGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_WristGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.core") ($prfx + $modName + "_Wrist");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Wrist.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.ext") ("_Wrist");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Wrist.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Wrist.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Wrist.overrideColor") 7;

		RRM_CreateProxyArm2($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

		//ADD EXTRA ATTRIBUTES
		if ($mirrorMod == 2)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable true ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
				
			}
			
			select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Clavicle")
			("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist");
			
			$armMods = `ls -sl`;
			string $crntMod;
			for ($crntMod in $armMods)
			{
				//PAIR AND TYPE
				addAttr -ln "pair"  -dt "string"  $crntMod;
				setAttr -e-keyable true ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
				//OPPOSITE NAME
				addAttr -ln "opposite"  -dt "string"  $crntMod;
				setAttr -e-keyable true ($crntMod + ".opposite");
			}
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.opposite") ($oppPrfx + $modName + "_Clavicle");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.opposite") ($oppPrfx + $modName + "_Shoulder");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.opposite") ($oppPrfx + $modName + "_Wrist");
			
			for ($crntMod in $armMods)
			{
				setAttr -l true ($crntMod + ".opposite");
			}
		}
		else
		{
			//ADD LEFT OR RIGHT ATTRIBUTE
			addAttr -ln "single"  -dt "string" ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".single");
			setAttr -type "string" ("RRM_" + $modName + ".single") $crntSide;
			setAttr -l true ("RRM_" + $modName + ".single");
		}

		//ATTACH TO RIG
		int $mirrorCheck = 2;
		RRM_AttachToRig($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
	
		if (!`objExists ("RRM_" + $modName + ".top")`)
		{	
			//ADD TOP ATTRIBUTE
			addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".top");
			setAttr -type "string" ("RRM_" + $modName + ".top") "arm";
			setAttr -l true ("RRM_" + $modName + ".top");
			
			//ADD PARENT ATTRIBUTE
			$parentCore = `getAttr ($attachMod[0] + ".core")`;
			addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".parent");
			setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
			setAttr -l true ("RRM_" + $modName + ".parent");

			//ADD CORE NAME ATTRIBUTE
			addAttr -ln "core"  -dt "string" ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".core");
			setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
			setAttr -l true ("RRM_" + $modName + ".core");
			
			//ADD UPPER ARM NUM ATTRIBUTE
			addAttr -ln "upperArmNum"  -at long ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".upperArmNum");
			setAttr ("RRM_" + $modName + ".upperArmNum") $upperArmNum;
			setAttr -l true ("RRM_" + $modName + ".upperArmNum");
			
			//ADD LOWER ARM NUM ATTRIBUTE
			addAttr -ln "lowerArmNum"  -at long ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".lowerArmNum");
			setAttr ("RRM_" + $modName + ".lowerArmNum") $lowerArmNum;
			setAttr -l true ("RRM_" + $modName + ".lowerArmNum");

			//ADD ELBOW NUM ATTRIBUTE
			addAttr -ln "elbowNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".elbowNum");
			setAttr ("RRM_" + $modName + ".elbowNum") $elbowNum;
			setAttr -l true ("RRM_" + $modName + ".elbowNum");

			//ADD UPPER ARM NUM ATTRIBUTE
			addAttr -ln "elbowJoints" -at long ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".elbowJoints");
			setAttr ("RRM_" + $modName + ".elbowJoints") $elbowJoints;
			setAttr -l true ("RRM_" + $modName + ".elbowJoints");
			
			parent ("RRM_" + $modName) $attachMod[0];
		}
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	
		if ($mirrorMod != 2)
		{
			$i = 2;
		}
	}

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_ArmPrompts(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $mirrorMod)
{
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique modName.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldArmName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			$attachModNum = `size $attachMod`;
			if ($attachModNum == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ($attachModNum > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyArm($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyArm($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////LEGS////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyLeg2(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $posOffset, string $crntUnit)
{
	//SET ARM NUM'S IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.upperRollNum") $upperLegNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum") $lowerLegNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.kneeNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.kneeNum") $kneeJoints;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.kneeNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.midRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.midRollNum") $kneeNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.midRollNum");

	//KNEE
	if ($kneeJoints == 1)
	{
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Knee");
		curve -n ("RRM_" + $prfx + $modName + "_KneeAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_KneeAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_KneeAimShape") ("RRM_" + $prfx + $modName + "_Knee");
		delete ("RRM_" + $prfx + $modName + "_KneeAim");
		group -n ("RRM_" + $prfx + $modName + "_KneeGrp") ("RRM_" + $prfx + $modName + "_Knee"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_KneeGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_KneeGrp");		
		rotate -r 0 -180 90 ("RRM_" + $prfx + $modName + "_Knee");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_KneeGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_KneeGrp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.core") ($prfx + $modName + "_Knee");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.ext") ("_Knee");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Knee.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee.overrideColor") 31;
	}
	else
	{
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Knee1");
		curve -n ("RRM_" + $prfx + $modName + "_Knee1Aim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Knee1AimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_Knee1AimShape") ("RRM_" + $prfx + $modName + "_Knee1");
		delete ("RRM_" + $prfx + $modName + "_Knee1Aim");
		group -n ("RRM_" + $prfx + $modName + "_Knee1Grp") ("RRM_" + $prfx + $modName + "_Knee1"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_Knee1Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee1Grp");		
		rotate -r 0 -180 90 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee1Grp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.core") ($prfx + $modName + "_Knee1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee1.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.ext") ("_Knee1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee1.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Knee1.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee1.overrideColor") 31;
		
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Knee2");
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee2");
		curve -n ("RRM_" + $prfx + $modName + "_Knee2Aim") -d 1 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 1 -p 0.5 0 1 -p 0 0 1.5 -p -0.5 0 1 -p -0.25 0 1 -p -0.25 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Knee2AimShape");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Knee2Aim");
		parent -r -s ("RRM_" + $prfx + $modName + "_Knee2AimShape") ("RRM_" + $prfx + $modName + "_Knee2");
		delete ("RRM_" + $prfx + $modName + "_Knee2Aim");
		group -n ("RRM_" + $prfx + $modName + "_Knee2Grp") ("RRM_" + $prfx + $modName + "_Knee2"); xform -os -piv 0 0 0;
		parent ("RRM_" + $prfx + $modName + "_Knee2Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee2Grp");
		
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.rotateOrder") 1;
        
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.core") ($prfx + $modName + "_Knee2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee2.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.ext") ("_Knee2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee2.ext");
        
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.overrideColor") 31;
	}
	
	//LEG CONSTRAINTS
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_KneeGrp");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		parent ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_KneeGrp");
		
		pointConstraint -skip x -skip z ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 0 1 0
		-skip x -skip z ("RRM_" + $prfx + $modName + "_KneeAimLctr") ("RRM_" + $prfx + $modName + "_Knee");
		
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Hip"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Hip"), ("RRM_" + $prfx + $modName + "_Knee"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee"), ("RRM_" + $prfx + $modName + "_Ankle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ankle"), ("RRM_" + $prfx + $modName + "_Ball"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ball"), ("RRM_" + $prfx + $modName + "_Toe"));
	}
	else
	{
		//CONNECT KNEE 2
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" -skip y ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Knee2Grp_pointConstraint1." + "RRM_" + $prfx + $modName + "_AnkleW1") 2;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
    
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
		parent ("RRM_" + $prfx + $modName + "_Knee2AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_Knee2AimLctr") ("RRM_" + $prfx + $modName + "_Knee2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Knee2AimLctr.v") 0;
        
		//CONNECT KNEE 1
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Knee1Grp");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		parent ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Knee1Grp");
		
		pointConstraint -skip x -skip z ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 0 1 0
		-skip x -skip z ("RRM_" + $prfx + $modName + "_KneeAimLctr") ("RRM_" + $prfx + $modName + "_Knee1");

		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Hip"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Hip"), ("RRM_" + $prfx + $modName + "_Knee1"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee1"), ("RRM_" + $prfx + $modName + "_Knee2"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee2"), ("RRM_" + $prfx + $modName + "_Ankle"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ankle"), ("RRM_" + $prfx + $modName + "_Ball"));
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ball"), ("RRM_" + $prfx + $modName + "_Toe"));
	}	
	
	//UPPER LEG JOINTS
	if ($upperLegNum > 0)
	{
		$shoulderInf = $upperLegNum;
		$kneeInf = 1;
		$crntInt = 1;
		while ($crntInt <= $upperLegNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core") ($prfx + $modName + "_Upper" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext") ("_Upper" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Upper" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleZ") .125;
			setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleX") .125;
			setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleY") .125;
			if ($crntUnit == "m")
			{
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleZ") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleX") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScaleY") .00125;
			}

			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".template");
			
			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_HipW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_KneeW1") $kneeInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_HipW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee1W1") $kneeInf;
			}
			//LOCK ATTRIBUTES
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sz");			

			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ty");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sz");		

			$shoulderInf--;
			$kneeInf++;
			$crntInt++;
		}
	}

	//LOWER LEG JOINTS
	if ($lowerLegNum > 0)                                                         
	{
		$kneeInf = $lowerLegNum;
		$wristInf = 1;
		$crntInt = 1;
		while ($crntInt <= $lowerLegNum)
		{
			RRM_CreateProxyModuleProxy($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core") ($prfx + $modName + "_Lower" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext") ("_Lower" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Lower" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleZ") .125;
			setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleX") .125;
			setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleY") .125;
			if ($crntUnit == "m")
			{
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleZ") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleX") .00125;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScaleY") .00125;
			}
			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_KneeW0") $kneeInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_AnkleW1") $wristInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee2W0") $kneeInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_AnkleW1") $wristInf;
			}
			//LOCK ATTRIBUTES
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sz");			

			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ty");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ry");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rz");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sx");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sy");
			setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sz");		

			$kneeInf--;
			$wristInf++;
			$crntInt++;
		}
	}
	
	//KNEE JOINTS
	if ($kneeJoints == 2)
	{
		if ($kneeNum > 0)
		{
			$knee1Inf = $kneeNum;
			$knee2Inf = 1;
			$crntInt = 1;
			while ($crntInt <= $kneeNum)
			{
				RRM_CreateProxyModuleProxy($crntUnit);
				rename RRM_Base ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				group -n ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				parent ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
				scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");

				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core") ($prfx + $modName + "_Middle" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext") ("_Middle" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext");
				if ($mirrorMod == 2)
				{
					addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair") ($crntSide);
					addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Middle" + $crntInt);
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair");
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite");
				}
				//SCALE LOCATOR
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleZ") .125;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleX") .125;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleY") .125;
				if ($crntUnit == "m")
				{
					setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleZ") .00125;
					setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleX") .00125;
					setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScaleY") .00125;
				}
				connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".template");
				
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee1W0") $knee1Inf;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee2W1") $knee2Inf;
				
				//LOCK ATTRIBUTES
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ry");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rz");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sy");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sz");
				
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ty");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tz");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ry");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rz");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sx");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sy");
				setAttr -lock true -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sz");		

				$knee1Inf--;
				$knee2Inf++;
				$crntInt++;
			}
		}
	}
	
	//LOCK CHANNELS
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee.rx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee.ry");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee.rz");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee.sx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee.sy");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee.sz");
	}
	else
	{
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee1.rx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee1.ry");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee1.rz");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee1.sx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee1.sy");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee1.sz");
    
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee2.rx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee2.rz");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee2.sx");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee2.sy");
		setAttr -lock true -keyable false -channelBox false ("RRM_" + $prfx + $modName + "_Knee2.sz");
	}
    
	//ADD EXTRA ATTRIBUTES
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
		{
			select ("RRM_" + $prfx + $modName + "_Knee");
		}
		else
		{
			select ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Knee2");
		}
		
		$legMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $legMods)
		{
			//PAIR AND TYPE
			addAttr -ln "pair"  -dt "string"  $crntMod;
			setAttr -e-keyable true ($crntMod + ".pair");
			setAttr -type "string" ($crntMod + ".pair") $crntSide;
			setAttr -l true ($crntMod + ".pair");
			//OPPOSITE NAME
			addAttr -ln "opposite" -dt "string"  $crntMod;
			setAttr -e-keyable true ($crntMod + ".opposite");
		}
		if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.opposite") ($oppPrfx + $modName + "_Knee");
		}
		else
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.opposite") ($oppPrfx + $modName + "_Knee1");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.opposite") ($oppPrfx + $modName + "_Knee2");
		}
		
		for ($crntMod in $legMods)
		{
			setAttr -l true ($crntMod + ".opposite");
		}
		
		//COLOURS
		setAttr ($crntMod + ".overrideEnabled") 1;
		setAttr ($crntMod + ".overrideColor") 31;
	}

	setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v")      0;
	setAttr ("RRM_" + $prfx + $modName + "_KneeAimLctr.v") 0;
}

global proc RRM_CreateProxyLeg(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;

	
	string $prfx = "l_";
	string $oppPrfx = "r_";
	float $posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	
	float $rotOffset = -90;

	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	$attachModNum = `size $attachMod`;

	$i = 1;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 1)
		{
			$prfx = "";
			$prfx = "";
			$posOffset = 0;
			$rotOffset = 180; 
		}
			
		//ATTACH NODE
		RRM_CreateProxyParentProxy($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		rotate -r 0 0 $rotOffset ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "leg";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		addAttr -ln "upperRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "lowerRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "kneeNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "midRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");

		//TEMPLATE ROLL JOINTS
		addAttr -ln "templateRollJoints"  -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -keyable 1 ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints");

		//HIP		
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Hip");
		curve -n ("RRM_" + $prfx + $modName + "_HipAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rotate -r 180 0 -90	("RRM_" + $prfx + $modName + "_HipAim");
		makeIdentity -apply true ("RRM_" + $prfx + $modName + "_HipAim");
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_HipAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_HipAimShape") ("RRM_" + $prfx + $modName + "_Hip");
		delete ("RRM_" + $prfx + $modName + "_HipAim");
		group -n ("RRM_" + $prfx + $modName + "_HipGrp") ("RRM_" + $prfx + $modName + "_Hip"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_HipGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HipGrp");		
		move -r $posOffset -1 0 ("RRM_" + $prfx + $modName + "_HipGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HipGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.core") ($prfx + $modName + "_Hip");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Hip.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.ext") ("_Hip");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Hip.ext");

		//ANKLE
		RRM_CreateProxyModuleProxy($crntUnit);		
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Ankle");
		group -n ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Ankle"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_AnkleGrp");		
		move -r 0 1.5 0 ("RRM_" + $prfx + $modName + "_AnkleGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_AnkleGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.core") ($prfx + $modName + "_Ankle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ankle.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.ext") ("_Ankle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ankle.ext");

		//FOOT
		//FOOT GROUND
		circle -n ("RRM_" + $prfx + $modName + "_Ground") -c 0 0 0 -nr 0 1 0 -sw 360 -r 3.25 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;
		group -n ("RRM_" + $prfx + $modName + "_GroundGrp") ("RRM_" + $prfx + $modName + "_Ground"); xform -os -piv 0 0 0; 
		scale -r .8 1 1 ("RRM_" + $prfx + $modName + "_GroundGrp");
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_GroundGrp");
		move -r 0 0 2 ("RRM_" + $prfx + $modName + "_Ground.cv[0:7]");
		
		group -n ("RRM_" + $prfx + $modName + "_GroundGrp2") ("RRM_" + $prfx + $modName + "_GroundGrp"); xform -os -piv 0 0 0; 
		
		addAttr -ln "core" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Ground.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.core") ($prfx + $modName + "_Ground");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ground.core");
		
		addAttr -ln "ext" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Ground.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.ext") ("_Ground");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ground.ext");
		
		addAttr -ln "clone" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Ground.clone");

		addAttr -ln "modName" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Ground.modName");
		
		move -r 1.3 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[3]") ;
		move -r 0.2 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[2]") ("RRM_" + $prfx + $modName + "_GroundShape.cv[4]");
		move -r -1.3 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[7]") ;
		move -r -0.2 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[2]") ("RRM_" + $prfx + $modName + "_GroundShape.cv[4]");
		
		RRM_CreateProxyModuleProxy($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Ball");
		parent ("RRM_" + $prfx + $modName + "_Ball") ("RRM_" + $prfx + $modName + "_Ground");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Ball");		
		move -r 0 0 2.5 ("RRM_" + $prfx + $modName + "_Ball");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Ball");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.core") ($prfx + $modName + "_Ball");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ball.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.ext") ("_Ball");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ball.ext");

		RRM_CreateProxyEndProxy($crntUnit);
		rename RRM_End ("RRM_" + $prfx + $modName + "_Toe");
		parent ("RRM_" + $prfx + $modName + "_Toe") ("RRM_" + $prfx + $modName + "_Ground");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Toe");		
		move -r 0 0 4 ("RRM_" + $prfx + $modName + "_Toe");
		rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_Toe");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Toe");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.core") ($prfx + $modName + "_Toe");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Toe.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.ext") ("_Toe");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Toe.ext");

		//FOOT CONTROLS
		curve -n ("RRM_" + $prfx + $modName + "_FootRightTilt") -d 1 -p 0 0 -1 -p 0 0 1 -p 0 0 0 -p 1 0 0 -p -1 0 0 -p 0 0 0 -p 0 1 0 -p 0 -1 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_FootRightTiltShape");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootRightTiltB");
		setAttr ("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScaleZ") .25;
		setAttr ("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScaleX") .25;
		setAttr ("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScaleY") .25;
		if ($crntUnit == "m")
		{
			setAttr ("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScaleZ") .0025;
			setAttr ("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScaleX") .0025;
			setAttr ("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScaleY") .0025;
		}
		
		parent -r -s ("RRM_" + $prfx + $modName + "_FootRightTiltBShape") ("RRM_" + $prfx + $modName + "_FootRightTilt");
		delete ("RRM_" + $prfx + $modName + "_FootRightTiltB");

		parent ("RRM_" + $prfx + $modName + "_FootRightTilt") ("RRM_" + $prfx + $modName + "_Ground");
		move -r -1 0 2.5 ("RRM_" + $prfx + $modName + "_FootRightTilt");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_FootRightTilt");
		
		addAttr -ln "core" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_FootRightTilt.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.core") ($prfx + $modName + "_FootRightTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootRightTilt.core");
		
		addAttr -ln "ext" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_FootRightTilt.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.ext") ("_FootRightTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootRightTilt.ext");
		
		addAttr -ln "clone" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_FootRightTilt.clone");

		addAttr -ln "modName" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Ground.modName");

		duplicate -n ("RRM_" + $prfx + $modName + "_FootLeftTilt") ("RRM_" + $prfx + $modName + "_FootRightTilt");
		select ("RRM_" + $prfx + $modName + "_FootLeftTilt");
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_FootLeftTiltShape");
		move -r 2 0 0 ("RRM_" + $prfx + $modName + "_FootLeftTilt");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_FootLeftTilt");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_FootLeftTilt.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.core") ($prfx + $modName + "_FootLeftTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootLeftTilt.core");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_FootLeftTilt.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.ext") ("_FootLeftTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootLeftTilt.ext");

		duplicate -n ("RRM_" + $prfx + $modName + "_HeelPivot") ("RRM_" + $prfx + $modName + "_FootRightTilt"); 
		select ("RRM_" + $prfx + $modName + "_HeelPivot");
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_HeelPivotShape");
		move -r 1 0 -3 ("RRM_" + $prfx + $modName + "_HeelPivot");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HeelPivot");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_HeelPivot.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.core") ($prfx + $modName + "_HeelPivot");
		setAttr -l true ("RRM_" + $prfx + $modName + "_HeelPivot.core");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_HeelPivot.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.ext") ("_HeelPivot");
		setAttr -l true ("RRM_" + $prfx + $modName + "_HeelPivot.ext");

		//LOCK CHANNELS
		$footPivots = `ls ("RRM_" + $prfx + $modName + "_FootRightTilt") ("RRM_" + $prfx + $modName + "_FootLeftTilt") ("RRM_" + $prfx + $modName + "_HeelPivot")`;
		string $crntControl;
		for ($crntControl in $footPivots)
		{
			setAttr -lock true -keyable false -channelBox false ($crntControl + ".ty");
			setAttr -lock true -keyable false -channelBox false ($crntControl + ".rx");
			setAttr -lock true -keyable false -channelBox false ($crntControl + ".ry");
			setAttr -lock true -keyable false -channelBox false ($crntControl + ".rz");
			setAttr -lock true -keyable false -channelBox false ($crntControl + ".sx");
			setAttr -lock true -keyable false -channelBox false ($crntControl + ".sy");
			setAttr -lock true -keyable false -channelBox false ($crntControl + ".sz");
		}
		//CONNECT FOOT
		parent ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Ground");
		setAttr ("RRM_" + $prfx + $modName + "_AnkleGrp.ty") 0;
		
		RRM_CreateProxyLeg2($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $posOffset, $crntUnit);

		//ADD EXTRA ATTRIBUTES, CHANGE COLOURS
		select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Hip")
		("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Ball")
		("RRM_" + $prfx + $modName + "_Toe") ("RRM_" + $prfx + $modName + "_FootRightTilt")
		("RRM_" + $prfx + $modName + "_FootLeftTilt") ("RRM_" + $prfx + $modName + "_HeelPivot")
		("RRM_" + $prfx + $modName + "_Ground") ;

			
		$legMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $legMods)
		{
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string"  $crntMod;
				setAttr -e-keyable true ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
				
				addAttr -ln "opposite"  -dt "string" $crntMod;
				setAttr -e-keyable true ($crntMod + ".opposite");
			}

			//COLOURS
			setAttr ($crntMod + ".overrideEnabled") 1;
			setAttr ($crntMod + ".overrideColor") 31;
		}
		
		if ($mirrorMod == 2)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable true ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.opposite") ($oppPrfx + $modName + "_Hip");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.opposite") ($oppPrfx + $modName + "_Ankle");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.opposite") ($oppPrfx + $modName + "_Ball");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.opposite") ($oppPrfx + $modName + "_Toe");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.opposite") ($oppPrfx + $modName + "_Ground");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.opposite") ($oppPrfx + $modName + "_FootRightTilt");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.opposite") ($oppPrfx + $modName + "_FootLeftTilt");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.opposite") ($oppPrfx + $modName + "_HeelPivot");
	
			for ($crntMod in $legMods)
			{
				setAttr -l true ($crntMod + ".opposite");
			}
		}
		setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v") 0;
		setAttr ("RRM_" + $prfx + $modName + "_KneeAimLctr.v") 0;
		
		//ATTACH TO RIG
		int $mirrorCheck = 2;
		RRM_AttachToRig($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		pointConstraint -skip y ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_GroundGrp");
		parentConstraint -mo RRM_MAIN ("RRM_" + $prfx + $modName + "_GroundGrp2");
		parent ("RRM_" + $prfx + $modName + "_GroundGrp2") ("RRM_" + $prfx + $modName + "_Parent");
		scale 1 1 1 ("RRM_" + $prfx + $modName + "_GroundGrp") ("RRM_" + $prfx + $modName + "_GroundGrp2");


		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$rotOffset = 90;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "leg";
	setAttr -l true ("RRM_" + $modName + ".top");
	
	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");
	
	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD UPPER LEG NUM ATTRIBUTE
	addAttr -ln "upperLegNum" -at long ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".upperLegNum");
	setAttr ("RRM_" + $modName + ".upperLegNum") $upperLegNum;
	setAttr -l true ("RRM_" + $modName + ".upperLegNum");
	
	//ADD LOWER LEG NUM ATTRIBUTE
	addAttr -ln "lowerLegNum" -at long ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".lowerLegNum");
	setAttr ("RRM_" + $modName + ".lowerLegNum") $lowerLegNum;
	setAttr -l true ("RRM_" + $modName + ".lowerLegNum");

	//ADD KNEE NUM ATTRIBUTE
	addAttr -ln "kneeNum" -at long ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".kneeNum");
	setAttr ("RRM_" + $modName + ".kneeNum") $kneeNum;
	setAttr -l true ("RRM_" + $modName + ".kneeNum");

	//ADD UPPER LEG NUM ATTRIBUTE
	addAttr -ln "kneeJoints" -at long ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".kneeJoints");
	setAttr ("RRM_" + $modName + ".kneeJoints") $kneeJoints;
	setAttr -l true ("RRM_" + $modName + ".kneeJoints");	

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_LegPrompts(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $mirrorMod)
{
	string $name = `textField -q -text RRM_TextFieldLegName`;
	int $nameSize = `size $name`;

	if ($nameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($name))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($name)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldLegName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this name. Please use a unique name\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			$attachModNum = `size $attachMod`;
			if ($attachModNum == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ($attachModNum > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyLeg($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyLeg($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////FK CHAINS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyFKChain2(string $modName, int $chainsNum, int $jointsNum, int $direction, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, string $crntUnit, int $create)
{
	//SET FK NUM'S IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.chainNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.chainNum") $chainsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.chainNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jointNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.jointNum") $jointsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jointNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.direction");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.direction") $direction;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.direction");

	//SET FK NUM'S IN TOP NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $modName + ".chainsNum");
	setAttr ("RRM_" + $modName + ".chainsNum") $chainsNum;
	setAttr -l true ("RRM_" + $modName + ".chainsNum");

	setAttr -l false ("RRM_" + $modName + ".jointsNum");
	setAttr ("RRM_" + $modName + ".jointsNum") $jointsNum;
	setAttr -l true ("RRM_" + $modName + ".jointsNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.direction");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.direction") $direction;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.direction");


	//CREATE ATTACH LOCATION
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[1]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[2]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[3]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_targetLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_targetLctr");
	
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[5]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[10]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[9]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[4]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_AimLctr");
	delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
	-worldUpVector 0 1 0 -worldUpObject ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr")`;
	parent ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr");
	makeIdentity -apply false -r 1 ("RRM_" + $prfx + $modName + "_targetLctr");
	$targetLoc = `getAttr ("RRM_" + $prfx + $modName + "_targetLctr.translate")`;
	setAttr ("RRM_" + $prfx + $modName + "_targetLctr.tx") ($targetLoc[0] * 3.1304347826087);
	parentConstraint -mo ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_AimLctr");
	
	//CREATE FIRST NODE
	if ($jointsNum != 1)
	{
		RRM_CreateProxyBaseUpProxy($crntUnit);
		rename RRM_BaseUp ("RRM_" + $prfx + $modName + "_01_");
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideColor") 9;
	}
	else
	{
		RRM_CreateProxyEndProxy($crntUnit);
		rename RRM_End ("RRM_" + $prfx + $modName + "_01_");
		rotate -r -os -90 0 0 ("RRM_" + $prfx + $modName + "_01_");
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideColor") 9;
	}
	group -n ("RRM_" + $prfx + $modName + "_Grp")  ("RRM_" + $prfx + $modName + "_01_"); xform -os -piv 0 0 0;
	delete `parentConstraint ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_Grp")`;
	rotate -r -os 90 0 0 ("RRM_" + $prfx + $modName + "_01_");
	makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_01_");
	parent ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_Parent");
	rotate -r -os 0 -90 -90 ("RRM_" + $prfx + $modName + "_Grp") ;
	makeIdentity -apply false -s 1  ("RRM_" + $prfx + $modName + "_Grp");
	
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.core") ($prfx + $modName + "_01_");
	
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.ext") ("_01_");

	delete ("RRM_" + $prfx + $modName + "_AimLctr");

	RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_01_"));

	if ($mirrorMod ==1)
	{
		addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_01_");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_01_.pair");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.pair") $crntSide;
		setAttr -l true ("RRM_" + $prfx + $modName + "_01_.pair");
		
		addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_01_");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_01_.opposite");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.opposite") ($oppPrfx + $modName + "_01_");
	}
    
	//CHAINS
	int $crntChNum = 2;
	while ($crntChNum <= $chainsNum)
	{
		$previousMod = ($crntChNum -1);
		string $namePadding = "";
		if ($crntChNum < 10)
		{
			$namePadding = "0";
		}
		string $namePaddingPrev = "";
		if ($crntChNum < 11)
		{
			$namePaddingPrev = "0";
		}
		duplicate -n ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_") ("RRM_" + $prfx + $modName + "_" + $namePaddingPrev + $previousMod + "_");
		move -r -ls ($multiplier * -0.75) 0 0 ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_");
		
		if ($mirrorMod ==1)
		{
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.opposite") ($oppPrfx + $modName + "_" + $namePadding + $crntChNum + "_");			
		}
    
		setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.core");			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.core") ($prfx + $modName + "_" + $namePadding + $crntChNum + "_");
    
		setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.ext");			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.ext") ("_" + $namePadding + $crntChNum + "_");
		
		//CONNECTORS
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_"));

		$crntChNum++;
	}
	
	//FIX JOINT OFFSET
	spaceLocator -n  ("RRM_" + $prfx + $modName + "chainCenterLctr");
	$chainStart = `ls ("RRM_" + $prfx + $modName + "_??_")`;
	delete `pointConstraint $chainStart ("RRM_" + $prfx + $modName + "chainCenterLctr")`;
	parent $chainStart ("RRM_" + $prfx + $modName + "chainCenterLctr");
	delete `pointConstraint ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "chainCenterLctr")`;
	parent $chainStart ("RRM_" + $prfx + $modName + "_Grp");
	delete ("RRM_" + $prfx + $modName + "chainCenterLctr");
    
	//JOINTS
	select -hi ("RRM_" + $prfx + $modName + "_Grp");
	select -d ("RRM_" + $prfx + $modName + "_Grp");
	select -d "RRM_*Shape";
	$chains = `ls -sl`;
	int $crntJntNum = 2;
    
	for ($crntJnt in $chains)
	{
		$crntJntNum = 2;
		while ($crntJntNum <= $jointsNum)
		{
			string $namePadding = "";
			string $prevPadding = "";
			$prevJntNum = ($crntJntNum - 1);
			//CHECK IF END NODE OR NOT
			if ($crntJntNum < 10)
			{
				$namePadding = "0";
			}
			if ($crntJntNum <= 10)
			{
				$prevPadding = "0";
			}
			if ($crntJntNum != $jointsNum)
			{
				if ($crntJntNum ==2)
				{
					duplicate -n ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
					move -r -ls 0 1 0 ($crntJnt + $namePadding + $crntJntNum);
					parent ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
				}
				else
				{
					duplicate -n ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
					move -r -ls 0 1 0 ($crntJnt + $namePadding + $crntJntNum);
					parent ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
				}
			}
			else
			{
				RRM_CreateProxyEndProxy($crntUnit);
				rename RRM_End ($crntJnt + $namePadding + $crntJntNum);
				if ($crntJntNum ==2)
				{
					parent ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
					delete `parentConstraint $crntJnt ($crntJnt + $namePadding + $crntJntNum)`;
				}
				else
				{
					parent ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
					delete `parentConstraint ($crntJnt + $prevPadding + $prevJntNum) ($crntJnt + $namePadding + $crntJntNum)`;
				}
				if ($mirrorMod ==1)
				{
					addAttr -ln "pair"  -dt "string" ($crntJnt + $namePadding + $crntJntNum);
					setAttr -e-keyable true ($crntJnt + $namePadding + $crntJntNum + ".pair");
					setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".pair") $crntSide;
					setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".pair");
					
					
					addAttr -ln "opposite"  -dt "string" ($crntJnt + $namePadding + $crntJntNum);
					setAttr -e-keyable true ($crntJnt + $namePadding + $crntJntNum + ".opposite");
				}
				move -r -ls  0 1 0 ($crntJnt + $namePadding + $crntJntNum);
			}
			//ATTRIBUTES
			$coreName = `getAttr ($crntJnt + ".core")`;
			setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".core");
			setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".core") ($coreName + $namePadding + $crntJntNum);
			setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".core");

			$extName = `getAttr ($crntJnt + ".ext")`;
			setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".ext");
			setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".ext") ($extName + $namePadding + $crntJntNum);
			setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".ext");

			if ($mirrorMod == 1)
			{
				$oppositeName = `getAttr ($crntJnt + ".opposite")`;
				setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".opposite");
				setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".opposite") ($oppositeName + $namePadding + $crntJntNum);
				setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".opposite");
			}
			//CONNECTORS
			if ($crntJntNum == 2)
			{
				RRM_ProxyConnectors($modName, $prfx, $crntJnt, ($crntJnt + $namePadding + $crntJntNum));
			}
			else
			{
				RRM_ProxyConnectors($modName, $prfx, ($crntJnt + $prevPadding + $prevJntNum), ($crntJnt + $namePadding + $crntJntNum));
			}
			$crntJntNum++;
		}
	}
    
	//RENAME 01 JOINTS
	$topJoints = `ls ("RRM_" + $prfx + $modName + "_??_")`;
	$previousJnt = ("RRM_" + $prfx + $modName + "_Parent_");
	$i =0;
	for ($crntJnt in $topJoints)
	{
		rename $crntJnt ($crntJnt + "01");

		$coreName = `getAttr ($crntJnt + "01.core")`;
		setAttr -type "string" ($crntJnt + "01.core") ($coreName + "01");
		setAttr -l true ($crntJnt + "01.core");

		$extName = `getAttr ($crntJnt + "01.ext")`;
		setAttr -type "string" ($crntJnt + "01.ext") ($extName + "01");
		setAttr -l true ($crntJnt + "01.ext");
		
		if ($mirrorMod == 1)
		{
			$oppositeName = `getAttr ($crntJnt + "01.opposite")`;
			setAttr -type "string" ($crntJnt + "01.opposite") ($oppositeName + "01");		
			setAttr -l true ($crntJnt + "01.opposite");
		}
	}

	//ONLY FREEZE IF IT IS NOT AN EDIT
	if ($create == 1)
	{
		//FIX UP AND DOWN
		if ($direction == 2)
		{
			rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
			makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		}
		if ($direction == 5)
		{
			rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_Parent");
			makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		}
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Grp");
	}
}

global proc RRM_CreateProxyFKChain(string $modName, int $chainsNum, int $jointsNum, int $modDirection, int $modDirection2, int $mirrorMod)
{
	//SET UNITS TO CENTIMETERS
	string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//}
	if ($modDirection == 0)
	{
		$modDirection = ($modDirection2 + 3);
	}
	
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$rotOffset = 0;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	$create = 1;

	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	//FK CHAIN
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppSide = "";
		}
		
		RRM_CreateProxyParentProxy($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "fkChain";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		addAttr -ln "chainNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "jointNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "direction"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
	
		//CHECK IF MIRRORED
		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
	
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable true ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName);
			}
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");			
		}

		if (!`objExists ("RRM_" + $modName + ".chainsNum")`)
		{
			//ADD CHAIN NUM ATTRIBUTE	
			addAttr -ln "chainsNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".chainsNum");
			setAttr ("RRM_" + $modName + ".chainsNum") $chainsNum;
			setAttr -l true ("RRM_" + $modName + ".chainsNum");
		
			//ADD JOINT NUM ATTRIBUTE	
			addAttr -ln "jointsNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".jointsNum");
			setAttr ("RRM_" + $modName + ".jointsNum") $jointsNum;
			setAttr -l true ("RRM_" + $modName + ".jointsNum");
		}

		//X
		string $selectedMod;
		float $xValue = 0;
		rotate -r -90 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		if ($crntSide == "left")
		{
			if ($modDirection == 1)
			{
				//CHECK LOCATION
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					if ($xValue < 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
					}
				}
			}
			if ($modDirection == 4)
			{
				//CHECK LOCATION
				$xValue = 0;
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					
					if ($xValue >= 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
					}
				}
			}
		}
		else if ($crntSide == "right")
		{
			if ($modDirection == 1)
			{
				//CHECK LOCATION
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					if ($xValue >= 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
					}
				}

			}
			if ($modDirection == 4)
			{
				//CHECK LOCATION
				$xValue = 0;
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					
					if ($xValue < 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
					}
				}
			}
		}
		//Y
		if ($modDirection == 2)
		{
			setAttr (("RRM_" + $prfx + $modName + "_Parent.rotate"), -90, 0, 90);
		}
		if ($modDirection == 5)
		{
			setAttr (("RRM_" + $prfx + $modName + "_Parent.rotate"), -90, 0, -90);
		}		
		//Z
		if ($modDirection == 3)
		{
			rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
		}
		if ($modDirection == 6)
		{
			rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_Parent");
		}
		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			if ($mirrorMod == 1)
			{
				move -r ($multiplier * 1) 0 0  ("RRM_" + $prfx + $modName + "_Parent");
			}
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");

		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 9;
		
			
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		RRM_CreateProxyFKChain2($modName, $chainsNum, $jointsNum, $modDirection, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit, $create);

		//PARENT CONNECTOR

		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$rotOffset = 180;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "fkChain";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE	
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD DIRECTION ATTRIBUTE	
	addAttr -ln "direction" -at long ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".direction");
	setAttr ("RRM_" + $modName + ".direction") $modDirection;
	setAttr -l true ("RRM_" + $modName + ".direction");

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);
	

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{
			select ("RRM_l_" + $modName + "_Parent") ("RRM_r_" + $modName + "_Parent");
		}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}


}

global proc RRM_FKChainPrompts(string $modName, int $chainsNum, int $jointsNum, int $mirrorMod, int $modDirection, int $modDirection2)
{
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldFKChainName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this name. Please use a unique name\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			$attachModNum = `size $attachMod`;
			if ($attachModNum == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ($attachModNum > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$chainSize = ($chainsNum * $jointsNum * $mirrorMod);
						if ($chainSize <= 100)
						{
							RRM_CreateProxyFKChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
						}
						else
						{
							string $returnVal_Generate2 = `confirmDialog
							-title "Large Number of proxies in module"
							-message "The FK Chain you are about to create has over 100 proxies. This could take several minutes to generate. Proceed?\n"
							-button "OK" -button "Cancel"
							-defaultButton "OK"
							-cancelButton "Cancel"
							-icon "warning"`;
							
							if ($returnVal_Generate2 == "OK")
							{
								RRM_CreateProxyFKChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
							}
						}
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					$chainSize = ($chainsNum * $jointsNum * $mirrorMod);
					if ($chainSize <= 100)
					{
						RRM_CreateProxyFKChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
					}
					else
					{
						string $returnVal_Generate2 = `confirmDialog
						-title "Large Number of proxies in module"
						-message "The FK Chain you are about to create has over 100 proxies. This could take several minutes to generate. Proceed?\n"
						-button "OK" -button "Cancel"
						-defaultButton "OK"
						-cancelButton "Cancel"
						-icon "warning"`;
						
						if ($returnVal_Generate2 == "OK")
						{
							RRM_CreateProxyFKChain($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
						}
					}
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////HEAD///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyHead(string $modName, int $RRM_Jaw, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 1;
	$crntSide = "left";
	$oppSide = "right";
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$posOffset = 0;
		}
		
		if (`objExists ($attachMod[0] + (".opposite"))`)
		{
			$posOffset = 0;
		}
		
		RRM_CreateProxyParentProxy($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "head";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		addAttr -ln "jaw"  -at bool -dv $RRM_Jaw ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
		
		

		RRM_CreateProxyEndProxy($crntUnit);
		rename RRM_End ("RRM_" + $prfx  + $modName + "_Top");
		move -r 0 3 0 ("RRM_" + $prfx + $modName + "_Top");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.core") ($prfx + $modName + "_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.ext") ("_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.ext");
		
		RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx  + $modName + "_Top"));
		
		if ($RRM_Jaw == 1)
		{
			RRM_CreateProxyModuleProxy($crntUnit);
			rename RRM_Base	 ("RRM_" + $prfx + $modName + "_Jaw");
			move -r 0 1.5 0.25 ("RRM_" + $prfx + $modName + "_Jaw");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.core") ($prfx + $modName + "_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.core");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.ext") ("_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.ext");
		
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Jaw"));
			
			RRM_CreateProxyEndProxy($crntUnit);
			rename RRM_End ("RRM_" + $prfx + $modName + "_JawEnd");
			move -r 0 1 1.5 ("RRM_" + $prfx + $modName + "_JawEnd");
			rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_JawEnd");
			parent ("RRM_" + $prfx + $modName + "_JawEnd") ("RRM_" + $prfx + $modName + "_Jaw");
			parent ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_Parent");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.core") ($prfx + $modName + "_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.core");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.ext") ("_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.ext");

			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Jaw"), ("RRM_" + $prfx + $modName + "_JawEnd"));
		}
		
		parent ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
			
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable true ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			//MIRROR ATTRIBUTES
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");
				
			if ($RRM_Jaw == 1)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Jaw");
				setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Jaw.pair");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.pair") $crntSide;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.pair");
				
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Jaw");
				setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Jaw.opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.opposite") ($oppPrfx + $modName + "_Jaw");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.opposite");
        	
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_JawEnd");
				setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_JawEnd.pair");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.pair") $crntSide;
				setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.pair");
				
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_JawEnd");
				setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_JawEnd.opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.opposite") ($oppPrfx + $modName + "_JawEnd");
				setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.opposite");
			}
				
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Top.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Top.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.opposite") ($oppPrfx + $modName + "_Top");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.opposite");
		}
		//OFFSET FROM CENTER IF NOT ATTACHED TO PAIR		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			move -r $posOffset 0 0 ("RRM_" + $prfx + $modName + "_Parent");
		}
				
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		//ASSIGN COLOURS
		select ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");
		if ($RRM_Jaw == 1)
		{
			select -add ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_JawEnd");
		}
		$headProxies = `ls -sl`;
		string $crntHead;
		for ($crntHead in $headProxies)
		{
			setAttr ($crntHead + ".overrideEnabled") 1;
			setAttr ($crntHead + ".overrideColor") 4;
		}
		select ("RRM_" + $prfx + $modName + "_Parent");
		
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -1;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "head";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD JAW ATTRIBUTE
	addAttr -ln "jaw" -at long ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".jaw");
	setAttr ("RRM_" + $modName + ".jaw") $RRM_Jaw;
	setAttr -l true ("RRM_" + $modName + ".jaw");	

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_HeadPrompts(string $modName, int $RRM_Jaw, int $mirrorMod)
{
	string $modName = `textField -q -text RRM_TextFieldHeadName`;
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique modName.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldHeadName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			$attachModNum = `size $attachMod`;
			if ($attachModNum == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ($attachModNum > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyHead($modName, $RRM_Jaw, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyHead($modName, $RRM_Jaw, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////LOOK AT///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyLookAt2(string $modName, int $jointsNum, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, string $crntUnit)
{
	//SET EYE NUM IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.eyeNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.eyeNum") $jointsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.eyeNum");

	lockNode -lock off ("RRM_" + $modName);

	setAttr -l false ("RRM_" + $modName + ".eyeNum");
	setAttr ("RRM_" + $modName + ".eyeNum") $jointsNum;
	setAttr -l true ("RRM_" + $modName + ".eyeNum");
	

	//CREATE ATTACH LOCATION
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[1]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[2]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[3]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_targetLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_targetLctr");
	
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[5]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[10]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[9]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[4]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_AimLctr");
	delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
	-worldUpVector 0 1 0 -worldUpObject ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr")`;
	parent ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr");
	makeIdentity -apply false -r 1 ("RRM_" + $prfx + $modName + "_targetLctr");
	$targetLoc = `getAttr ("RRM_" + $prfx + $modName + "_targetLctr.translate")`;
	setAttr ("RRM_" + $prfx + $modName + "_targetLctr.tx") ($targetLoc[0] * 1.65);
	parentConstraint -mo ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_AimLctr");
	
	//CREATE FIRST NODE
	RRM_CreateProxyBaseUpProxy($crntUnit);
	rename RRM_BaseUp ("RRM_" + $prfx + $modName + "_01");
	scale -r  3 3.2 3 ("RRM_" + $prfx + $modName + "_01DShape.cv[1]") ("RRM_" + $prfx + $modName + "_01EShape.cv[0:2]")
	("RRM_" + $prfx + $modName + "_01FShape.cv[0:2]") ("RRM_" + $prfx + $modName + "_01GShape.cv[0:7]");
	
	move -r -os -wd 0 8 0 ("RRM_" + $prfx + $modName + "_01DShape.cv[1]") ("RRM_" + $prfx + $modName + "_01EShape.cv[0:2]")
	("RRM_" + $prfx + $modName + "_01FShape.cv[0:2]") ("RRM_" + $prfx + $modName + "_01GShape.cv[0:7]");
	move -r 0 1 0 ("RRM_" + $prfx + $modName + "_01");
	rotate -r -os 0 0 -90 ("RRM_" + $prfx + $modName + "_01");
	makeIdentity -apply true -t 1-r 1 ("RRM_" + $prfx + $modName + "_01");
    
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.core") ($prfx + $modName + "_01");
	setAttr -l true ("RRM_" + $prfx + $modName + "_01.core");
    
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.ext") ("_01");
	setAttr -l true ("RRM_" + $prfx + $modName + "_01.ext");
	
	RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_01"));

	if ($mirrorMod ==1)
	{
		//MIRROR ATTRIBUTES
		addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_01");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_01.pair");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.pair") $crntSide;
		setAttr -l true ("RRM_" + $prfx + $modName + "_01.pair");
		
		addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_01");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_01.opposite");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.opposite") ($oppPrfx + $modName + "_01");
		setAttr -l true ("RRM_" + $prfx + $modName + "_01.opposite");
	}
	group -n ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_01"); xform -os -piv 0 0 0;
	
	if ($jointsNum > 1)
	{
		//JOINTS
		int $crntjointNum = 2;
		while ($crntjointNum <= $jointsNum)
		{
			$previousMod = ($crntjointNum -1);
			string $namePadding = "";
			if ($crntjointNum < 10)
			{
				$namePadding = "0";
			}
			string $namePaddingPrev = "";
			if ($crntjointNum < 11)
			{
				$namePaddingPrev = "0";
			}
			duplicate -n ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum) ("RRM_" + $prfx + $modName + "_" + $namePaddingPrev + $previousMod);
			move -r -ls 0 0 -0.75 ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum);
			
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core") ($prfx + $modName + "_" + $namePadding + $crntjointNum);
			setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core");
			
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext") ("_" + $namePadding + $crntjointNum);
			setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext");
		
			if ($mirrorMod ==1)
			{
				setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite") ($oppPrfx + $modName + "_" + $namePadding + $crntjointNum);			
				setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite");
			}
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum));

			$crntjointNum++;
		}
	}
	//FIX JOINT OFFSET
	spaceLocator -n ("RRM_" + $prfx + $modName + "_CenterLctr");
	$lookAts = `ls ("RRM_" + $prfx + $modName + "_??")`;
	delete `pointConstraint $lookAts ("RRM_" + $prfx + $modName + "_CenterLctr")`;
	parent $lookAts ("RRM_" + $prfx + $modName + "_CenterLctr");
	delete `pointConstraint ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_CenterLctr")`;
	parent $lookAts ("RRM_" + $prfx + $modName + "_Grp");
	delete `parentConstraint ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_Grp")`;
	parent ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_Parent");
	makeIdentity -apply true -t 1 -r 1 ("RRM_" + $prfx + $modName + "_Grp");
	setAttr (("RRM_" + $prfx + $modName + "_Grp.scale"), 1, 1, 1);

	delete ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_CenterLctr");
}


global proc RRM_CreateProxyLookAt(string $modName, int $jointsNum, int $modDirection, int $modDirection2, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	if ($modDirection == 0)
	{
		$modDirection = ($modDirection2 + 3);
	}

	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		
		RRM_CreateProxyParentProxy($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "lookAt";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		addAttr -ln "eyeNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable true ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");

			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			
			//MIRROR ATTRIBUTES
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");		
		}
			
		if (!`objExists ("RRM_" + $modName + ".eyeNum")`)
		{
			//ADD EYE NUM ATTRIBUTE
			addAttr -ln "eyeNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable true ("RRM_" + $modName + ".eyeNum");
			setAttr ("RRM_" + $modName + ".eyeNum") $jointsNum;
			setAttr -l true ("RRM_" + $modName + ".eyeNum");
		}

		//X
		string $selectedMod;
		float $xValue = 0;
		rotate -r ($multiplier * -90) -90 0 ("RRM_" + $prfx + $modName);
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName);
		if ($modDirection == 1)
		{
			//CHECK LOCATION
			for ($selectedMod in $attachMod)
			{
			    $modTX = `xform -q -ws -rp $selectedMod`;
			    $xValue = ($xValue + $modTX[0]);
			}
			if ($xValue < 0)
			{
				rotate -r 0 ($multiplier * 180) 0 ("RRM_" + $prfx + $modName);
			}
		}
		if ($modDirection == 4)
		{
			//CHECK LOCATION
			$xValue = 0;
			for ($selectedMod in $attachMod)
			{
			    $modTX = `xform -q -ws -rp $selectedMod`;
			    $xValue = ($xValue + $modTX[0]);
			}
			if ($xValue >= 0)
			{
				rotate -r 0 ($multiplier * 180) 0 ("RRM_" + $prfx + $modName);
			}
		}
		//Y
		if ($modDirection == 2)
		{
			rotate -r -90 0 ($multiplier * 90) ("RRM_" + $prfx + $modName);
		}
		if ($modDirection == 5)
		{
			rotate -r 90 0 ($multiplier * -90) ("RRM_" + $prfx + $modName);
		}		
		//Z
		if ($modDirection == 3)
		{
			rotate -r 0 ($multiplier * -90) 0 ("RRM_" + $prfx + $modName);
		}
		if ($modDirection == 6)
		{
			rotate -r 0 ($multiplier * 90) 0 ("RRM_" + $prfx + $modName);
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName);
		
		//OFFSET FROM CENTER IF NOT ATTACHED TO PAIR		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			if ($mirrorMod == 1)
			{
				move -r ($multiplier * 1) 0 0  ("RRM_" + $prfx + $modName + "_Parent");
			}
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
				
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 30;
		
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
		
		RRM_CreateProxyLookAt2($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

	
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "lookAt";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");

	//ADD DIRECTION ATTRIBUTE	
	addAttr -ln "direction" -at long ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".direction");
	setAttr ("RRM_" + $modName + ".direction") $modDirection;
	setAttr -l true ("RRM_" + $modName + ".direction");	

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_LookAtPrompts(string $modName, int $jointsNum, int $mirrorMod, int $modDirection, int $modDirection2)
{
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique modName.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text textFieldLookAtModName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			$attachModNum = `size $attachMod`;
			if ($attachModNum == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ($attachModNum > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyLookAt($modName, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyLookAt($modName, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////Auxiliary///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyAuxiliary(string $modName, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		
		//GET OPPOSITE ATTACHMENT
		//if ($i == 1)
		//{
		//	if (`objExists ($attachMod[0] + ".opposite")`)
		//	{
		//		$oppAttach = `getAttr ($attachMod[0] + ".opposite")`;
		//		$attachMod[0] = ("RRM_" + $oppAttach);
		//		$attachModCore = `getAttr ($attachMod[0] + ".core")`;
		//	}
		//}
		
		RRM_CreateProxyModuleProxy($crntUnit);
		scale -r 1.5 1.5 1.5 RRM_Base;
		makeIdentity -apply true -s 1 RRM_Base;
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Aux");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Aux"); xform -os -piv 0 0 0;
		
		addAttr -ln "modType" -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.modType") "auxiliary";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.modType");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.core") ($prfx + $modName + "_Aux");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.core");

		addAttr -ln "attachNode"  -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
		
		//CREATE COLOURED AXES CURVES
		curve  -n ("RRM_" + $prfx + $modName + "_Aux_X") -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Aux_XShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_XShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_XShape.overrideColor") 13;
		
		curve -n ("RRM_" + $prfx + $modName + "_Aux_Y") -d 1 -p 0 0 0 -p 0 1 0 -k 0 -k 1 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Aux_YShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_YShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_YShape.overrideColor") 14;
		
		curve -n ("RRM_" + $prfx + $modName + "_Aux_Z") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Aux_ZShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_ZShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_ZShape.overrideColor") 6;
		
		parent -r -s ("RRM_" + $prfx + $modName + "_Aux_XShape") ("RRM_" + $prfx + $modName + "_Aux_YShape") ("RRM_" + $prfx + $modName + "_Aux_ZShape")("RRM_" + $prfx + $modName + "_Aux");
		delete ("RRM_" + $prfx + $modName + "_Aux_X") ("RRM_" + $prfx + $modName + "_Aux_Y") ("RRM_" + $prfx + $modName + "_Aux_Z");


		//ADD PINNED ATTRIBUTE
		addAttr -ln "pinned"  -at bool ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Aux.pinned");
		setAttr ("RRM_" + $prfx + $modName + "_Aux.pinned") 0;
		setAttr -lock true ("RRM_" + $prfx + $modName + "_Aux.pinned");
		
		//ADD CONNECTOR VIZ ATTRIBUTE
		addAttr -ln "connectors"  -at bool ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Aux.connectors");
		setAttr ("RRM_" + $prfx + $modName + "_Aux.connectors") 1;

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable true ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");

			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			
			//MIRROR ATTRIBUTES
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Aux.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
			setAttr -e-keyable true ("RRM_" + $prfx + $modName + "_Aux.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.opposite") ($oppPrfx + $modName + "_Aux");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.opposite");		
		}
		
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
		
		
		//makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
				
		setAttr ("RRM_" + $prfx + $modName + "_Aux.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux.overrideColor") 24;
		
		//RRM_CreateProxyLookAt2($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

	
		//PARENT CONNECTOR
		RRM_ProxyConnectors($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Aux"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "auxiliary";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable true ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes($modNodes);

	select -cl;
	
	if (`objExists ("RRM_l_" + $modName + "_Aux")`)
	{
		move -r 1 0 0 ("RRM_l_" + $modName + "_Aux");
		move -r -1 0 0 ("RRM_r_" + $modName + "_Aux");
		select ("RRM_l_" + $modName + "_Aux") ("RRM_r_" + $modName + "_Aux");
	}
	else if (`objExists ("RRM_" + $modName + "_Aux")`)
		{select ("RRM_" + $modName + "_Aux");}
}

global proc RRM_AuxiliaryPrompts(string $modName, int $mirrorMod)
{
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique modName.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text textFieldAuxiliaryModName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			$attachModNum = `size $attachMod`;
			if ($attachModNum == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ($attachModNum > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyAuxiliary($modName, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyAuxiliary($modName, $mirrorMod);
				}
			}
		}
	}
}



//OVERRIDE COLOUR
global proc RRM_ProxyOverrideColor(int $colorVal)
{
	$selection = `ls -sl -type "transform"`;
	for ($each in $selection)
	{
		//MAKE SURE EACH IN SELECTION IS A VALID PROXY
		if (`objExists ($each + ".modName")`)
		{
			$modName = `getAttr ($each + ".modName")`;
			$modNodes = `ls -type "transform" ("RRM_*" + $modName + "*")`;
			//MAKE SURE NODE IS PART OF THE SELECTED MODULE
			for ($each2 in $modNodes)
			{
				//VALIDATE EACH IS PART OF THE MODULE OF THE INITIAL SELECTED BRANCH
				if (`objExists ($each2 + ".modName")`)
				{
					$checkModName = `getAttr ($each2 + ".modName")`;
					if ($checkModName == $modName)
					{
						//CHECK IF IT IS RESET
						if ($colorVal == 0)
						{
							string $modType =`getAttr ("RRM_" + $checkModName + ".top")`;
							//print ($modType + "\n");
							if ($modType == "spline")
							{
								setAttr ($each2 + ".overrideColor") 29;
							}
							else if ($modType == "arm")
							{
								setAttr ($each2 + ".overrideColor") 7;
							}
							else if ($modType == "leg")
							{
								setAttr ($each2 + ".overrideColor") 31;
							}
							else if ($modType == "fkChain")
							{
								setAttr ($each2 + ".overrideColor") 9;
							}
							else if ($modType == "head")
							{
								setAttr ($each2 + ".overrideColor") 4;
							}
							else if ($modType == "lookAt")
							{
								setAttr ($each2 + ".overrideColor") 30;
							}
						}
						else
						{
							setAttr ($each2 + ".overrideColor") $colorVal;
						}
					}
				}
			}
		}
	}
	select $selection;
}
////////////////////////////////////////////////////////////////////////////////
//////////////////////////////RENAME MODULE/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//RENAME MODULE	
global proc RRM_Rename(string $name, string $selection, int $call)
{
	//string $crntUnit = `currentUnit -query -linear`;
	
	string $modName;
	string $modType;
	string $attachNode;
	string $side;
	string $ext;
	
	string $eachModName;
	
	if ($call == 0)
	{
		$modName = `getAttr ($selection + ".modName")`;
		$modType = `getAttr ("RRM_" + $modName + ".top")`;
		$attachNode = `getAttr ("RRM_" + $modName + ".parent")`;
	}
	else
	{
		$modName = `getAttr ("RRM_" + $selection + ".core")`;
		$modType = `getAttr ("RRM_" + $selection + ".top")`;
		//ORIGINAL MODULE'S ATTACH NODE
		$sourceAttachNode = `getAttr ("RRM_" + $modName + ".parent")`;

		//GET ATTACH NODE'S CLONED ATTRIBUTE
		string $cloneName = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		if (`gmatch $cloneName ""`)
		{//ATTACH NODE IS NOT A CLONE
			$attachNode = ($sourceAttachNode);
		}
		else
		{//ATTACH NODE IS A CLONE
			$attachNode = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		}
	}
	string $clonedParentNodes[];	

	int $mirrorMod = 1;
	string $prfx = "l_";
	string $prfxReset = "l_";
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 0;
		$prfx = "";
		$prfxReset = "";
	}
	int $firstTimeThrough;

	//CHECK IF SPLINE
	if (`gmatch $modType "spline"`)
	{
		RRM_Clone_Spline($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "arm"`)
	{//CHECK IF ARM
		RRM_Clone_Arm($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "leg"`)
	{//CHECK IF LEG
		RRM_Clone_Leg($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "fkChain"`)
	{//CHECK IF FKCHAIN
		RRM_Clone_FkChain($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "head"`)
	{//CHECK IF HEAD
		RRM_Clone_Head($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "lookAt"`)
	{//CHECK IF LOOKAT
		RRM_Clone_LookAt($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "auxiliary"`)
	{//CHECK IF AUXILIARY
		RRM_Clone_Auxiliary($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
		
	if ($call <= 1)
	{
		//CHECK TO SEE IF IT IS NOT AN AUXILIARY
		if (!`objExists ("RRM_" + $name + "_Aux")` && !`objExists ("RRM_l_" + $name + "_Aux")`)
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_Lctr";
			setAttr -e-keyable true "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Parent");
			if (!`objExists ("RRM_" + $name + "_Parent")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_l_" + $name + "_Parent");
			}
		}
		else
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_Lctr";
			setAttr -e-keyable true "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Aux");
			if (!`objExists ("RRM_" + $name + "_Aux")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_l_" + $name + "_Aux");
			}
		}			
	}
	
	//FIND CHILDREN MODULES AND ATTACH TO RENAMED DUPLICATE
	$hierarchy = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	string $prfx = "";
	int $childModCount = 0;
	for ($each in $hierarchy)
	{
		print ("each is " + $each + " 1\n");

		if (`objExists ($each + ".parent")` && !`objExists ($each + ".top")`)
		{//VERIFY IT IS A PARENT
			print ("\n\neach is " + $each + " 2\n\n\n");
			$attachNode = `getAttr ($each + ".attachNode")`;
			if (`objExists ("RRM_" + $attachNode + ".pair")`)
			{
				print "is a pair\n";
				$prfx = `getAttr ("RRM_" + $attachNode + ".pair")`;
				if (`gmatch $prfx "left"`)
					{$prfx = "l_";}
				else if (`gmatch $prfx "right"`)
					{$prfx = "r_";}
			}
			print ("attach node is " + $attachNode + " and modName is " + $modName + "\n");
			if (`gmatch ($attachNode + "*") ($prfx + $modName + "*")`)
			{//MAKE SURE IT IS A PARENT NODE ATTACHED TO THE RENAMED MODULE
				$eachModName = `getAttr ($each + ".modName")`;
				print "parent node attached to the renamed module\n";
				if (!`gmatch $modName $eachModName`)
				{//MAKE SURE IT IS NOT A PARENT NODE OF THE RENAMED MODULE
					string $attachNode_Ext = `getAttr ("RRM_" + $attachNode + ".ext")`;
					if (`objExists ("RRM_" + $prfx + $name + $attachNode_Ext)`)
					{//ONLY ATTACH IF IT IS A DIRECT CHILD MODULE OF THE RENAMED MODULE
						print ($each + " is a direct child module or renamed module\n");
						select ("RRM_" + $prfx + $name + $attachNode_Ext);
						select $each;
						RRM_AttachToNewModule(("RRM_" + $prfx + $name + $attachNode_Ext));
					}
					$childModCount++;
				}
			}
		}
	}
	//DELETE ORIGINAL MODULE
	RRM_DeleteBranchPrompts();
}

global proc RRM_RenamePrompts(string $name)
{
	string $selection[] = `ls -sl`;
	$selectionSize = `size $selection`;
	string $coreCheck;
	if (`objExists ($selection[0] + ".core")`)
	{
		$coreCheck = `getAttr ($selection[0] + ".core")`;
	}
	
	$nameCheck = `size $name`;
	if ($selectionSize == 0)
	{//CHECK THAT SOMETHING IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Nothing Selected"
			-message "You must select a node of the desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if ($selectionSize > 1)
	{//CHECK THAT ONLY ONE OBJECT IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Only One Module May Be Cloned At A Time"
			-message "You must select only one node of a desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (!`objExists ($selection[0] + ".core")`)
	{//CHECK TO MAKE SURE OBJECT IS A VALID MODULE
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message "You must select one node of a desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	
	else if (`gmatch $coreCheck "MAIN"` || `gmatch $coreCheck "ROOT"`)
	{//CHECK TO MAKE SURE OBJECT IS NOT MAIN OR ROOT
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message "You cannot rename the MAIN or ROOT modules.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}

	else if ($nameCheck == "0")
	{//CHECK TO MAKE SURE THE USER HAS INPUT A NAME
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($name))
	{//CHECK TO MAKE SURE A VALID NAME HAS BEEN USED
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ("RRM_" + $name)`)
	{//CHECK TO MAKE SURE NAME DOES NOT CONFLICT WITH EXISTING OBJECT
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		print "renaming...\n";
		string $parentNullName = "";
		RRM_Rename($name, $selection[0], 0);
	}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////CLONE MODULE/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//CLONE SPLINE
global proc RRM_Clone_Spline(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $splineNum = `getAttr ("RRM_" + $modName + ".jointsNum")`;
	int $i = 0;

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Top_Lctr");
		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top.rotate")`;
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.scale"), $topScale[0], $topScale[1], $topScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.clone") ($prfx + $name + "_Top");

		//WHILE LOOP
		int $i2 = 1;
		while ($i2 <= $splineNum)
		{
			string $nPd = "_0";
			if ($i2 >= 10)
			{
				string $nPd = "_";
			}
			//TRANSFORMS LOCATOR
			spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr");
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".rotate")`;
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".scale")`;
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i2 + ".clone") ($prfx + $name + $nPd + $i2);
			
			$i2++;
		}
		$prfx = "r_";
		$i++;
	}

	//GENERATE NEW SPLINE
	select ("RRM_" + $attachNode);
	RRM_CreateProxySpline($name, $splineNum, $mirrorMod);
	
	$clonedParentNodes = `ls -sl`;
	
	
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
	
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS
	
		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		
	
		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");
	
		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.rotate")`;		
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.scale")`;		
	
		setAttr (("RRM_" + $prfx + $name + "_Top.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.scale"), $topScale[0], $topScale[1], $topScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Top_Lctr");
	
		$i3 = 1;
		while ($i3 <= $splineNum)
		{
			string $nPd = "_0";
			if ($i3 >= 10)
			{
				string $nPd = "_";
			}
			//MOVE PROXY TO LOCATOR
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.rotate")`;		
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			delete ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr");
			$i3++;
		}
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

global proc RRM_Clone_Arm(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	print "cloning arm...\n";
	//GET NUMBER OF JOINTS
	int $upperArmNum = `getAttr ("RRM_" + $modName + ".upperArmNum")`;
	int $lowerArmNum = `getAttr ("RRM_" + $modName + ".lowerArmNum")`;
	int $elbowNum    = `getAttr ("RRM_" + $modName + ".elbowNum")`;
	int $elbowJoints = `getAttr ("RRM_" + $modName + ".elbowJoints")`;
	$mirrorMod       = 2;
	$prfx            = "l_";
	$prfxReset       = "l_";
	
	if (`objExists ("RRM_" + $modName + ".single")`)
	{
		$prfx = "";
		$prfxReset = "";
		$checkSide = `getAttr ("RRM_" + $modName + ".single")`;
		if ($checkSide == "left")
		{
			$mirrorMod = 1;
		}
		else if ($checkSide == "right")
		{
			$mirrorMod = 3;
		}
	}
	int $i = 1;

	string $clonedParentNodes[];	
	
	while ($prfx != "end")
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Clavicle_Lctr");
		$clavPos   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.translate")`;
		$clavRot   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.rotate")`;
		$clavScale = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.translate"), $clavPos[0], $clavPos[1], $clavPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.rotate"), $clavRot[0], $clavRot[1], $clavRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.scale"), $clavScale[0], $clavScale[1], $clavScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.clone") ($prfx + $name + "_Clavicle");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Shoulder_Lctr");
		$shldrPos   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.translate")`;
		$shldrRot   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.rotate")`;
		$shldrScale = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.translate"), $shldrPos[0], $shldrPos[1], $shldrPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.rotate"), $shldrRot[0], $shldrRot[1], $shldrRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.scale"), $shldrScale[0], $shldrScale[1], $shldrScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.clone") ($prfx + $name + "_Shoulder");
		
		if ($elbowJoints == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow_Lctr");
			$elbowPos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.translate")`;
			$elbowRot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.rotate")`;
			$elbowScale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.translate"), $elbowPos[0], $elbowPos[1], $elbowPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.rotate"), $elbowRot[0], $elbowRot[1], $elbowRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.scale"), $elbowScale[0], $elbowScale[1], $elbowScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.clone") ($prfx + $name + "_Elbow");
		}
		else
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow1_Lctr");
			$elbow1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.translate")`;
			$elbow1Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.rotate")`;
			$elbow1Scale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.translate"), $elbow1Pos[0], $elbow1Pos[1], $elbow1Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.rotate"), $elbow1Rot[0], $elbow1Rot[1], $elbow1Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.scale"), $elbow1Scale[0], $elbow1Scale[1], $elbow1Scale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.clone") ($prfx + $name + "_Elbow1");
		
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow2_Lctr");
			$elbow2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.translate")`;
			$elbow2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.rotate")`;
			$elbow2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.translate"), $elbow2Pos[0], $elbow2Pos[1], $elbow2Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.rotate"), $elbow2Rot[0], $elbow2Rot[1], $elbow2Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.scale"), $elbow2Scale[0], $elbow2Scale[1], $elbow2Scale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.clone") ($prfx + $name + "_Elbow2");
		}
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Wrist_Lctr");
		$wristPos   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.translate")`;
		$wristRot   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.rotate")`;
		$wristScale = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.translate"), $wristPos[0], $wristPos[1], $wristPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.rotate"), $wristRot[0], $wristRot[1], $wristRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.scale"), $wristScale[0], $wristScale[1], $wristScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.clone") ($prfx + $name + "_Wrist");			

		if ($prfx == "l_")
		{//SWITCH TO RIGHT
			$prfx = "r_";
		}
		else if ($prfx == "r_"|| $prfx == "")
		{//SWITCH TO END
			$prfx = "end";
		}
	}
	
	//GENERATE NEW ARM(S)
	select ("RRM_" + $attachNode);
	//RRM_CreateProxySpline($name, $splineNum, $mirrorMod);
	RRM_CreateProxyArm($name, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $mirrorMod);

	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$prfx = $prfxReset;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$clavPos   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.translate")`;
		$clavRot   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.rotate")`;		
		$clavScale = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Clavicle.translate"), $clavPos[0], $clavPos[1], $clavPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Clavicle.rotate"), $clavRot[0], $clavRot[1], $clavRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Clavicle.scale"), $clavScale[0], $clavScale[1], $clavScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Clavicle_Lctr");

		$shldrPos   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.translate")`;
		$shldrRot   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.rotate")`;		
		$shldrScale = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Shoulder.translate"), $shldrPos[0], $shldrPos[1], $shldrPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Shoulder.rotate"), $shldrRot[0], $shldrRot[1], $shldrRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Shoulder.scale"), $shldrScale[0], $shldrScale[1], $shldrScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Shoulder_Lctr");

			
		if ($elbowJoints == 1)
		{
			$elbowPos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.translate")`;
			$elbowRot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.rotate")`;		
			$elbowScale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.scale")`;		

			setAttr (("RRM_" + $prfx + $name + "_Elbow.translate"), $elbowPos[0], $elbowPos[1], $elbowPos[2]);
			delete ("RRM_" + $prfx + $modName + "_Elbow_Lctr");
		}
		else
		{
			$elbow1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1_Lctr.translate")`;

			setAttr (("RRM_" + $prfx + $name + "_Elbow1.translate"), $elbow1Pos[0], $elbow1Pos[1], $elbow1Pos[2]);
			delete ("RRM_" + $prfx + $modName + "_Elbow1_Lctr");

			$elbow2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2_Lctr.translate")`;
			$elbow2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Elbow2.translate"), $elbow2Pos[0], $elbow2Pos[1], $elbow2Pos[2]);
			setAttr ("RRM_" + $prfx + $name + "_Elbow2.rotateX") $elbow2Rot[0];
			delete ("RRM_" + $prfx + $modName + "_Elbow2_Lctr");
		}

		$wristPos   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.translate")`;
		$wristRot   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.rotate")`;		
		$wristScale = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Wrist.translate"), $wristPos[0], $wristPos[1], $wristPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Wrist.rotate"), $wristRot[0], $wristRot[1], $wristRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Wrist.scale"), $wristScale[0], $wristScale[1], $wristScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Wrist_Lctr");

		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
	print"clonedParentNodes are ";
	print $clonedParentNodes;
}

global proc RRM_Clone_Leg(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $upperLegNum = `getAttr ("RRM_" + $modName + ".upperLegNum")`;
	int $lowerLegNum = `getAttr ("RRM_" + $modName + ".lowerLegNum")`;
	int $kneeNum    = `getAttr ("RRM_" + $modName + ".kneeNum")`;
	int $kneeJoints = `getAttr ("RRM_" + $modName + ".kneeJoints")`;
	$mirrorMod       = 2;
	$prfx            = "l_";
	$prfxReset       = "l_";
	
	if (`objExists ("RRM_" + $modName + ".single")`)
	{
		$prfx = "";
		$prfxReset = "";
		$checkSide = `getAttr ("RRM_" + $modName + ".single")`;
		if ($checkSide == "left")
		{
			$mirrorMod = 1;
		}
		else if ($checkSide == "right")
		{
			$mirrorMod = 3;
		}
	}
	int $i = 1;

	string $clonedParentNodes[];	
	
	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Hip_Lctr");
		$hipPos   = `getAttr ("RRM_" + $prfx + $modName + "_Hip.translate")`;
		$hipRot   = `getAttr ("RRM_" + $prfx + $modName + "_Hip.rotate")`;
		$hipScale = `getAttr ("RRM_" + $prfx + $modName + "_Hip.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.translate"), $hipPos[0], $hipPos[1], $hipPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.rotate"), $hipRot[0], $hipRot[1], $hipRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.scale"), $hipScale[0], $hipScale[1], $hipScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.clone") ($prfx + $name + "_Hip");
			
		if ($kneeJoints == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee_Lctr");
			$kneePos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee.translate")`;
			$kneeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee.rotate")`;
			$kneeScale = `getAttr ("RRM_" + $prfx + $modName + "_Knee.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.translate"), $kneePos[0], $kneePos[1], $kneePos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.rotate"), $kneeRot[0], $kneeRot[1], $kneeRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.scale"), $kneeScale[0], $kneeScale[1], $kneeScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.clone") ($prfx + $name + "_Knee");
		}
		else
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee1_Lctr");
			$knee1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.translate")`;
			$knee1Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.rotate")`;
			$knee1Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.translate"), $knee1Pos[0], $knee1Pos[1], $knee1Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.rotate"), $knee1Rot[0], $knee1Rot[1], $knee1Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.scale"), $knee1Scale[0], $knee1Scale[1], $knee1Scale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.clone") ($prfx + $name + "_Knee1");
			
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee2_Lctr");
			$knee2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.translate")`;
			$knee2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.rotate")`;
			$knee2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.translate"), $knee2Pos[0], $knee2Pos[1], $knee2Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.rotate"), $knee2Rot[0], $knee2Rot[1], $knee2Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.scale"), $knee2Scale[0], $knee2Scale[1], $knee2Scale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.clone") ($prfx + $name + "_Knee2");
		}
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ankle_Lctr");
		$anklePos   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.translate")`;
		$ankleRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.rotate")`;
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.clone") ($prfx + $name + "_Ankle");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ball_Lctr");
		$ballPos   = `getAttr ("RRM_" + $prfx + $modName + "_Ball.translate")`;
		$ballRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ball.rotate")`;
		$ballScale = `getAttr ("RRM_" + $prfx + $modName + "_Ball.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.translate"), $ballPos[0], $ballPos[1], $ballPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.rotate"), $ballRot[0], $ballRot[1], $ballRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.scale"), $ballScale[0], $ballScale[1], $ballScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.clone") ($prfx + $name + "_Ball");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Toe_Lctr");
		$toePos   = `getAttr ("RRM_" + $prfx + $modName + "_Toe.translate")`;
		$toeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Toe.rotate")`;
		$toeScale = `getAttr ("RRM_" + $prfx + $modName + "_Toe.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.translate"), $toePos[0], $toePos[1], $toePos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.rotate"), $toeRot[0], $toeRot[1], $toeRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.scale"), $toeScale[0], $toeScale[1], $toeScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.clone") ($prfx + $name + "_Toe");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr");
		$heelPivPos   = `getAttr ("RRM_" + $prfx + $modName + "_HeelPivot.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.tx") $heelPivPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.tz") $heelPivPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.clone") ($prfx + $name + "_HeelPivot");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr");
		$lTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr.tx") $lTiltPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr.tz") $lTiltPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.clone") ($prfx + $name + "_FootLeftTilt");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr");
		$rTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootRightTilt.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr.tx") $rTiltPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr.tz") $rTiltPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.clone") ($prfx + $name + "_FootRightTilt");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ground_Lctr");
		$grndPos   = `getAttr ("RRM_" + $prfx + $modName + "_Ground.translate")`;
		$grndRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ground.rotate")`;
		$grndScale = `getAttr ("RRM_" + $prfx + $modName + "_Ground.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.translate"), $grndPos[0], $grndPos[1], $grndPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.rotate"), $grndRot[0], $grndRot[1], $grndRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.scale"), $grndScale[0], $grndScale[1], $grndScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.clone") ($prfx + $name + "_Ground");
		
		
		if ($prfx == "l_")
		{//SWITCH TO RIGHT
			$prfx = "r_";
		}
		$i++;
	}
	
	//GENERATE NEW LEG(S)
	select ("RRM_" + $attachNode);
	RRM_CreateProxyLeg($name, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $mirrorMod);

	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$prfx = $prfxReset;
	$i = 1;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$hipPos   = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.translate")`;
		$hipRot   = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.rotate")`;		
		$hipScale = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Hip.translate"), $hipPos[0], $hipPos[1], $hipPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Hip.rotate"), $hipRot[0], $hipRot[1], $hipRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Hip.scale"), $hipScale[0], $hipScale[1], $hipScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Hip_Lctr");

			
		if ($kneeJoints == 1)
		{
			$kneePos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee_Lctr.translate")`;
			$kneeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee.translate"), $kneePos[0], $kneePos[1], $kneePos[2]);
			delete ("RRM_" + $prfx + $modName + "_Knee_Lctr");
		}
		else
		{
			$knee1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1_Lctr.translate")`;
			$knee1Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee1.translate"), $knee1Pos[0], $knee1Pos[1], $knee1Pos[2]);
			delete ("RRM_" + $prfx + $modName + "_Knee1_Lctr");

			$knee2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.translate")`;
			$knee2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.rotate")`;		
			$knee2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.scale")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee2.translate"), $knee2Pos[0], $knee2Pos[1], $knee2Pos[2]);
			setAttr ("RRM_" + $prfx + $name + "_Knee2.rotateY") $knee2Rot[1];
			delete ("RRM_" + $prfx + $modName + "_Knee2_Lctr");
		}

		$anklePos   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.translate")`;
		$ankleRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.rotate")`;		
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ankle.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ankle.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ankle.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ankle_Lctr");


		$ballPos   = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.translate")`;
		$ballRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.rotate")`;		
		$ballScale = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ball.translate"), $ballPos[0], $ballPos[1], $ballPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ball.rotate"), $ballRot[0], $ballRot[1], $ballRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ball.scale"), $ballScale[0], $ballScale[1], $ballScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ball_Lctr");

		$toePos   = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.translate")`;
		$toeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.rotate")`;		
		$toeScale = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Toe.translate"), $toePos[0], $toePos[1], $toePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Toe.rotate"), $toeRot[0], $toeRot[1], $toeRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Toe.scale"), $toeScale[0], $toeScale[1], $toeScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Toe_Lctr");


		$heelPivPos   = `getAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_HeelPivot.tx") $heelPivPos[0];
		setAttr ("RRM_" + $prfx + $name + "_HeelPivot.tz") $heelPivPos[2];
		delete ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr");


		$lTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_FootLeftTilt.tx") $lTiltPos[0];
		setAttr ("RRM_" + $prfx + $name + "_FootLeftTilt.tz") $lTiltPos[2];
		delete ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr");


		$rTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_FootRightTilt.tx") $rTiltPos[0];
		setAttr ("RRM_" + $prfx + $name + "_FootRightTilt.tz") $rTiltPos[2];
		delete ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr");


		$anklePos   = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.translate")`;
		$ankleRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.rotate")`;		
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ground.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ground.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ground.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ground_Lctr");

		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_FkChain(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $chainsNum = `getAttr ("RRM_" + $modName + ".chainsNum")`;
	int $jointsNum = `getAttr ("RRM_" + $modName + ".jointsNum")`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $i = 0;
	
	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
		
		//WHILE LOOP FOR CHAINS
		int $chainLoop = 1;
		while ($chainLoop <= $chainsNum)
		{
			string $nPd = "_0";
			if ($chainLoop >= 10)
			{
				string $nPd = "_";
			}
			$jointLoop = 1;
			//WHILE LOOP FOR JOINTS
			while ($jointLoop <= $jointsNum)
			{				
				string $jPad = "_0";
				if ($chainLoop >= 10)
				{
					string $jPad = "_";
				}
				//MOVE PROXY TO LOCATOR
				spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr");
				$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".translate")`;
				$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".rotate")`;
				$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".scale")`;
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
				//CLONE ATT
				setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".clone") ($prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop);
				$jointLoop++;		
			}
			$chainLoop++;
		}
		$prfx = "r_";
		$i++;
	}
	
	//GENERATE NEW FK CHAIN
	select ("RRM_" + $attachNode);
	RRM_CreateProxyFKChain($name, $chainsNum, $jointsNum, $direction, $direction, $mirrorMod);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		
		//WHILE LOOP FOR CHAINS
		int $chainLoop = 1;
		while ($chainLoop <= $chainsNum)
		{
			string $nPd = "_0";
			if ($chainLoop >= 10)
			{
				string $nPd = "_";
			}
			$jointLoop = 1;
			//WHILE LOOP FOR JOINTS
			while ($jointLoop <= $jointsNum)
			{			
				string $jPad = "_0";
				if ($chainLoop >= 10)
				{
					string $jPad = "_";
				}
				//MOVE PROXY TO LOCATOR
				$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.translate")`;
				$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.rotate")`;		
				$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.scale")`;		
				
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
				delete ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr");
				$jointLoop++;
			}
			$chainLoop++;
		}
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_Head(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $jaw = `getAttr ("RRM_" + $modName + ".jaw")`;
	int $i = 0;

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
		
		if ($jaw == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Jaw_Lctr");
			$jawPos   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.translate")`;
			$jawRot   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.rotate")`;
			$jawScale = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.translate"), $jawPos[0], $jawPos[1], $jawPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.rotate"), $jawRot[0], $jawRot[1], $jawRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.scale"), $jawScale[0], $jawScale[1], $jawScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.clone") ($prfx + $name + "_Jaw");
			
			spaceLocator -n ("RRM_" + $prfx + $modName + "_JawEnd_Lctr");
			$jawEndPos   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.translate")`;
			$jawEndRot   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.rotate")`;
			$jawEndScale = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.translate"), $jawEndPos[0], $jawEndPos[1], $jawEndPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.rotate"), $jawEndRot[0], $jawEndRot[1], $jawEndRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.scale"), $jawEndScale[0], $jawEndScale[1], $jawEndScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.clone") ($prfx + $name + "_JawEnd");
		}
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Top_Lctr");
		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top.rotate")`;
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.scale"), $topScale[0], $topScale[1], $topScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.clone") ($prfx + $name + "_Top");

		$prfx = "r_";
		$i++;
	}
	
	//GENERATE NEW HEAD
	select ("RRM_" + $attachNode);
	RRM_CreateProxyHead($name, $jaw, $mirrorMod);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;

		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		if ($jaw == 1)
		{
			$jawPos   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.translate")`;
			$jawRot   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.rotate")`;		
			$jawScale = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + "_Jaw.translate"), $jawPos[0], $jawPos[1], $jawPos[2]);
			setAttr (("RRM_" + $prfx + $name + "_Jaw.rotate"), $jawRot[0], $jawRot[1], $jawRot[2]);
			setAttr (("RRM_" + $prfx + $name + "_Jaw.scale"), $jawScale[0], $jawScale[1], $jawScale[2]);
			delete ("RRM_" + $prfx + $modName + "_Jaw_Lctr");
			
			$jawEndPos   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.translate")`;
			$jawEndRot   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.rotate")`;		
			$jawEndScale = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.translate"), $jawEndPos[0], $jawEndPos[1], $jawEndPos[2]);
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.rotate"), $jawEndRot[0], $jawEndRot[1], $jawEndRot[2]);
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.scale"), $jawEndScale[0], $jawEndScale[1], $jawEndScale[2]);
			delete ("RRM_" + $prfx + $modName + "_JawEnd_Lctr");
		}

		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.rotate")`;		
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Top.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.scale"), $topScale[0], $topScale[1], $topScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Top_Lctr");

		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_LookAt(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{//CHECK IF LOOKAT
	//GET NUMBER OF JOINTS
	int $eyeNum = `getAttr ("RRM_" + $modName + ".eyeNum")`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $i = 0;

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");

		//WHILE LOOP
		int $i2 = 1;
		while ($i2 <= $eyeNum)
		{
			string $nPd = "_0";
			if ($i2 >= 10)
			{
				string $nPd = "_";
			}
			//TRANSFORMS LOCATOR
			spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr");
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".rotate")`;
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".scale")`;
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i2 + ".clone") ("RRM_" + $prfx + $modName + $nPd + $i2);
			$i2++;
		}
		$prfx = "r_";
		$i++;
	}
	
	//GENERATE NEW LOOK AT
	select ("RRM_" + $attachNode);
	RRM_CreateProxyLookAt($name, $eyeNum, $direction, $direction, $mirrorMod);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;

		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$i3 = 1;
		while ($i3 <= $eyeNum)
		{
			string $nPd = "_0";
			if ($i3 >= 10)
			{
				string $nPd = "_";
			}
			//MOVE PROXY TO LOCATOR
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.rotate")`;		
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			delete ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr");
			$i3++;
		}
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_Auxiliary(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	int $i = 0;
	
	while ($i <= $mirrorMod)
	{
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.clone") ($prfx + $name + "_Aux");
		$prfx = "r_";
		$i++;
	}

	//GENERATE NEW AUXILIARY
	select ("RRM_" + $attachNode);
	RRM_CreateProxyAuxiliary($name, $mirrorMod);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
	
	while ($i <= $mirrorMod)
	{
		delete `parentConstraint ("RRM_" + $prfx + $modName + "_Aux") ("RRM_" + $prfx + $name + "_Aux")`;
		delete `scaleConstraint ("RRM_" + $prfx + $modName + "_Aux") ("RRM_" + $prfx + $name + "_Aux")`;
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

	
global proc RRM_Clone(string $name, string $selection, string $attachNode, int $call)
{
	string $modName;
	string $modType;
	string $side;
	string $ext;
	
	if ($call == 0)
	{
		$modName = `getAttr ($selection + ".modName")`;
		$modType = `getAttr ("RRM_" + $modName + ".top")`;
		$attachNode = `getAttr ("RRM_" + $modName + ".parent")`;
	}
	else
	{
		$modName = `getAttr ("RRM_" + $selection + ".core")`;
		$modType = `getAttr ("RRM_" + $selection + ".top")`;
		//ORIGINAL MODULE'S ATTACH NODE
		$sourceAttachNode = `getAttr ("RRM_" + $modName + ".parent")`;

		//GET ATTACH NODE'S CLONED ATTRIBUTE
		string $cloneName = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		if (`gmatch $cloneName ""`)
		{//ATTACH NODE IS NOT A CLONE
			$attachNode = ($sourceAttachNode);
		}
		else
		{//ATTACH NODE IS A CLONE
			$attachNode = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		}
	}
	string $clonedParentNodes[];	

	int $mirrorMod = 1;
	string $prfx = "l_";
	string $prfxReset = "l_";
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 0;
		$prfx = "";
		$prfxReset = "";
	}
	int $firstTimeThrough;

		
	//CHECK IF SPLINE
	if (`gmatch $modType "spline"`)
	{
		RRM_Clone_Spline($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "arm"`)
	{//CHECK IF ARM
		RRM_Clone_Arm($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "leg"`)
	{//CHECK IF LEG
		RRM_Clone_Leg($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "fkChain"`)
	{//CHECK IF FKCHAIN
		RRM_Clone_FkChain($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "head"`)
	{//CHECK IF HEAD
		RRM_Clone_Head($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "lookAt"`)
	{//CHECK IF LOOKAT
		RRM_Clone_LookAt($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "auxiliary"`)
	{//CHECK IF AUXILIARY
		RRM_Clone_Auxiliary($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
		
	if ($call <= 1)
	{
		//CHECK TO SEE IF IT IS NOT AN AUXILIARY
		//print ("name is " + $name + "\n");
		if (!`objExists ("RRM_" + $name + "_Aux")` && !`objExists ("RRM_l_" + $name + "_Aux")`)
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_Lctr";
			setAttr -e-keyable true "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Parent");
			if (!`objExists ("RRM_" + $name + "_Parent")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_l_" + $name + "_Parent");
			}
		}
		else
		{
			spaceLocator -n ("RRM_Clone_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_Lctr";
			setAttr -e-keyable true "RRM_Clone_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_" + $name + "_Aux");
			if (!`objExists ("RRM_" + $name + "_Aux")`)
			{
				setAttr -type "string" "RRM_Clone_Lctr.topCloneNode" ("RRM_l_" + $name + "_Aux");
			}
		}			
	}
}

global proc RRM_CheckCloneFields(int $cloneCheck[], string $textFields[], string $cloneSource[], string $cloneParent[])
{
	int $i;
	string $each;
	for ($each in $textFields)
	{
		$name = `textField -q -text $each`;
		$nameSize = `size $name`;
		if (`objExists ("RRM_" + $name)`)
		{
		string $returnVal_Generate = `confirmDialog
			-title "Module Already Exists"
			-message ("A module named \"" + $name + "\" already exists. You need to use a unique name.\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
			error "PLEASE PROVIDE UNIQUE NAMES FOR ALL CLONED MODULES.";
		}
		else if ($nameSize == 0)
		{
		string $returnVal_Generate = `confirmDialog
			-title "Missing Name"
			-message "You need to provide a name for each module.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
			error "PLEASE PROVIDE UNIQUE NAMES FOR ALL CLONED MODULES.";
		}
		$i++;
	}
	$i = 0;
	for ($each in $textFields)
	{
		$name = `textField -q -text $each`;
		RRM_Clone($name, $cloneSource[$i], $cloneParent[$i], ($i + 1));
		$i++;
	}
}

global proc RRM_CloneHierarchyUI()
{
	$name = `textField -q -text textFieldCloneName`;
	string $selection[] = `ls -sl`;
	string $modName = `getAttr ($selection[0] + ".modName")`;
	$nodes = `listRelatives -ad ("RRM_" + $modName)`;
	string $topModules[];
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".top")`)
		{
			$topModules = `ls $topModules $each`;
		}
	}
	//GET DIALOG'S FORMLAYOUT
	string $form = `setParent -q`;
	
	formLayout -e -width 300 $form;
	string $instructions = `text -l "Rename Branches"`;
	string $original = `text -l "SOURCE NAME:"`;
	string $clone = `text -l "CLONE NAME:"`;
	formLayout -edit
		-attachForm				$instructions 	"top" 5
		-attachForm				$instructions 	"left" 90
		
		-attachForm				$original 	"top" 30
		-attachForm				$original 	"left" 4
		
		-attachForm				$clone 	"top" 30
		-attachForm				$clone 	"right" 75
	$form;
	int $i;
	string $checkBoxes[];
	global int $cloneCheck[];
	global string $cloneTextFields[];
	global string $cloneSource[];
	global string $cloneParent[];
	int $spacer = 10;
	int $top = 50;
	string $eachBranch;
	for ($eachBranch in $topModules)
	{
		//GET CORE NAME
		$coreName = `getAttr ($eachBranch + ".core")`;
		
		//GET PLACE IN HIERARCHY
		$left = 20;
		string $parentModule = $eachBranch;
		while (!`gmatch $parentModule ("RRM_" + $modName)`)
		{
			$parentNode = `getAttr ($parentModule + ".parent")`;
			$parentModule = `getAttr ("RRM_" + $parentNode + ".modName")`;
			$parentModule = ("RRM_" + $parentModule); 
			$left = ($left + 16);
		}
			
		string $checkBox = `checkBox -en 0 -vis 0 -v 0 -l "" ("checkBox_" + $eachBranch)`;
		string $label = `text -l ("-" + $coreName)`;
		string $textField = `textField -w 150 ("textField" + $eachBranch)`;
		
		formLayout -edit
			-attachForm			$checkBox		"top" $top
			-attachForm			$checkBox		"left" 4

			-attachForm			$label			"top" $top
			-attachForm			$label			"left" $left
			
			-attachForm			$textField		"top" $top
			-attachForm			$textField		"right" 5
		$form;
		
		$top = ($top + 20);
		$cloneCheck[$i] = `checkBox -q -v $checkBox`;
		$cloneTextFields[$i] =  $textField;
		$cloneSource[$i] = $coreName;
		string $cloneParent[];
		if (`objExists ("RRM_" + $coreName + ".parent")`)
		{
			$cloneParent[$i] = `getAttr ("RRM_" + $coreName + ".parent")`;
		}
		else
		{
			$cloneParent[$i] = `getAttr ("RRM_" + $coreName + ".attachNode")`;
		}
		$i++;
	}
	string $button_OK = `button -w 144 -label "OK" -c "RRM_CheckCloneFields($cloneCheck, $cloneTextFields, $cloneSource, $cloneParent);layoutDialog -dismiss \"OK\";" Clone_Button`;
	string $button_Cancel = `button -w 144 -label "Cancel" -c "layoutDialog -dismiss \"Cancel\""`;
	formLayout -edit
		-attachForm			$button_OK		"top" ($top + 10)
		-attachForm			$button_OK		"left" 4
		
		-attachForm			$button_Cancel	"top" ($top + 10)
		-attachForm			$button_Cancel	"right" 4
	$form;
	
	textField -e -text $name $cloneTextFields[0]; 
}

global proc RRM_ClonePrompts(string $name, int $branchClone, int $clone)
{
	string $selection[] = `ls -sl`;
	$selectionSize = `size $selection`;
	string $coreCheck;
	if (`objExists ($selection[0] + ".core")`)
	{
		$coreCheck = `getAttr ($selection[0] + ".core")`;
	}
	
	string $dupeType = "clone";
	if ($clone == 0)
	{
		$dupeType = "rename";
	}
	
	$nameCheck = `size $name`;
	if ($selectionSize == 0)
	{//CHECK THAT SOMETHING IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Nothing Selected"
			-message ("You must select a node of the desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if ($selectionSize > 1)
	{//CHECK THAT ONLY ONE OBJECT IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Only One Module May Be Cloned At A Time"
			-message ("You must select only one node of a desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (!`objExists ($selection[0] + ".core")`)
	{//CHECK TO MAKE SURE OBJECT IS A VALID MODULE
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message ("You must select one node of a desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	else if (`gmatch $coreCheck "MAIN"` || `gmatch $coreCheck "ROOT"`)
	{//CHECK TO MAKE SURE OBJECT IS NOT MAIN OR ROOT
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message ("You cannot " + $dupeType + " the MAIN or ROOT modules.\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	else if ($nameCheck == "0")
	{//CHECK TO MAKE SURE THE USER HAS INPUT A NAME
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message ("You must enter a name for the " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (! RRM_CheckName($name))
	{//CHECK TO MAKE SURE A VALID NAME HAS BEEN USED
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ("RRM_" + $name)`)
	{//CHECK TO MAKE SURE NAME DOES NOT CONFLICT WITH EXISTING OBJECT
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $parentNullName = "";
		if ($branchClone == 0)
		{//ONLY CLONE LOADED MODULE
			if ($clone == 1)
			{
				print "cloning...\n";
				RRM_Clone($name, $selection[0], $parentNullName, 0);
			}
			else
			{
				print "renaming...\n";
				RRM_Rename($name, $selection[0], 0);
			}
		}
		else
		{//CLONE BRANCHES
			string $topmodules[];
			$modName = `getAttr ($selection[0] + ".modName")`;
			
			$hierarchy = `listRelatives -ad ("RRM_" + $modName)`;
			$nodes = `ls -type "nurbsCurve" $hierarchy`;
			
			string $each;
			for ($each in $nodes)
			{
				if (`objExists ($each + ".top")`)
				{
					$topmodules = `ls $topmodules $each`;
				}
			}
			$moduleNum = `size $topmodules`;
			if ($moduleNum == 1)
			{
				if ($clone = 1) 
				{
					RRM_Clone($name, $selection[0], $parentNullName, 0);
				}
				else
				{
					RRM_Rename($name, $selection[0], 0);
				}					
			}
			if ($branchClone == 1 && $moduleNum > 1)
			{
				select $selection[0];
				layoutDialog -ui "RRM_CloneHierarchyUI()";
			}
		}
		//RESET CLONE ATTRIBUTES FOR FUTURE CLONES
		
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		$shapeNodes = `ls -type "nurbsCurve" $hierarchy`;
		$nodes = `listRelatives -p $shapeNodes`;
		
		string $each;
		for ($each in $nodes)
		{
			if (`objExists ($each + ".clone")`)
			{
				setAttr -type "string" ($each + ".clone") "";
			}
		}
	}
	select -cl;
	int $selectionInt = 0;
	while ($selectionInt <= $selectionSize)
	{
		if (`objExists $selection[$selectionInt]`)
		{
			select -add $selection[$selectionInt];
		}
		$selectionInt++;
	}
	if (`objExists "RRM_Clone_Lctr.topCloneNode"`)
	{
		$topNode[0] = `getAttr "RRM_Clone_Lctr.topCloneNode"`;
		if (`objExists ($topNode[0] + ".opposite")`)
		{
			$opposite = `getAttr ($topNode[0] + ".opposite")`;
			$topNode[1] = ("RRM_" + $opposite);
		}
		delete "RRM_Clone_Lctr";
		select $topNode;
	}
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////DELETE BRANCH/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_DeleteBranch(string $eachMod)
{
	//UNLOCK NODES	
	$rigHierarchy = `listRelatives -ad RRM_MAIN`;
	
	lockNode -lock off $rigHierarchy;

	string $crntNode;
	int $crntInt = 0;
	select $eachMod;
	$eachNode = `ls $eachMod`;
	
	while ((!`objExists ($eachNode[0] + ".top")`) && ($crntInt < 101))
	{
		pickWalk -d up;
		$eachNode = `ls -sl`;
		$crntInt++;
	}
	if (`objExists ($eachNode[0] + ".top")`)
	{
		delete $eachNode;
		$crntInt = 100;
	}
	
	//LOCK NODES
	$rigHierarchy2 = `listRelatives -ad RRM_MAIN`;
	lockNode $rigHierarchy2;
}
			
global proc RRM_DeleteBranchPrompts()
{
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	$attachModNum = `size $attachMod`;
	string $eachMod;
	if ($attachModNum == 0)
	{
		string $returnVal_Generate = `confirmDialog
				-title "No Module Selected"
				-message "Please select a module node of a branch to delete.\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
	}
	else
	{
		for ($eachMod in $attachMod)
		{
			print ($eachMod + "\n");
			if (`objExists $eachMod` && !`objExists ($eachMod + ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Branch Node"
					-message "You cannot delete the selected node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ((`gmatch $eachMod "RRM_ROOT"`) || (`gmatch $eachMod "RRM_MAIN"`))
			{
				string $returnVal_Generate = `confirmDialog
					-title "Proxy Rig Deletion"
					-message "This will delete your entire proxy rig!\nAre you sure you wisth to proceed?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "critical"`;
				if ($returnVal_Generate == "OK") 
				{
					select -hi RRM_MAIN;
					$rigHierarchy = `ls -sl`;
					$rigHierarchy = `listRelatives -ad RRM_MAIN`;
					lockNode -lock off $rigHierarchy;
					delete RRM_MAIN;					
				}
			}
			else
			{
				if (`objExists $eachMod`)
				{
					RRM_DeleteBranch($eachMod);
				}
			}
		}
	}
}

global proc modLocalAxesToggleAll()
{
	$crnt = `ls -sl`;
	string $proxies[];
	$hierarchy = `listRelatives -ad RRM_MAIN`;
	string $crntProxy;
	for ($crntProxy in $hierarchy)
	{
	    if (`objExists ($crntProxy + ".core")`)
	    {
	    	$LocalAxisDisplay = `getAttr ($crntProxy + ".displayLocalAxis")`;
	    	if ($LocalAxisDisplay == 0)
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 1;
	    	}
	    	else
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 0;
	    	}
	    }
	}
	select $crnt;
}

global proc RRM_LocalAxesToggleSelected()
{
	$crnt = `ls -sl`;
	string $crntProxy;
	for ($crntProxy in $crnt)
	{
	    if (`objExists ($crntProxy + ".core")`)
	    {
	    	$LocalAxisDisplay = `getAttr ($crntProxy + ".displayLocalAxis")`;
	    	if ($LocalAxisDisplay == 0)
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 1;
	    	}
	    	else
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 0;
	    	}
	    }
	}
}

global proc RRM_LoadNewModuleAttachNode()
{
	$crnt = `ls -sl`;
	$crntSize = `size $crnt`;
	if ($crntSize == 1)
	{
		if (`objExists ($crnt[0] + ".core")`)
		{
			$checkMain = `getAttr ($crnt[0] + ".core")`;
			if (($checkMain != "MAIN") && (!`objExists ($crnt[0] + ".parent")`))
			{
				textFieldButtonGrp -e -text $crnt RRM_LoadNewModuleAttachNodeTextField;
			}
			else
			{
				warning "CANNOT ASSIGN THE MAIN CONTROL OR PARENT NODES AS THE NEW ATTACH NODE";
			}
		}
		else
		{
			warning "PLEASE SELECT A VALID PROXY NODE TO LOAD";
		}
	}
	else if ($crntSize == 0)
	{
		warning "PLEASE SELECT A PROXY NODE TO LOAD";
	}
	else
	{
		warning "PLEASE SELECT ONLY ONE NODE. MIRRORED PARENTS WILL AUTOMATICALLY BE CONNECTED PROPERLY";
	}
}

global proc RRM_AttachToNewModule(string $modAttachName)
{
	$checkMain = `getAttr ($modAttachName + ".core")`;
	if ((!`objExists $checkMain`) && ($checkMain != "MAIN") && (!`objExists ($checkMain + ".parent")`))
	{
		$parentModules = `ls -sl`;
		$moduleGroups = `listRelatives -p $parentModules`;
		$parentModulesHierarchy = `listRelatives -ad $parentModules`;
		
		string $eachModule;
		for ($eachModule in $parentModulesHierarchy)
		{
			if ($modAttachName == $eachModule)
			{
				select $parentModules;
				error "YOU CANNOT ATTACH PARENT NODES TO ONE OF THEIR CHILDREN";
			}
		}
		
		string $eachModule;
		for ($eachModule in $parentModules)
		{
			string $modType;
			if (`objExists ($eachModule + ".parent")`)
			{
				$modType = 	`getAttr ($eachModule + ".parent")`;
			}
			else if (`objExists ($eachModule + ".modType")`)
			{
				$modType = `getAttr ($eachModule + ".modType")`;
			}
			
			string $modAbsoluteParent[];
			if (`objExists ($eachModule + ".parent")` || $modType == "auxiliary")
			{
				$modParent = `listRelatives -p $eachModule`;
				$modAbsoluteParent[0] = $modParent[0];
				if (`objExists ($eachModule + ".pair")`)
				{
					if (`objExists ($modAttachName + ".pair")`)
					{
						$moduleSideCheck = `getAttr ($eachModule + ".pair")`; 
						if ($moduleSideCheck == "right")
						{
							$eachModule = `getAttr ($eachModule + ".opposite")`;
							$eachModule = ("RRM_" + $eachModule);
						}
						$modAttachSideCheck = `getAttr ($modAttachName + ".pair")`;
						if ($modAttachSideCheck == "right")
						{
							$modAttachName = `getAttr ($modAttachName + ".opposite")`;
							$modAttachName = ("RRM_" + $modAttachName);
						}
					}
					$modAbsoluteParent = `listRelatives -p $modParent[0]`;
				}
				
				//DELETE CONSTRAINTS
				lockNode -lock off ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1") $eachModule $modAbsoluteParent[0];
				delete ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1");
    	
				//PARENT IF NOT ALREADY PARENTED
				string $parent[] = `listRelatives -parent $modAbsoluteParent[0]`;
				if (!`gmatch $parent[0] $modAttachName`)
				{
					parent $modAbsoluteParent[0] $modAttachName;
				}
				
				//DELETE OLD CONNECTOR AND CREATE NEW ONE
				$attachCore = `getAttr ($eachModule + ".attachNode")`;
				$connectorHi = `listRelatives -ad ("RRM_" + $attachCore + "_" + $eachModule + "Ctrl") ("RRM_" + $attachCore + "_" + $eachModule + "_AimLctr")`;
				lockNode -lock off $connectorHi ;
				delete $connectorHi;
				
				$modName = `getAttr ($eachModule + ".modName")`;
				$prfx = "";
				if (`objExists ($eachModule + ".pair")`)
				{
					$sideCheck = `getAttr ($eachModule + ".pair")`;
					if ($sideCheck == "left")
					{
						$prfx = "l_";
					}
					else
					{
						$prfx = "r_";
					}
				}
				RRM_ProxyConnectors($modName, $prfx, $modAttachName, $eachModule);

				//MAKE NEW CONSTRAINTS
				parentConstraint -mo $modAttachName "RRM_MAIN" $modParent[0];
				scaleConstraint  -mo $modAttachName "RRM_MAIN" $modParent[0];
				setAttr ($modParent[0] + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ($modParent[0] + "_scaleConstraint1.RRM_MAINW1") 0;
				
				//CHANGE ATTACH NODE ATTRIBUTE IN PARENT NODE
				$modAttachCore = `getAttr ($modAttachName + ".core")`;
				setAttr -l false ($eachModule + ".attachNode");
				setAttr -type "string" ($eachModule + ".attachNode") $modAttachCore;
				setAttr -l true ($eachModule + ".attachNode");
				
				//CHANGE PARENT ATTRIBUTE IN TOP NODE
				setAttr -l false ($modAbsoluteParent[0] + ".parent");
				setAttr -type "string" ($modAbsoluteParent[0] + ".parent") $modAttachCore;
				
				
				//CHECK TO SEE IF MIRRORED////////////////////////////////////////////////////////////
				if (`objExists ($eachModule + ".pair")`)
				{
					$mirrorModule = `getAttr ($eachModule + ".opposite")`;
					$mirrorModule = ("RRM_" + $mirrorModule); 
					//
					////CHECK FOR MIRROR NODE
					$mirrorModAttachName = $modAttachName;
					$mirrorModAttachName = $mirrorModAttachName;
					

					$mirrorModuleSideCheck = `getAttr ($eachModule + ".pair")`; 
					if ($mirrorModuleSideCheck == "left")
					{
						$mirrorModule = `getAttr ($eachModule + ".opposite")`;
						$mirrorModule = ("RRM_" + $mirrorModule);
					}
					
					if (`objExists ($modAttachName + ".pair")`)
					{						
						$mirrorModAttachSideCheck = `getAttr ($modAttachName + ".pair")`;
						if ($mirrorModAttachSideCheck == "left")
						{
							$mirrorModAttachName = `getAttr ($modAttachName + ".opposite")`;
							$mirrorModAttachName = ("RRM_" + $mirrorModAttachName);
						}
					}

					$mirrorModParent = `listRelatives -p $mirrorModule`;
					
					//DELETE CONSTRAINTS
					lockNode -lock off ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1") $mirrorModule;
					delete ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1");
    	
					//DELETE OLD CONNECTOR AND CREATE NEW ONE
					$attachCore = `getAttr ($mirrorModule + ".attachNode")`;
					$connectorHi = `listRelatives -ad ("RRM_" + $attachCore + "_" + $mirrorModule + "Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr")`;
					lockNode -lock off $connectorHi ("RRM_" + $attachCore + "_" + $mirrorModule + "Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr");
					delete $connectorHi ("RRM_" + $attachCore + "_" + $mirrorModule + "Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr");
					
					$modName = `getAttr ($mirrorModule + ".modName")`;
					$prfx = "";
					if (`objExists ($mirrorModule + ".pair")`)
					{
						$sideCheck = `getAttr ($mirrorModule + ".pair")`;
						if ($sideCheck == "left")
						{
							$prfx = "l_";
						}
						else
						{
							$prfx = "r_";
						}
					}
					RRM_ProxyConnectors($modName, $prfx, $modAttachName, $mirrorModule);
					
					//MAKE NEW CONSTRAINTS
					if (`objExists $mirrorModAttachName`)
					{
						parentConstraint -mo ($mirrorModAttachName) "RRM_MAIN" $mirrorModParent[0];
						scaleConstraint  -mo ($mirrorModAttachName) "RRM_MAIN" $mirrorModParent[0];
						setAttr ($mirrorModParent[0] + "_parentConstraint1.RRM_MAINW1") 0;
						setAttr ($mirrorModParent[0] + "_scaleConstraint1.RRM_MAINW1") 0;

						//CHANGE ATTACH NODE ATTRIBUTE IN PARENT NODE
						$mirrorModAttachCore = `getAttr ($mirrorModAttachName + ".core")`;
						setAttr -l false ($mirrorModule + ".attachNode");
						setAttr -type "string" ($mirrorModule + ".attachNode") $mirrorModAttachCore;
						setAttr -l true ($mirrorModule + ".attachNode");
					}
					lockNode -lock on ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1") $mirrorModule;
				}
				lockNode -lock on ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1") $eachModule $modAbsoluteParent[0];
			}
			else
			{
				print ("\"" + $eachModule + "\" IS NOT A PARENT MODULE... SKIPPING\n");
			}
		}
		select $parentModules;
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////RESET///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_ResetProxies(int $RRM_ResetSelection)
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	$proxySize = `size $proxies`;
	string $crntProxy;
	string $topMods[];

	if ($RRM_ResetSelection == 2)
	{
		if ($proxySize > 0)
		{
			for ($crntProxy in $proxies)
			{
				if (!`objExists ($crntProxy + ".parent")`)
				{
					string $crntProxy2;
					$crntInt = 0;
					while ((!`objExists ($crntProxy2 + ".parent")`) && ($crntInt < 103))
					{
						$parentCheck = `listRelatives -p $proxies`;
						
						if (`objExists ($parentCheck[0] + ".parent")`)
						{
							$crntTopMod = `ls -sl`;
							$topMods = `ls $topMods $crntTopMod`;
						}
						
						$crntProxy2 = $parentCheck[0];
						$crntInt++;
					}
				}
				else
				{
					$topMods = `ls -type "transform" $crntProxy $topMods`;
				}
			}
			
			$hierarchy = `listRelatives -ad $topMods`;
			string $crntProxy3;
			for ($crntProxy3 in $hierarchy)
			{
			    if (`objExists ($crntProxy3 + ".core")`)
			    {
			        $proxies = `ls $proxies $crntProxy3`;
			    }
			}
		}
	}
	else if ($RRM_ResetSelection == 3)
	{
		$hierarchy = `listRelatives -ad RRM_MAIN`;

		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".core")`)
		    {
		        $proxies = `ls $proxies $crntProxy`;
		    }
		}
	}
	
	string $crntProxy;
	for ($crntProxy in $proxies)
	{
		if (!`gmatch $crntProxy "RRM_ROOT"` && !`objExists ($crntProxy + ".parent")`)
		{
			$lockTX = `getAttr -lock ($crntProxy + ".tx")`;
			$lockTY = `getAttr -lock ($crntProxy + ".ty")`;
			$lockTZ = `getAttr -lock ($crntProxy + ".tz")`;
			$lockRX = `getAttr -lock ($crntProxy + ".rx")`;
			$lockRY = `getAttr -lock ($crntProxy + ".ry")`;
			$lockRZ = `getAttr -lock ($crntProxy + ".rz")`;
			$lockSX = `getAttr -lock ($crntProxy + ".sx")`;
			$lockSY = `getAttr -lock ($crntProxy + ".sy")`;
			$lockSZ = `getAttr -lock ($crntProxy + ".sz")`;
		
			if ($lockTX == 0)
			{
				setAttr ($crntProxy + ".tx") 0;
			}
			if ($lockTY == 0)
			{
				setAttr ($crntProxy + ".ty") 0;
			}
			if ($lockTZ == 0)
			{
				setAttr ($crntProxy + ".tz") 0;
			}
			if ($lockRX == 0)
			{
				setAttr ($crntProxy + ".rx") 0;
			}
			
			if ($lockRY == 0)
			{
				setAttr ($crntProxy + ".ry") 0;
			}
			if ($lockRZ == 0)
			{
				setAttr ($crntProxy + ".rz") 0;
			}
			
			if ($lockSX == 0)
			{
				setAttr ($crntProxy + ".sx") 1;
			}
			if ($lockSY == 0)
			{
				setAttr ($crntProxy + ".sy") 1;
			}
			if ($lockSZ == 0)
			{
				setAttr ($crntProxy + ".sz") 1;
			}
			select $originalSelection;
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////RIGHT TO LEFT///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_RightToLeftProxies(int $RRM_ResetSelection)
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	$proxySize = `size $proxies`;
	string $crntProxy;
	string $topMods[];
	
	if ($RRM_ResetSelection == 2)
	{
		if ($proxySize > 0)
		{
			for ($crntProxy in $proxies)
			{
				if (!`objExists ($crntProxy + ".parent")`)
				{
					string $crntProxy2;
					$crntInt = 0;
					while ((!`objExists ($crntProxy2 + ".parent")`) && ($crntInt < 103))
					{
						$parentCheck = `listRelatives -p $proxies`;
						if (`objExists ($parentCheck[0] + ".parent")`)
						{
							$crntTopMod = `ls -sl`;
							$topMods = `ls $topMods $crntTopMod`;
						}
						
						$crntProxy2 = $parentCheck[0];
						$crntInt++;
					}
				}
				else
				{
					$topMods = `ls $crntProxy $topMods`;
				}
			}
			$hierarchy = `listRelatives -ad $topMods`;
			
			string $crntProxy3;
			for ($crntProxy3 in $hierarchy)
			{
			    if (`objExists ($crntProxy3 + ".core")`)
			    {
			        $proxies = `ls $proxies $crntProxy3`;
			    }
			}
		}
	}
	else if ($RRM_ResetSelection == 3)
	{
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".core")`)
		    {
		        $proxies = `ls $proxies $crntProxy`;
		    }
		}
	}
	
	string $crntProxy;
	for ($crntProxy in $proxies)
	{
		if (`objExists ($crntProxy + ".opposite")`)
		{
			string $side = `getAttr ($crntProxy + ".pair")`;
			if ($side == "left"|| $side == "right")
			{
				string $opp = `getAttr ($crntProxy + ".opposite")`;
				if ($side == "left")
				{
					$crntProxy = ("RRM_" + $opp);
				}
				string $opp = `getAttr ($crntProxy + ".opposite")`;
				
				$lockTX = `getAttr -lock ($crntProxy + ".tx")`;
				$lockTY = `getAttr -lock ($crntProxy + ".ty")`;
				$lockTZ = `getAttr -lock ($crntProxy + ".tz")`;
				$lockRX = `getAttr -lock ($crntProxy + ".rx")`;
				$lockRY = `getAttr -lock ($crntProxy + ".ry")`;
				$lockRZ = `getAttr -lock ($crntProxy + ".rz")`;
				$lockSX = `getAttr -lock ($crntProxy + ".sx")`;
				$lockSY = `getAttr -lock ($crntProxy + ".sy")`;
				$lockSZ = `getAttr -lock ($crntProxy + ".sz")`;
				

				if ($lockTX == 0)
				{
					$tx = `getAttr ($crntProxy + ".tx")`;
					setAttr ("RRM_" + $opp + ".tx") ($tx * -1);
				}
				if ($lockTY == 0)
				{
					$ty = `getAttr ($crntProxy + ".ty")`;
					setAttr ("RRM_" + $opp + ".ty") ($ty * 1);
				}
				if ($lockTZ == 0)
				{
					$tz = `getAttr ($crntProxy + ".tz")`;
					setAttr ("RRM_" + $opp + ".tz") ($tz * 1);
				}
				if ($lockRX == 0)
				{
					$rx = `getAttr ($crntProxy + ".rx")`;
					setAttr ("RRM_" + $opp + ".rx") ($rx * 1);
				}
				if ($lockRY == 0)
				{
					$ry = `getAttr ($crntProxy + ".ry")`;
					setAttr ("RRM_" + $opp + ".ry") ($ry * -1);
				}
				if ($lockRZ == 0)
				{
					$rz = `getAttr ($crntProxy + ".rz")`;
					setAttr ("RRM_" + $opp + ".rz") ($rz * -1);
				}
				if ($lockSX == 0)
				{
					$sx = `getAttr ($crntProxy + ".sx")`;
					setAttr ("RRM_" + $opp + ".sx") ($sx * 1);
				}
				if ($lockSY == 0)
				{
					$sy = `getAttr ($crntProxy + ".sy")`;
					setAttr ("RRM_" + $opp + ".sy") ($sy * 1);
				}
				if ($lockSZ == 0)
				{
					$sz = `getAttr ($crntProxy + ".sz")`;
					setAttr ("RRM_" + $opp + ".sz") ($sz * 1);
				}
			}
		}
	}
	select $originalSelection;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////LEFT TO RIGHT///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_LeftToRightProxies(int $RRM_ResetSelection)
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	$proxySize = `size $proxies`;
	string $topMods[];
	
	if ($RRM_ResetSelection == 2)
	{//BRANCH RESET
		if ($proxySize > 0)
		{//CHECK THAT SOMETHING IS SELECTED
			for ($crntProxy in $proxies)
			{
				if (!`objExists ($crntProxy + ".parent")`)
				{
					string $crntProxy2;
					$crntInt = 0;
					while ((!`objExists ($crntProxy2 + ".parent")`) && ($crntInt < 103))
					{
						pickWalk -d up;
						$parentCheck = `listRelatives -p $proxies`;
						if (`objExists ($parentCheck[0] + ".parent")`)
						{
							$crntTopMod = `ls -sl`;
							$topMods = `ls $topMods $crntTopMod`;
						}
						
						$crntProxy2 = $parentCheck[0];
						$crntInt++;
					}
				}
				else
				{
					$topMods = `ls $crntProxy $topMods`;
				}
			}
			$hierarchy = `listRelatives -ad $topMods`;

			string $crntProxy3;
			for ($crntProxy3 in $hierarchy)
			{
				$template = `getAttr ($crntProxy3 + ".template")`;
		    	if ((`objExists ($crntProxy3 + ".core")`) && ($template == 0))
		    	{
		    	    $proxies = `ls $proxies $crntProxy3`;
		    	}
			}
		}
	}
	else if ($RRM_ResetSelection == 3)
	{//ALL RESET
		$hierarchy = `listRelatives -ad RRM_MAIN`;

		for ($crntProxy in $hierarchy)
		{
			$template = `getAttr ($crntProxy + ".template")`;
		    if ((`objExists ($crntProxy + ".core")`) && ($template == 0))
		    {
		        $proxies = `ls $proxies $crntProxy`;
		    }
		}
	}
	
	for ($crntProxy in $proxies)
	{
		if (`objExists ($crntProxy + ".opposite")`)
		{
			string $side = `getAttr ($crntProxy + ".pair")`;
			if ($side == "left"|| $side == "right")
			{
				string $opp = `getAttr ($crntProxy + ".opposite")`;
				if ($side == "right")
				{
					$crntProxy = ("RRM_" + $opp);
				}
				string $opp = `getAttr ($crntProxy + ".opposite")`;

				$lockTX = `getAttr -lock ($crntProxy + ".tx")`;
				$lockTY = `getAttr -lock ($crntProxy + ".ty")`;
				$lockTZ = `getAttr -lock ($crntProxy + ".tz")`;
				$lockRX = `getAttr -lock ($crntProxy + ".rx")`;
				$lockRY = `getAttr -lock ($crntProxy + ".ry")`;
				$lockRZ = `getAttr -lock ($crntProxy + ".rz")`;
				$lockSX = `getAttr -lock ($crntProxy + ".sx")`;
				$lockSY = `getAttr -lock ($crntProxy + ".sy")`;
				$lockSZ = `getAttr -lock ($crntProxy + ".sz")`;
								
				if ($lockTX == 0)
				{
					$tx = `getAttr ($crntProxy + ".tx")`;
					setAttr ("RRM_" + $opp + ".tx") ($tx * -1);
				}
				if ($lockTY == 0)
				{
					$ty = `getAttr ($crntProxy + ".ty")`;
					setAttr ("RRM_" + $opp + ".ty") ($ty * 1);
				}
				if ($lockTZ == 0)
				{
					$tz = `getAttr ($crntProxy + ".tz")`;
					setAttr ("RRM_" + $opp + ".tz") ($tz * 1);
				}
				if ($lockRX == 0)
				{
					$rx = `getAttr ($crntProxy + ".rx")`;
					setAttr ("RRM_" + $opp + ".rx") ($rx * 1);
				}
				if ($lockRY == 0)
				{
					$ry = `getAttr ($crntProxy + ".ry")`;
					setAttr ("RRM_" + $opp + ".ry") ($ry * -1);
				}
				if ($lockRZ == 0)
				{
					$rz = `getAttr ($crntProxy + ".rz")`;
					setAttr ("RRM_" + $opp + ".rz") ($rz * -1);
				}
				if ($lockSX == 0)
				{
					$sx = `getAttr ($crntProxy + ".sx")`;
					setAttr ("RRM_" + $opp + ".sx") ($sx * 1);
				}
				if ($lockSY == 0)
				{
					$sy = `getAttr ($crntProxy + ".sy")`;
					setAttr ("RRM_" + $opp + ".sy") ($sy * 1);
				}
				if ($lockSZ == 0)
				{
					$sz = `getAttr ($crntProxy + ".sz")`;
					setAttr ("RRM_" + $opp + ".sz") ($sz * 1);
				}
			}
		}
	}
	select $originalSelection;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////PINNING///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_PinProxies(int $on, int $off)
{
	$selected = `ls -sl`;
	$selectedSize = `size $selected`;
	string $parentModules[];
	int $parentModSize;
	string $prfx = "";
	string $rootCheck;
	select $selected;
	//CHECK THAT SOMETHING IS SELECTED
	if ($selectedSize > 0)
	{
		//CHECK IF VALID MODULE
		string $each;
		for ($each in $selected)
		{
			if (`objExists ($each + ".modName")`)
			{
				//CHECK IF PAIR, GET PREFIX IF TRUE
				if (`objExists ($each + ".pair")`)
				{
					$sideCheck = `getAttr ($each + ".pair")`;
					if ($sideCheck == "left")
						{$prfx = "l_";}
					else if ($sideCheck == "right")
						{$prfx = "r_";}
				}
				else
				{
					$prfx = "";
				}
				$modName = `getAttr ($each + ".modName")`;
				//CHECK IF ROOT
				$rootCheck = `getAttr ($each + ".core")`;
				{
					if ($rootCheck == "ROOT")
					{
						warning "YOU CANNOT PIN THE ROOT PROXY.";
					}
					else if ($rootCheck == "MAIN")
					{
						warning "YOU CANNOT PIN THE MAIN PROXY.";
					}
					else
					{
						$parentModules = `ls ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "*_Aux") $parentModules`;
						$parentModSize = `size $parentModules`;
					}
				}
			}
		}
		if ($parentModSize > 0)
		{
			//GET WORLD SPACE AND SCALE
			string $each2;
			string $mirroredTopNode;
			$topNodeScale = <<1,1,1>>;
			for ($each2 in $parentModules)
			{
				$pinCheck = `getAttr ($each2 + ".pinned")`;
				if ($pinCheck != $on)
				{
					//CHECK IF PAIR, GET PREFIX IF TRUE
					if (`objExists ($each2 + ".pair")`)
					{
						$sideCheck = `getAttr ($each2 + ".pair")`;
						if ($sideCheck == "left")
							{$prfx = "l_";}
						else if ($sideCheck == "right")
							{$prfx = "r_";}
						//GET TOP NODE'S SCALE
						$mirroredTopNode = `getAttr ($each2 + ".modName")`;
						$topNodeScale = `getAttr ("RRM_" + $mirroredTopNode + ".scale")`;
					}
					else 
					{
						$prfx = "";
						$topNodeScale = <<1,1,1>>;
					}
	
					$modLoc = `xform -q -ws -rp $each2`;
					$modRot = `xform -q -ws -ro $each2`;
					
					//GET SCALE
					spaceLocator -n ($each + "_ScaleLctr");
					parent ($each + "_ScaleLctr") RRM_MAIN;
					scaleConstraint $each2 ($each + "_ScaleLctr");
					$modScale = `getAttr ($each + "_ScaleLctr.scale")`;
					delete ($each + "_ScaleLctr");
					
					$modName  = `getAttr ($each2 + ".modName")`;
					$topScale = `getAttr ("RRM_" + $prfx + $modName + ".scale")`;
					
					$scaleRatio[0] = ($modScale[0] * $topScale[0] * $topNodeScale.x);
					$scaleRatio[1] = ($modScale[1] * $topScale[1] * $topNodeScale.y);
					$scaleRatio[2] = ($modScale[2] * $topScale[2] * $topNodeScale.z);
					
					//ATTACH NODE
					string $attachNode;
					if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
					{
						$attachNode = `getAttr ("RRM_" + $prfx + $modName + "_Parent.attachNode")`;
					}
					else if (`objExists ("RRM_" + $prfx + $modName + "_Aux")`)
					{
						$attachNode = `getAttr ("RRM_" + $prfx + $modName + "_Aux.attachNode")`;
					}

					//SET CONSTRAINT WEIGHTS
					setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_" + $attachNode + "W0") $off;
					setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") $on;				
					setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_" + $attachNode + "W0") $off;
					setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") $on;
					
					//SET SCALE VALUES
					setAttr (($each2 + ".scale"), $scaleRatio[0], $scaleRatio[1], $scaleRatio[2]);
					//SET ROTATE
					rotate -ws -a $modRot[0] $modRot[1] $modRot[2] $each2;
					//SET SCALE
					move -ws $modLoc[0] $modLoc[1] $modLoc[2] $each2;
					
					////CHANGE COLOUR OF CONNECTOR
					//setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_ParentCtrl.overrideColor") (6 + (7 * $on));

					
					if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
					{
						//CHANGE COLOUR OF CONNECTOR
						setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_ParentCtrl.overrideColor") (6 + (7 * $on));

						//SET PIN CHANNEL
						lockNode -lock 0 ("RRM_" + $prfx + $modName + "_Parent");
						setAttr -lock 0 ("RRM_" + $prfx + $modName + "_Parent.pinned");
						setAttr ("RRM_" + $prfx + $modName + "_Parent.pinned") $on;
						setAttr -lock 1 ("RRM_" + $prfx + $modName + "_Parent.pinned");
						lockNode ("RRM_" + $prfx + $modName + "_Parent");
					}
					else if (`objExists ("RRM_" + $prfx + $modName + "_Aux")`)
					{
						//CHANGE COLOUR OF CONNECTOR
						setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_AuxCtrl.overrideColor") (6 + (7 * $on));

						//SET PIN CHANNEL
						lockNode -lock 0 ("RRM_" + $prfx + $modName + "_Aux");
						setAttr -lock 0 ("RRM_" + $prfx + $modName + "_Aux.pinned");
						setAttr ("RRM_" + $prfx + $modName + "_Aux.pinned") $on;
						setAttr -lock 1 ("RRM_" + $prfx + $modName + "_Aux.pinned");
						lockNode ("RRM_" + $prfx + $modName + "_Aux");
					}						
				}
			}
		}
		else
		{
			warning "NO VALID MODULES WERE SELECTED";
		}
	}
	else
	{
		warning "NOTHING SELECTED";
	}
	select $selected;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////TRANSFER TRANSFORMS///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_TransferModTransforms2()
{
	//CHECK WHETHER TO INCLUDE PARENT NODE
	$parentCheck = `checkBox -q -v RRM_TransferParent`;
	
	$sourceAndDestination = `ls -sl`;
	$sourceParent[0] = $sourceAndDestination[0];
	$destinationParent[0] = $sourceAndDestination[1];
	
	select -hi $sourceParent[0];
	select -d "*Shape" "*Constraint1";
	if ($parentCheck == 0)
	{
		select -d $sourceParent[0];
	}
	$sourceHierarchy = `ls -sl`;
	$sourceSize = `size $sourceHierarchy`;
	
	select -hi $destinationParent[0];
	select -d "*Shape" "*Constraint1";
	select -d "*Shape" "*Constraint1";
	if ($parentCheck == 0)
	{
		select -d $destinationParent[0];
	}
	$destinationHierarchy = `ls -sl`;
	$destinationSize = `size $destinationHierarchy`;
		
	if (($sourceSize > 0) && ($destinationSize > 0))
	{
		int $crntHierarchyMod = 0;
		while (($crntHierarchyMod < $sourceSize) && ($crntHierarchyMod < $destinationSize))
		{
			$sourceT = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".translate")`;
			$sourceR = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".rotate")`;
			$sourceS = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".scale")`;
			
			$lockTX = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".tx")`;
			$lockTY = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".ty")`;
			$lockTZ = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".tz")`;
			$lockRX = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".rx")`;
			$lockRY = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".ry")`;
			$lockRZ = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".rz")`;
			$lockSX = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".sx")`;
			$lockSY = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".sy")`;
			$lockSZ = `getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".sz")`;
          		
			if ($lockTX == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".tx") $sourceT[0];}
			if ($lockTY == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".ty") $sourceT[1];}
			if ($lockTZ == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".tz") $sourceT[2];}
			
			if ($lockRX == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".rx") $sourceR[0];}
			if ($lockRY == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".ry") $sourceR[1];}
			if ($lockRZ == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".rz") $sourceR[2];}
          		
			if ($lockSX == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sx") $sourceS[0];}
			if ($lockSY == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sy") $sourceS[1];}
			if ($lockSZ == 0)
			{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sz") $sourceS[2];}
			$crntHierarchyMod++;
		}
	}
}
global proc RRM_TransferModTransforms()
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	$sourceParent = `ls -sl`;
	$destinationParent = `ls -sl`;
	$proxySize = `size $proxies`;
	string $crntProxy;
	
	int $RRM_TransferSelectionButton = `radioButtonGrp -q -select RRM_TransferSelectionButton`;

	if ($proxySize == 2)
	{
		//SELECTED
		if ($RRM_TransferSelectionButton == 1)
		{
			$sourceT = `getAttr ($proxies[0] + ".translate")`;
			$sourceR = `getAttr ($proxies[0] + ".rotate")`;
			$sourceS = `getAttr ($proxies[0] + ".scale")`;
			
			$lockTX = `getAttr -lock ($proxies[1] + ".tx")`;
			$lockTY = `getAttr -lock ($proxies[1] + ".ty")`;
			$lockTZ = `getAttr -lock ($proxies[1] + ".tz")`;
			$lockRX = `getAttr -lock ($proxies[1] + ".rx")`;
			$lockRY = `getAttr -lock ($proxies[1] + ".ry")`;
			$lockRZ = `getAttr -lock ($proxies[1] + ".rz")`;
			$lockSX = `getAttr -lock ($proxies[1] + ".sx")`;
			$lockSY = `getAttr -lock ($proxies[1] + ".sy")`;
			$lockSZ = `getAttr -lock ($proxies[1] + ".sz")`;

			if ($lockTX == 0)
			{setAttr ($proxies[1] + ".tx") $sourceT[0];}
			if ($lockTY == 0)
			{setAttr ($proxies[1] + ".ty") $sourceT[1];}
			if ($lockTZ == 0)
			{setAttr ($proxies[1] + ".tz") $sourceT[2];}
			
			if ($lockRX == 0)
			{setAttr ($proxies[1] + ".rx") $sourceR[0];}
			if ($lockRY == 0)
			{setAttr ($proxies[1] + ".ry") $sourceR[1];}
			if ($lockRZ == 0)
			{setAttr ($proxies[1] + ".rz") $sourceR[2];}

			if ($lockSX == 0)
			{setAttr ($proxies[1] + ".sx") $sourceS[0];}
			if ($lockSY == 0)
			{setAttr ($proxies[1] + ".sy") $sourceS[1];}
			if ($lockSZ == 0)
			{setAttr ($proxies[1] + ".sz") $sourceS[2];}
		}
		
		//BRANCH
		else if ($RRM_TransferSelectionButton == 2)
		{
			$sourceProxy = $proxies[0];
			$destinationProxy = $proxies[1];
			
			//GET SOURCE PARENT
			if (!`objExists ($sourceProxy + ".parent")`)
			{
				string $crntProxy;
				$crntInt = 0;
				while ((!`objExists ($crntProxy + ".parent")`) && ($crntInt < 103))
				{
					$parentCheck = `listRelatives -p $sourceProxy`;
					if (`objExists ($parentCheck[0] + ".parent")`)
					{
						$sourceParent = `ls -sl`;
					}
					
					$crntProxy = $parentCheck[0];
					$crntInt++;
				}
			}
			else
			{
				$sourceParent = `ls $sourceProxy`;
			}
			
			//GET DESTINATION PARENT
			if (!`objExists ($destinationProxy + ".parent")`)
			{
				string $crntProxy;
				$crntInt = 0;
				while ((!`objExists ($crntProxy + ".parent")`) && ($crntInt < 103))
				{
					$parentCheck = `listRelatives -p $destinationProxy`;
					if (`objExists ($parentCheck[0] + ".parent")`)
					{
						$destinationParent = `ls $destinationProxy`;
					}
					
					$crntProxy = $parentCheck[0];
					$crntInt++;
				}
			}
			else
			{
				$destinationParent = `ls $destinationProxy`;
			}
			$sourceModType = `getAttr ($sourceParent[0] + ".parent")`;
			$destinationModType = `getAttr ($destinationParent[0] + ".parent")`;
			
			//CHECK TO SEE IF THEY ARE THE SAME TYPE OF MODULE
			if ($sourceModType == $destinationModType)
			{
				select -hi $sourceParent[0];
				select -d "*Shape" "*Constraint1";
				$sourceHierarchy = `ls -sl`;
				$sourceSize = `size $sourceHierarchy`;
				
				select -hi $destinationParent[0];
				select -d "*Shape" "*Constraint1";
				$destinationHierarchy = `ls -sl`;
				$destinationSize = `size $destinationHierarchy`;

				//CHECK TO SEE IF SOURCE AND DESTINATION HAVE SAME NUMBER OF NODES				
				if ($sourceSize == $destinationSize)
				{
					select $sourceParent[0] $destinationParent[0];
					RRM_TransferModTransforms2;
				}
				else
				{
					string $returnVal_Generate = `confirmDialog
						-title "The Source And Destination Branches Have A Different Number Of Nodes."
						-message "The results may not transfer properly.\nProceed?"
						-button "OK" -button "Cancel"
						-defaultButton "OK"
						-cancelButton "Cancel"
						-icon "question"`;
					if ($returnVal_Generate == "OK") 
					{
						select $sourceParent[0] $destinationParent[0];
						RRM_TransferModTransforms2;
					}
				}
			}
			else
			{
				string $returnVal_Generate = `confirmDialog
					-title "The Modules Are Not Of The Same Type."
					-message "The results may not transfer properly.\nProceed?"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					select $sourceParent[0] $destinationParent[0];
					RRM_TransferModTransforms2;
				}
			}
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
			-title "Wrong Number Of Objects Seleted"
			-message "Select ONE target node followed by ONE destination node that you want to match to.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	select $originalSelection;
}

//SAVE/LOAD PROXY TRANSFORMS//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

global proc RRM_WritePathProxyTransforms()
{
	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		string $mayaFolder;
	
		fileBrowserDialog -mode 1
		-fileCommand ( "RRM_SaveProxyTransforms \"" + $mayaFolder + "\"" )
		-actionName "Save";
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to save the transforms from.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}   	
}


global proc RRM_SaveProxyTransforms(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;
		
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".core")`)
		    {
		        $proxies = `ls $proxies $crntProxy`;
		    }
		}
	
	for ($crntProxy in $proxies)
	{
		$lockTX = `getAttr -lock ($crntProxy + ".tx")`;
		$lockTY = `getAttr -lock ($crntProxy + ".ty")`;
		$lockTZ = `getAttr -lock ($crntProxy + ".tz")`;
		$lockRX = `getAttr -lock ($crntProxy + ".rx")`;
		$lockRY = `getAttr -lock ($crntProxy + ".ry")`;
		$lockRZ = `getAttr -lock ($crntProxy + ".rz")`;
		$lockSX = `getAttr -lock ($crntProxy + ".sx")`;
		$lockSY = `getAttr -lock ($crntProxy + ".sy")`;
		$lockSZ = `getAttr -lock ($crntProxy + ".sz")`;	
		
		fprint $fileID ("if (`objExists " + $crntProxy + "`) {");
		
		if ($lockTX == 0)
		{
			$crntTX = `getAttr ($crntProxy + ".tx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tx "+ $crntTX +"; ");
		}
		if ($lockTY == 0)
		{
			$crntTY = `getAttr ($crntProxy + ".ty")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ty "+ $crntTY +"; ");
		}
		if ($lockTZ == 0)
		{
			$crntTZ = `getAttr ($crntProxy + ".tz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tz "+ $crntTZ +"; ");
		}		

		if ($lockRX == 0)
		{
			$crntRX = `getAttr ($crntProxy + ".rx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rx "+ $crntRX +"; ");
		}
		if ($lockRY == 0)
		{
			$crntRY = `getAttr ($crntProxy + ".ry")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ry "+ $crntRY +"; ");
		}
		if ($lockRZ == 0)
		{
			$crntRZ = `getAttr ($crntProxy + ".rz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rz "+ $crntRZ +"; ");
		}		

		if ($lockSX == 0)
		{
			$crntSX = `getAttr ($crntProxy + ".sx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sx "+ $crntSX +"; ");
		}
		if ($lockSY == 0)
		{
			$crntSY = `getAttr ($crntProxy + ".sy")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sy "+ $crntSY +"; ");
		}
		if ($lockSZ == 0)
		{
			$crntSZ = `getAttr ($crntProxy + ".sz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sz "+ $crntSZ +"; ");
		}
		fprint $fileID "}\n";

	}
	fclose $fileID;
	select $originalSelection;		
}


global proc RRM_ReadPathProxyTransform()
{
 	string $mayaFolder2;
	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		fileBrowserDialog -mode 0
		-fileCommand ( "RRM_LoadModProxyTransforms \"" + $mayaFolder2 + "\"" )
		-actionName "Load";
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to load the transforms to.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
}

global proc RRM_LoadModProxyTransforms(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING POSE FROM "+$result2+"...\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}

//SAVE/LOAD PROXY SETUP///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

global proc RRM_WritePathProxySetup()
{
	string $mayaFolder;
	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		fileBrowserDialog -mode 1
		-fileCommand ( "RRM_SaveProxySetup \"" + $mayaFolder + "\"" )
		-actionName "Save";
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to save to a setup file.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}    
}


global proc RRM_SaveProxySetup(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;
		
	$originalSelection = `ls -sl`;
	string $proxies[];
	string $modules[];
	
	
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl`;
		
		//FIND MODULE NODES
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".core")`)
		    {
		        $proxies = `ls $proxies $crntProxy`;
		    }
		}
		
		//FIND PROXIES
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".top")`)
		    {
		        $modules = `ls $modules $crntProxy`;
		    }
		}
		
		//CREATE MAIN AND ROOT PROXIES
		fprint $fileID "RRM_CreateProxyMainProxy(0);\n";
		
		//CREATE MODULES
		for ($each in $modules)
		{
			//CHECK TYPE OF MODULE, MOD NAME, ATTACH NODE
			string $modType = `getAttr ($each + ".top")`;
			string $modName = `getAttr ($each + ".core")`;
			string $attachNode = `getAttr ($each + ".parent")`;
			$attachNode = ("RRM_" + $attachNode);
			int $mirror = 0;
			int $single;
			if (`objExists ($each + ".pair")`)
			{
				$mirror = 1;
				if ($modType == "arm"||$modType == "leg")
				{
					$mirror = 2;
				}
			}
			else if ($modType == "arm")
			{
				string $single = `getAttr ($each + ".single")`;
				if ($single == "left")
				{
					$mirror = 1;
				}
				if ($single == "right")
				{
					$mirror = 3;
				}
			}
			else if ($modType == "leg")
			{
				$mirror = 1;
			}
			
			
			//DEFINE CUSTOM ATTRIBUTES OF EACH MODULE
			//SPLINE
			int $splineNum;
			//ARM/LEG
			int $upperNum;
			int $lowerNum;
			int $elbowNum;
			int $elbowJoints;
			int $kneeNum;
			int $kneeJoints;
			//FK CHAIN
			int $chainNum;
			int $jointNum;
			int $direction;
			//HEAD
			int $jaw;
			//LOOKAT
			int $eyeNum;

			//SELECT
			fprint $fileID ("select " + $attachNode + ";\n");
			
			if ($modType == "spline")
			{
				$splineNum = `getAttr ($each + ".jointsNum")`;
				fprint $fileID ("RRM_CreateProxySpline(\"" + $modName + "\"," + $splineNum + "," + $mirror + ");\n");
			}
			if ($modType == "arm")
			{
				$upperNum = `getAttr ($each + ".upperArmNum")`;
				$lowerNum = `getAttr ($each + ".lowerArmNum")`;
				$elbowNum = `getAttr ($each + ".elbowNum")`;
				$elbowJoints = `getAttr ($each + ".elbowJoints")`;
				fprint $fileID ("RRM_CreateProxyArm(\"" + $modName + "\"," + $upperNum + "," + $lowerNum + "," + $elbowNum + "," + $elbowJoints + "," + $mirror + ");\n");
			}
			if ($modType == "leg")
			{
				$upperNum = `getAttr ($each + ".upperLegNum")`;
				$lowerNum = `getAttr ($each + ".lowerLegNum")`;
				$kneeNum = `getAttr ($each + ".kneeNum")`;
				$kneeJoints = `getAttr ($each + ".kneeJoints")`;
				fprint $fileID ("RRM_CreateProxyLeg(\"" + $modName + "\"," + $upperNum + "," + $lowerNum + "," + $kneeNum + "," + $kneeJoints + "," + $mirror + ");\n");
			}
			if ($modType == "fkChain")
			{
				$chainNum = `getAttr ($each + ".chainsNum")`;
				$jointNum = `getAttr ($each + ".jointsNum")`;
				$direction = `getAttr ($each + ".direction")`;
				$direction2 = `getAttr ($each + ".direction")`;
				if ($direction > 3)
				{
					$direction2 = ($direction2 - 3);
					$direction = 0;
				}
				else
				{
					$direction2 = 0;
				}
				fprint $fileID ("RRM_CreateProxyFKChain(\"" + $modName + "\"," + $chainNum + "," + $jointNum + "," + $direction + "," + $direction2 + "," + $mirror + ");\n");
			}
			if ($modType == "head")
			{
				$jaw = `getAttr ($each + ".jaw")`;
				fprint $fileID ("RRM_CreateProxyHead(\"" + $modName + "\"," + $jaw + "," + $mirror + ");\n");
			}
			if ($modType == "lookAt")
			{
				$eyeNum = `getAttr ($each + ".eyeNum")`;
				$direction = `getAttr ($each + ".direction")`;
				$direction2 = `getAttr ($each + ".direction")`;
				if ($direction > 3)
				{
					$direction2 = ($direction2 - 3);
					$direction = 0;
				}
				else
				{
					$direction2 = 0;
				}
				fprint $fileID ("RRM_CreateProxyLookAt(\"" + $modName + "\"," + $eyeNum + "," + $direction + "," + $direction2 + "," + $mirror + ");\n");
			}
			if ($modType == "auxiliary")
			{
				fprint $fileID ("RRM_CreateProxyAuxiliary(\"" + $modName + "\"," + $mirror + ");\n");
			}
		}
			
				
	
	for ($crntProxy in $proxies)
	{
		$lockTX = `getAttr -lock ($crntProxy + ".tx")`;
		$lockTY = `getAttr -lock ($crntProxy + ".ty")`;
		$lockTZ = `getAttr -lock ($crntProxy + ".tz")`;
		$lockRX = `getAttr -lock ($crntProxy + ".rx")`;
		$lockRY = `getAttr -lock ($crntProxy + ".ry")`;
		$lockRZ = `getAttr -lock ($crntProxy + ".rz")`;
		$lockSX = `getAttr -lock ($crntProxy + ".sx")`;
		$lockSY = `getAttr -lock ($crntProxy + ".sy")`;
		$lockSZ = `getAttr -lock ($crntProxy + ".sz")`;		
		
		fprint $fileID ("if (`objExists " + $crntProxy + "`) {");
		
		//SET PINNING
		if (`objExists ($crntProxy + ".pinned")`)
		{
			$pinned = `getAttr ($crntProxy + ".pinned")`;
			if ($pinned == 1)
			{
				fprint $fileID ("select " + $crntProxy + "; ");
				fprint $fileID ("RRM_PinProxies(1, 0); ");
			}
		}
		
		if ($lockTX == 0)
		{
			$crntTX = `getAttr ($crntProxy + ".tx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tx "+ $crntTX +"; ");
		}
		if ($lockTY == 0)
		{
			$crntTY = `getAttr ($crntProxy + ".ty")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ty "+ $crntTY +"; ");
		}
		if ($lockTZ == 0)
		{
			$crntTZ = `getAttr ($crntProxy + ".tz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tz "+ $crntTZ +"; ");
		}		

		if ($lockRX == 0)
		{
			$crntRX = `getAttr ($crntProxy + ".rx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rx "+ $crntRX +"; ");
		}
		if ($lockRY == 0)
		{
			$crntRY = `getAttr ($crntProxy + ".ry")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ry "+ $crntRY +"; ");
		}
		if ($lockRZ == 0)
		{
			$crntRZ = `getAttr ($crntProxy + ".rz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rz "+ $crntRZ +"; ");
		}		

		if ($lockSX == 0)
		{
			$crntSX = `getAttr ($crntProxy + ".sx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sx "+ $crntSX +"; ");
		}
		if ($lockSY == 0)
		{
			$crntSY = `getAttr ($crntProxy + ".sy")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sy "+ $crntSY +"; ");
		}
		if ($lockSZ == 0)
		{
			$crntSZ = `getAttr ($crntProxy + ".sz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sz "+ $crntSZ +"; ");
		}
		fprint $fileID "}\n";

	}
	fprint $fileID "select -cl;";
	fclose $fileID;
	select $originalSelection;		
}


global proc RRM_ReadPathProxySetup()
{
	string $mayaFolder2;
	if (!`objExists "RRM_MAIN"` || !`objExists "RRM_ROOT"`)
	{
		fileBrowserDialog -mode 0
		-fileCommand ( "RRM_LoadModProxySetup \"" + $mayaFolder2 + "\"" )
		-actionName "Load";
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "Proxy Rig Already Exists"
			-message "You must first delete the existing proxy rig to load a new one. Do you wish to delete the proxy rig and then load a proxy?.\n"
			-button "Yes"
			-button "Cancel"
			-defaultButton "Cancel"
			-cancelButton "Cancel"
			-icon "critical"`;
			
			if ($returnVal_Generate == "Yes")
			{
				RRM_DeleteProxyRig;
				fileBrowserDialog -mode 0
				-fileCommand ( "RRM_LoadModProxySetup \"" + $mayaFolder2 + "\"" )
				-actionName "Load";
			}
	}   
}

global proc RRM_LoadModProxySetup(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING POSE FROM "+$result2+"...\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE FINAL RIG//////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_ColorControls(string $modName)
{
	//LEFT
	//MAIN BLUE IS 6
	//SECONDARY BLUE IS 18
	
	//RIGHT
	//MAIN RED IS 13
	//SECONDARY RED IS 21
	
	//CENTER
	//MAIN GREEN IS 14
	//SECONDARY GREEN IS 27
	
	select -hi ($modName + "_MAINCtrl");
	
	$controls= `ls -sl -type "nurbsCurve"`;
	string $crnt;
	for ($crnt in $controls)
	{
		$crntParent = `listRelatives -parent $crnt`;
		string $parentNode = $crntParent[0];
		
		if (`objExists ($parentNode + ".modRigName")`)
		{
			if (!`objExists ($parentNode + ".leftControl")` && !`objExists ($parentNode + ".rightControl")`)
			{
				if (!`gmatch $parentNode ($modName + "_*Curve*Ctrl")`)
				{//MAIN NON-MIRRORED CONTROLS
					setAttr ($crnt + ".overrideEnabled") 1;
					setAttr ($crnt + ".overrideColor") 14;
				}
				else
				{//MAIN NON-MIRRORED CURVE CONTROLS
					setAttr ($crnt + ".overrideEnabled") 1;
					setAttr ($crnt + ".overrideColor") 27;
				}
			}
			else
			{//MIRRORED CONTROLS
				if (`objExists ($parentNode + ".rightControl")`)
				{//RIGHT CONTROLS
					if (!`gmatch $parentNode ($modName + "_*Curve*Ctrl")`)
					{//MAIN NON-MIRRORED CONTROLS
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 6;
					}
					else
					{
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 18;
					}					
				}
				else if (`objExists ($parentNode + ".leftControl")`)
				{//LEFT CONTROLS
					if (!`gmatch $parentNode ($modName + "_*Curve*Ctrl")`)
					{//MAIN NON-MIRRORED CONTROLS
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 13;
					}
					else
					{
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 21;
					}					
				}
			}
		}
	}
}


//ADD CORE NAME
global proc RRM_CoreName(string $modControls[])
{
	for ($crntModControl in $modControls)
	{
		addAttr -ln "modCoreName"  -dt "string" $crntModControl;
		setAttr -e-keyable true ($crntModControl + ".modCoreName");
	}
}

//ADD CONTROL NAME
global proc RRM_ControlName(string $modName, string $modControls[])
{
	for ($crntModControl in $modControls)
	{
		$modNameSize = `size($modName)`;
		
		$crntModControlSize = `size($crntModControl)`;
		
		string $controlName = endString($crntModControl, ($crntModControlSize - $modNameSize));
		
		addAttr -ln "modControlName" -dt "string" $crntModControl;
		setAttr -e-keyable true ($crntModControl + ".modControlName");
		setAttr -type "string" ($crntModControl + ".modControlName") $controlName;
		setAttr -lock true -keyable false -channelBox false ($crntModControl + ".modControlName");
	}
}

//SET UP ORIENTATION TO PARENT NODE
global proc RRM_ParentOrient(string $modCore, string $modName, string $modAttachNode, string $parentOrient)
{
	if ($modAttachNode != "ROOT")
	{
		addAttr -ln "parentOrient" -at double -min 0 -max 1 -dv 1 $parentOrient;
		setAttr -e-keyable true ($parentOrient + ".parentOrient");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_orientConstraint1." + $modName + "_" + $modAttachNode + "JntW1");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_orientConstraint1." + $modName + "_" + $modAttachNode + "JntW1");
	}
	else
	{
		addAttr -ln "ROOT_Parent"  -at "enum" -en "ROOT:ROOTSecondary:"  $parentOrient;
		setAttr -e-keyable true ($parentOrient + ".ROOT_Parent");
		addAttr -ln "parentOrient" -at double  -min 0 -max 1 -dv 1 $parentOrient;
		setAttr -e-keyable true ( $parentOrient + ".parentOrient");		
        
		//CREATE NODES FOR BLENDING BETWEEN THE TWO ROOT CHOICES AND MAIN CONTROL
		
		//MODULE GROUP
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ParentMD");
		shadingNode -asUtility reverse -n ($modCore + "_ParentReverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ParentMD.input2X");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ParentReverse.inputX");
		connectAttr -force ($modCore + "_ParentReverse.outputX") ($modCore + "_ParentMD.input2Y");
		setAttr ($modCore + "_ParentMD.input1X") 1;
		setAttr ($modCore + "_ParentMD.input1Y") 1;
		
		//SECOND MULTIPLY DIVIDE TO ZERO OUT BOTH ROOT CHOICES WHEN PARENT ORIENT SET TO ZERO
		shadingNode -asUtility multiplyDivide -n ($modCore + "_Parent2MD");
		connectAttr -force ($modCore + "_ParentMD.outputX") ($modCore + "_Parent2MD.input1X");
		connectAttr -force ($modCore + "_ParentMD.outputY") ($modCore + "_Parent2MD.input1Y");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_Parent2MD.input2X");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_Parent2MD.input2Y");
		
		//CONNECT MULTIPLY/DIVIDE TO ORIENT CONSTRAINT
		connectAttr -force ($modCore + "_Parent2MD.outputY") ($modCore + "_orientConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -force ($modCore + "_Parent2MD.outputX") ($modCore + "_orientConstraint1." + $modName + "_ROOTJntW2");
		
		connectAttr -force ($modCore + "_Parent2MD.outputY") ($modCore + "_pointConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -force ($modCore + "_Parent2MD.outputX") ($modCore + "_pointConstraint1." + $modName + "_ROOTJntW0");
				
		//MODULE SCALEG
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ScaleGrp_ParentMD");
		shadingNode -asUtility reverse -n ($modCore + "_ScaleGrp_ParentReverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_ParentMD.input2X");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_ParentReverse.inputX");
		connectAttr -force ($modCore + "_ScaleGrp_ParentReverse.outputX") ($modCore + "_ScaleGrp_ParentMD.input2Y");
		setAttr ($modCore + "_ScaleGrp_ParentMD.input1X") 1;
		setAttr ($modCore + "_ScaleGrp_ParentMD.input1Y") 1;
		
		//SECOND MULTIPLY DIVIDE TO ZERO OUT BOTH ROOT CHOICES WHEN PARENT ORIENT SET TO ZERO
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ScaleGrp_Parent2MD");
		connectAttr -force ($modCore + "_ScaleGrp_ParentMD.outputX") ($modCore + "_ScaleGrp_Parent2MD.input1X");
		connectAttr -force ($modCore + "_ScaleGrp_ParentMD.outputY") ($modCore + "_ScaleGrp_Parent2MD.input1Y");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_Parent2MD.input2X");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_Parent2MD.input2Y");
		
		//CONNECT MULTIPLY/DIVIDE TO ORIENT CONSTRAINT
		connectAttr -force ($modCore + "_ScaleGrp_Parent2MD.outputY") ($modCore + "_ScaleGrp_orientConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -force ($modCore + "_ScaleGrp_Parent2MD.outputX") ($modCore + "_ScaleGrp_orientConstraint1." + $modName + "_ROOTJntW2");
	    
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_parentConstraint1." + $modName + "_ROOTJntW0");
		
		shadingNode -asUtility reverse -n ($modCore + "_ScaleGrp_Parent2Reverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_Parent2Reverse.inputX");

		connectAttr -force ($modCore + "_ScaleGrp_Parent2Reverse.outputX") ($modCore + "_ScaleGrp_parentConstraint1." + $modName + "_ROOTCtrlW1");
		
		//CHECK IF LEG, AND CHANGE TO ROOT Secondary
		if (`objExists ($modCore + "_FootIKCtrl")`)
		{
			setAttr ($parentOrient + ".ROOT_Parent") 1;
		}
	}
	//MODULE
	shadingNode -asUtility reverse -n ($modCore + "_ParentOrientReverse");
	connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ParentOrientReverse.inputX");
	connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_orientConstraint1." + $modCore + "_OffsetLctrW0");
	connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_ScaleGrp_orientConstraint1." + $modCore + "_OffsetLctrW0");
	if (`objExists ($modCore + "_pointConstraint1." + $modName + "_ROOTLocLctrW2")`)
	{
		connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_pointConstraint1." + $modName + "_ROOTLocLctrW2");
	}	
}


////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE ROOT MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigRoot(string $modName)
{
	//CREATE TOP GROUP
	select -cl;
	group -em -n $modName;
	//CREATE MAIN CONTROLLER///////////////////////////////////////////////////////////////
	circle -n ($modName + "_MAINCtrl") -nr 0 1 0 -sw 360 -r 8 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
	curve -n ($modName + "_Arrow1") -d 1 -p 3 0 8 -p 3 0 9 -p 5 0 9 -p 0 0 12 -p -5 0 9 -p -3 0 9 -p -3 0 8 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
	pickWalk -d down;
	rename ($modName + "_Arrow1Shape");
	circle -n ($modName + "_Outer1") -nr 0 1 0 -sw 48.9 -r 8.545 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
	rotate -r 0 110.55 0 ($modName + "_Outer1");
	duplicate -rr ($modName + "_Arrow1") ($modName + "_Outer1");
	rotate -r 0 90 0 ($modName + "_Arrow2") ($modName + "_Outer2");
	duplicate -rr ($modName + "_Arrow1") ($modName + "_Outer1");
	rotate -r 0 180 0 ($modName + "_Arrow3") ($modName + "_Outer3");
	duplicate -rr ($modName + "_Arrow1") ($modName + "_Outer1");
	rotate -r 0 270 0 ($modName + "_Arrow4") ($modName + "_Outer4");
	makeIdentity -apply true -r 1 ($modName + "_MAINCtrl") ($modName + "_Arrow1") ($modName + "_Outer1") ($modName + "_Arrow2") ($modName + "_Outer2") ($modName + "_Arrow3") ($modName + "_Outer3") ($modName + "_Arrow4") ($modName + "_Outer4") ;
	parent -r -s ($modName + "_Arrow1Shape") ($modName + "_Outer1Shape") ($modName + "_Arrow2Shape") ($modName + "_Outer2Shape") ($modName + "_Arrow3Shape") ($modName + "_Outer3Shape") ($modName + "_Arrow4Shape") ($modName + "_Outer4Shape") ($modName + "_MAINCtrl");
	delete ($modName + "_Arrow1") ($modName + "_Outer1") ($modName + "_Arrow2") ($modName + "_Outer2") ($modName + "_Arrow3") ($modName + "_Outer3") ($modName + "_Arrow4") ($modName + "_Outer4") ;
	move -r 0 0 2 ($modName + "_Arrow1Shape.cv[3]") ;
	
	//ADD RRM TO THE MAIN CONTROL
	curve -n ($modName + "R1_OuterCurve") -d 3 -p -0.407227 0 -0.429492 -p -0.263487 0 -0.429492 -p 0.0239912 0 -0.432182 -p 0.153059 0 -0.418734 -p 0.253227 0 -0.330969 -p 0.296535 0 -0.194139 -p 0.237588 0 -0.0195534 -p 0.0868775 0 0.0315034 -p 0.040764 0 0.0378381 -p 0.0375 0 0.0386719 -p 0.0382526 0 0.0396925 -p 0.0951021 0 0.0649485 -p 0.176419 0 0.152211 -p 0.284981 0 0.330214 -p 0.348426 0 0.427287 -p 0.349805 0 0.429492 -p 0.345946 0 0.429492 -p 0.276161 0 0.429492 -p 0.209868 0 0.429492 -p 0.206836 0 0.429492 -p 0.205116 0 0.426765 -p 0.154922 0 0.348158 -p 0.10053 0 0.260202 -p 0.0030441 0 0.11572 -p -0.0459097 0 0.0714475 -p -0.0972157 0 0.0491625 -p -0.149125 0 0.0478205 -p -0.274914 0 0.0480469 -p -0.288614 0 0.0480469 -p -0.293555 0 0.0480469 -p -0.293555 0 0.0510741 -p -0.293555 0 0.125268 -p -0.293493 0 0.202405 -p -0.293493 0 0.398616 -p -0.293555 0 0.428465 -p -0.293555 0 0.429492 -p -0.294535 0 0.429492 -p -0.328353 0 0.429492 -p -0.378561 0 0.429492 -p -0.405499 0 0.429492 -p -0.407227 0 0.429492 -p -0.407227 0 0.428253 -p -0.407227 0 0.405684 -p -0.407227 0 0.328387 -p -0.407227 0 -0.0915302 -p -0.407227 0 -0.429492 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 37 -k 38 -k 39 -k 40 -k 41 -k 42 -k 43 -k 43 -k 43 ;
	pickWalk -d down;
	rename ($modName + "R1_OuterCurveShape");
	curve -n ($modName + "R1_InnerCurve") -d 3 -p -0.293555 0 -0.33457 -p -0.257406 0 -0.33457 -p -0.0889505 0 -0.333847 -p 0.0486942 0 -0.336975 -p 0.14017 0 -0.292901 -p 0.171323 0 -0.194613 -p 0.146198 0 -0.11598 -p 0.0827139 0 -0.0601229 -p -0.0184461 0 -0.0494054 -p -0.159798 0 -0.0503906 -p -0.290636 0 -0.0503906 -p -0.293555 0 -0.0503906 -p -0.293555 0 -0.0540591 -p -0.293555 0 -0.119074 -p -0.293555 0 -0.33457 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 12 -k 12 ;
	pickWalk -d down;
	rename ($modName + "R1_InnerCurveShape");
	curve -n ($modName + "M_Curve") -d 1 -p 0.454102 0 0.429492 -p 0.454102 0 -0.429492 -p 0.625195 0 -0.429492 -p 0.869531 0 0.305859 -p 1.120898 0 -0.429492 -p 1.273828 0 -0.429492 -p 1.273828 0 0.429492 -p 1.164258 0 0.429492 -p 1.164258 0 -0.289453 -p 0.914648 0 0.429492 -p 0.812109 0 0.429492 -p 0.563672 0 -0.301758 -p 0.563672 0 0.429492 -p 0.454102 0 0.429492 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 ;
	pickWalk -d down;
	rename ($modName + "M_CurveShape");
	duplicate -n ($modName + "R2_OuterCurve") ($modName + "R1_OuterCurve");
	duplicate -n ($modName + "R2_InnerCurve") ($modName + "R1_InnerCurve");
	move -r -os -wd -1.5 0 0 ($modName + "R2_InnerCurve") ($modName + "R2_OuterCurve");
	
	scale -r 1.75 1.75 1.75 ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");
	move -r -ws 0 0 10.4 ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");
	makeIdentity -apply true -t 1 -r 1 -s 1 ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");

	select ($modName + "R1_OuterCurveShape") ($modName + "R1_InnerCurveShape") ($modName + "R2_OuterCurveShape") ($modName + "R2_InnerCurveShape") ($modName + "M_CurveShape");
	$RRM_Curves = `ls -sl -type "nurbsCurve"`;
	for ($each in $RRM_Curves)
	{
		//rename $each ($modName + "RRM_CurveShape" + $num);
		parent -r -s $each ($modName + "_MAINCtrl");
		setAttr ($each + ".overrideEnabled") 1;
		setAttr ($each + ".overrideColor") 14;
	}
	delete ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");

	$mainScale = `getAttr RRM_MAIN.scale`;
	setAttr (($modName + "_MAINCtrl.scale"), $mainScale[0], $mainScale[1], $mainScale[2]);
	makeIdentity -apply true -s 1 ($modName + "_MAINCtrl");
	
	addAttr -ln "masterScale"  -at double  ($modName + "_MAINCtrl");
	setAttr -e-keyable true ($modName + "_MAINCtrl.masterScale");
	setAttr ($modName + "_MAINCtrl.masterScale") $mainScale[1];
	setAttr -lock true -keyable false -channelBox false ($modName + "_MAINCtrl.masterScale");
	
	addAttr -ln "COG_Ctrl_visibility"  -at bool ($modName + "_MAINCtrl");
	setAttr -e-keyable true ($modName + "_MAINCtrl.COG_Ctrl_visibility");
	
	//////////////////////////////////LOCK & HIDE//////////////////////////////////
	setAttr -l 1 -k 0 ($modName + "_MAINCtrl.v");
	connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modName + "_MAINCtrl.scaleX");
	connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modName + "_MAINCtrl.scaleZ"); 
	setAttr -l 1 -k 0 ($modName + "_MAINCtrl.scaleX");
	setAttr -l 1 -k 0 ($modName + "_MAINCtrl.scaleZ");
	

	//GET ROOT POSITION
	$rootPos = `xform -q -ws -rp RRM_ROOT`;
	select -cl;
	joint -n ($modName + "_ROOTJnt");
	move -a $rootPos[0] $rootPos[1] $rootPos[2] ($modName + "_ROOTJnt");

	//PARENT CONTROL
	circle -n ($modName + "_ROOTParentCtrl") -c 0 0 0 -nr 0 1 0 -sw 315 -r 1.2 -d 3 -ut 0 -tol 0 -s 8; objectMoveCommand;
	rotate -r 0 -157.5 0 ($modName + "_ROOTParentCtrl");
	makeIdentity -apply true -r 1 ($modName + "_ROOTParentCtrl");
    curve -n ($modName + "_ROOTParentCtrl1") -d 1 -p 0.459248 0 1.108679 -p 0.459248 0 1.232295 -p 0 0 1.454964 -p -0.459248 0 1.232295 -p -0.459248 0 1.108679 -k 0 -k 1 -k 2 -k 3 -k 4 ;
	pickWalk -d down;
	rename ($modName + "_ROOTParentCtrl1Shape");	
	parent -r -s ($modName + "_ROOTParentCtrl1Shape") ($modName + "_ROOTParentCtrl1Shape") ($modName + "_ROOTParentCtrl");
	delete ($modName + "_ROOTParentCtrl1");
	scale -r 1.25 1.25 1.25 ($modName + "_ROOTParentCtrl");
	makeIdentity -apply true -s 1 ($modName + "_ROOTParentCtrl");

	//CREATE COG_Ctrl//////////////////////////////////////////////////////
	circle -n ($modName + "_OuterCOG_Ctrl1") -r 12 -nr 0 1 0 -sw 18;
	circle -n ($modName + "_InnerCOG_Ctrl1") -r 11 -nr 0 1 0 -sw 18;
	rotate -r -os 0 -18 0 ($modName + "_InnerCOG_Ctrl1");
	curve -n ($modName + "_LeftConnectorCOG_Ctrl1") -d 1 -p 0 0 -12 -p 0 0 -11 -k 0 -k 1 ;
	pickWalk -d down;
	rename ($modName + "_LeftConnectorCOG_Ctrl1Shape");
	duplicate -n ($modName + "_RightConnectorCOG_Ctrl1") ($modName + "_LeftConnectorCOG_Ctrl1");
	rotate  -r -os 0 -18 0 ($modName + "_LeftConnectorCOG_Ctrl1");
	
	select ($modName + "_OuterCOG_Ctrl1") ($modName + "_InnerCOG_Ctrl1") ($modName + "_LeftConnectorCOG_Ctrl1") ($modName + "_RightConnectorCOG_Ctrl1");
	
	duplicate -rr; rotate -r 0 36 0; for ($i=1; $i<9; ++$i) duplicate -rr -st;
	select ($modName + "_*COG_Ctrl?") ($modName + "_*COG_Ctrl??");
	makeIdentity -apply true -t 1 -r 1 -s 1;
	select -d ($modName + "_OuterCOG_Ctrl1");
	$transforms = `ls -sl`;
	pickWalk -d down;
	$shapes = `ls -sl`;
	parent -r -s $shapes ($modName + "_OuterCOG_Ctrl1");
	delete $transforms;
	rename ($modName + "_OuterCOG_Ctrl1") ($modName + "_COG_Ctrl");
	
	scale -r .7 .7 .7 ($modName + "_COG_Ctrl");
	rotate -r 0 -9 0 ($modName + "_COG_Ctrl");
	makeIdentity -apply true -r 1 -s 1 ($modName + "_COG_Ctrl");
	delete `scaleConstraint RRM_COG ($modName + "_COG_Ctrl")`;
	makeIdentity -apply true -s 1 ($modName + "_COG_Ctrl");

	group -n ($modName + "_COG_CtrlGrp") ($modName + "_COG_Ctrl");
	delete `parentConstraint RRM_COG ($modName + "_COG_CtrlGrp")`;

	parent ($modName + "_COG_CtrlGrp") ($modName + "_MAINCtrl");
	
	connectAttr -f ($modName + "_MAINCtrl.COG_Ctrl_visibility") ($modName + "_COG_CtrlGrp.v");
	
	
	//ADD CORE NAME
	addAttr -ln "isCOG_Ctrl"  -dt "string" ($modName + "_COG_Ctrl");
	setAttr -e-keyable true ($modName + "_COG_Ctrl.isCOG_Ctrl");
	setAttr -e-lock true ($modName + "_COG_Ctrl.isCOG_Ctrl");
	
	setAttr ($modName + "_COG_Ctrl.overrideEnabled") 1;
	setAttr ($modName + "_COG_Ctrl.overrideColor") 19;
	


	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_Ctrl.sx");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_Ctrl.sy");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_Ctrl.sz");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_Ctrl.v");
	
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.tx");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.ty");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.tz");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.rx");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.ry");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.rz");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.sx");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.sy");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.sz");
	setAttr -lock true -keyable false -channelBox false ($modName + "_COG_CtrlGrp.v");
	
	//CREATE MOVEABLE PIVOT CONTROL
	circle -n ($modName + "_PivotCtrl_Outer1") -c 0 0 0 -nr 0 1 0 -sw 10 -r .25 -d 3 -ut 0 -tol 0 -s 8;
	
	circle -n ($modName + "_PivotCtrl_Inner1") -c 0 0 0 -nr 0 1 0 -sw 10 -r 2 -d 3 -ut 0 -tol 0 -s 8;
	
	curve -n ($modName + "_PivotCtrl_leftLine1") -d 1 -p 0 0 -0.25 -p 0 0 -2 -k 0 -k 1 ;
	pickWalk -d down;
	rename ($modName + "_PivotCtrl_leftLine1Shape");
	curve -n ($modName + "_PivotCtrl_rightLine1") -d 1 -p -0.043412 0 -0.246202 -p -0.347296 0 -1.969616 -k 0 -k 1 ;
	pickWalk -d down;
	rename ($modName + "_PivotCtrl_RightLine1Shape");
	
	parent -r -s ($modName + "_PivotCtrl_Inner1Shape") ($modName + "_PivotCtrl_leftLine1Shape") ($modName + "_PivotCtrl_RightLine1Shape") ($modName + "_PivotCtrl_Outer1");
	delete ($modName + "_PivotCtrl_Inner1") ($modName + "_PivotCtrl_leftLine1") ($modName + "_PivotCtrl_rightLine1");
	
	rotate -r 0 -5 0 ($modName + "_PivotCtrl_Outer1");
	
	
	duplicate -rr -n ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer1");
	rotate -r 0 -90 0 ($modName + "_PivotCtrl_Outer2");
	
	duplicate -rr -n ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer1");
	rotate -r 0 -180 0 ($modName + "_PivotCtrl_Outer3");
	
	duplicate -rr -n ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer1");
	rotate -r 0 -270 0 ($modName + "_PivotCtrl_Outer4");
	
	duplicate ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4");
	rotate -r 0 0 90 ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8");
	
	duplicate ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4");
	rotate -r 90 0 0 ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12");
	
	curve -n ($modName + "_PivotCtrl") -d 1 -p 0.25 0 0 -p -0.25 0 0 -k 0 -k 1 ;
	pickWalk -d down;
	rename ($modName + "_PivotCtrlShape");
	curve -n ($modName + "_PivotCtrl_Line1") -d 1 -p 0 0.25 0 -p 0 -0.25 0 -k 0 -k 1 ;
	pickWalk -d down;
	rename ($modName + "_PivotCtrl_Line1Shape");
	curve -n ($modName + "_PivotCtrl_Line2") -d 1 -p 0 0 0.25 -p 0 0 -0.25 -k 0 -k 1 ;
	pickWalk -d down;
	rename ($modName + "_PivotCtrl_Line2Shape");
	
	makeIdentity -apply true -r 1 ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8") ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12");
	$shapes = `listRelatives -f -c -type "nurbsCurve" ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8") ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12") ($modName + "_PivotCtrl_Line1") ($modName + "_PivotCtrl_Line2") `;
	for ($each in $shapes)
	{
		parent -r -s $each ($modName + "_PivotCtrl");
	}
	delete ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8") ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12") ($modName + "_PivotCtrl_Line1") ($modName + "_PivotCtrl_Line2");
	group -n ($modName + "_PivotCtrlGrp");
	delete `parentConstraint RRM_ROOT ($modName + "_PivotCtrlGrp")`;
	
	setAttr (($modName + "_PivotCtrl.scale"), $mainScale[0], $mainScale[1], $mainScale[2]);
	makeIdentity -apply true -s 1 ($modName + "_PivotCtrl");
	
	parentConstraint -mo ($modName + "_COG_Ctrl") ($modName + "_PivotCtrlGrp");
	parent ($modName + "_PivotCtrlGrp") ($modName + "_MAINCtrl");

	
	//CREATE ROOT CONTROL//////////////////////////////////////////////////////
	circle -n ($modName + "_ROOTCtrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 1.15 -d 3 -ut 0 -tol 0 -s 8; objectMoveCommand;
	circle -n ($modName + "_ROOTCtrl1") -c 0 0 0 -nr 0 1 0 -sw 315 -r 1.2 -d 3 -ut 0 -tol 0 -s 8; objectMoveCommand;
	rotate -r 0 -157.5 0 ($modName + "_ROOTCtrl1");
	makeIdentity -apply true -r 1 ($modName + "_ROOTCtrl1");
    curve -n ($modName + "_ROOTCtrl2") -d 1 -p 0.459248 0 1.108679 -p 0.459248 0 1.232295 -p 0 0 1.454964 -p -0.459248 0 1.232295 -p -0.459248 0 1.108679 -k 0 -k 1 -k 2 -k 3 -k 4 ;
	pickWalk -d down;
	rename ($modName + "_ROOTCtrl2Shape");	
	parent -r -s ($modName + "_ROOTCtrl1Shape") ($modName + "_ROOTCtrl2Shape") ($modName + "_ROOTCtrl");
	delete ($modName + "_ROOTCtrl1") ($modName + "_ROOTCtrl2");
	
	
	//SECONDARY CONTROL
	circle -n ($modName + "_ROOTSecondaryCtrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.8 -d 3 -ut 0 -tol 0 -s 8; objectMoveCommand;
	curve -n ($modName + "_ROOTSecondaryCtrl2") -d 1 -p 0.448913 0 0.659205 -p 0.457839 0 0.707653 -p 0.43562 0 0.726309 -p 0.389727 0 0.761461 -p 0.317127 0 0.807243 -p 0.242199 0 0.852344 -p 0.165051 0 0.890957 -p 0.0916126 0 0.922558 -p 0.0354615 0 0.944185 -p 0 0 0.956437 -p 0 0 0.800148 -p 0 0 0.956437 -p -0.0354615 0 0.944185 -p -0.0916126 0 0.922558 -p -0.165051 0 0.890957 -p -0.242199 0 0.852344 -p -0.317127 0 0.807243 -p -0.389727 0 0.761461 -p -0.43562 0 0.726309 -p -0.457839 0 0.707653 -p -0.448913 0 0.659205 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 ;
	pickWalk -d down;
	rename ($modName + "_ROOTSecondaryCtrl2Shape");
	curve -n ($modName + "_ROOTSecondaryCtrl3") -d 1 -p 0.793238 0 -0.0839132 -p 0.715647 0 0 -p 0.793238 0 0.0839132 -k 0 -k 1 -k 2 ;
	pickWalk -d down;            
	rename ($modName + "_ROOTSecondaryCtrl3Shape");
    duplicate -rr; rotate -r 0 90 0; for ($i=1; $i<2; ++$i) duplicate -rr -st;
    makeIdentity -apply true -r 1 ($modName + "_ROOTSecondaryCtrl4") ($modName + "_ROOTSecondaryCtrl5");
	parent -r -s ($modName + "_ROOTSecondaryCtrl2Shape")  ($modName + "_ROOTSecondaryCtrl3Shape") ($modName + "_ROOTSecondaryCtrl4Shape") ($modName + "_ROOTSecondaryCtrl5Shape") ($modName + "_ROOTSecondaryCtrl");
	delete ($modName + "_ROOTSecondaryCtrl2") ($modName + "_ROOTSecondaryCtrl3") ($modName + "_ROOTSecondaryCtrl4") ($modName + "_ROOTSecondaryCtrl5");	
	
	move -r 0 0.03 0 ($modName + "_ROOTSecondaryCtrl.scalePivot") ($modName + "_ROOTSecondaryCtrl.rotatePivot");
	parent ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTCtrl");
	delete `pointConstraint ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl")`;
	makeIdentity -apply true ($modName + "_ROOTSecondaryCtrl");
	
	group -n ($modName + "_ROOTCtrlGrp") ($modName + "_ROOTCtrl"); xform -os -piv 0 0 0;
	parentConstraint ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
	parent ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp") RRM_ROOT;
	setAttr (($modName + "_ROOTParentCtrl.scale"), 4, 4, 4);
	setAttr (($modName + "_ROOTCtrlGrp.scale"), 4, 4, 4);
	parent -w ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
	makeIdentity -apply true -s 1 ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
	scaleConstraint ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");

	group -n ($modName + "_ROOTParentCtrlGrp") ($modName + "_ROOTParentCtrl");
	group -n ($modName + "_ROOTParentCtrlGrp2")  ($modName + "_ROOTParentCtrlGrp");
	delete `parentConstraint RRM_ROOT ($modName + "_ROOTParentCtrlGrp2")`;
	makeIdentity -apply true -t 1 ($modName + "_ROOTParentCtrlGrp2");
	
	parentConstraint -mo ($modName + "_PivotCtrl") ($modName + "_ROOTParentCtrlGrp2");
	
	//CREATE OFFSETTING VALUES ON PARENT CTRL GRP
	shadingNode -asUtility multiplyDivide -n ($modName + "_ROOTParentCtrlGrp_MD");
	connectAttr -f ($modName + "_PivotCtrl.translate") ($modName + "_ROOTParentCtrlGrp_MD.input1");
	setAttr (($modName + "_ROOTParentCtrlGrp_MD.input2"), -1, -1, -1);
	connectAttr -f ($modName + "_ROOTParentCtrlGrp_MD.output") ($modName + "_ROOTParentCtrlGrp.translate");
	
	
	delete -ch ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTParentCtrl");
	parentConstraint ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTJnt");
	connectAttr -f ($modName + "_ROOTSecondaryCtrl.scale") ($modName + "_ROOTJnt.scale");
	
	
	//ADD VISIBILITY CONTROL FOR PARENT CONTROL
	addAttr -ln "parentControl"  -at bool ($modName + "_ROOTCtrl");
	setAttr -e-keyable true ($modName + "_ROOTCtrl.parentControl");
	connectAttr -f ($modName + "_ROOTCtrl.parentControl") ($modName + "_ROOTParentCtrl.v");
	setAttr -lock true -keyable false -channelBox false ($modName + "_ROOTParentCtrl.v");
	setAttr ($modName + "_ROOTCtrl.parentControl") 0;
	
	//ADD VISIBILITY CONTROL FOR PIVOT CONTROL
	addAttr -ln "pivotCtrlVisibility"  -at bool ($modName + "_MAINCtrl");
	setAttr -e-keyable true ($modName + "_MAINCtrl.pivotCtrlVisibility");
	connectAttr -f ($modName + "_MAINCtrl.pivotCtrlVisibility") ($modName + "_PivotCtrl.v");
	setAttr -lock true -keyable false -channelBox false ($modName + "_PivotCtrl.v");
	setAttr ($modName + "_MAINCtrl.pivotCtrlVisibility") 0;
	
	setAttr -lock true -keyable false -channelBox false ($modName + "_PivotCtrl.sx");
	setAttr -lock true -keyable false -channelBox false ($modName + "_PivotCtrl.sy");
	setAttr -lock true -keyable false -channelBox false ($modName + "_PivotCtrl.sz");


	group -n ($modName + "_ROOTGrp") ($modName + "_ROOTParentCtrlGrp2");
	parent ($modName + "_ROOTCtrlGrp") ($modName + "_ROOTParentCtrlGrp2");
	parent ($modName + "_ROOTGrp") ($modName + "_MAINCtrl");
	parent ($modName + "_ROOTJnt") ($modName + "_ROOTCtrlGrp");

	parent ($modName + "_MAINCtrl") $modName;

	//ADD CORE NAME
	$modControls = `ls ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTParentCtrl")`;
	RRM_CoreName($modControls);
	for ($crntModControl in $modControls)
	{
		addAttr -ln "isROOT"  -dt "string" $crntModControl;
		setAttr -e-keyable true ($crntModControl + ".isROOT");
		setAttr -type "string" ($crntModControl + ".isROOT") $crntModControl;
		setAttr -e-lock true ($crntModControl + ".isROOT");
		
		setAttr -type "string" ($crntModControl + ".modCoreName") ("_ROOTCtrl");
		setAttr -e-lock true ($crntModControl + ".modCoreName");
	}

	addAttr -ln "isMain"  -dt "string" ($modName + "_MAINCtrl");
	setAttr -e-keyable true ($modName + "_MAINCtrl.isMain");
	setAttr -type "string" ($modName + "_MAINCtrl.isMain") "isMain";
	setAttr -e-lock true ($modName + "_MAINCtrl.isMain");

	//ADD VERSION NUMBER
	addAttr -ln "versionNumber"  -dt "string" ($modName + "_MAINCtrl");
	setAttr -e-keyable true ($modName + "_MAINCtrl.versionNumber");
	setAttr -type "string" ($modName + "_MAINCtrl.versionNumber") "1.5.2";
	setAttr -e-lock true ($modName + "_MAINCtrl.versionNumber");

	addAttr -ln "isROOTCtrl"  -dt "string" ($modName + "_ROOTCtrl");
	setAttr -e-keyable true ($modName + "_ROOTCtrl.isROOTCtrl");
	setAttr -e-lock true ($modName + "_ROOTCtrl.isROOTCtrl");

	addAttr -ln "isROOTGrp"  -dt "string" ($modName + "_ROOTGrp");
	setAttr -e-keyable true ($modName + "_ROOTGrp.isROOTGrp");
	setAttr -e-lock true ($modName + "_ROOTGrp.isROOTGrp");
	
	//CREATE LOCATOR FOR TURNING OFF CONSTRAINTS
	spaceLocator -n ($modName + "_ROOTLocLctr");
	delete `pointConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTLocLctr")`;
	parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTLocLctr");
	parent ($modName + "_ROOTLocLctr") ($modName + "_ROOTGrp");
	setAttr ($modName + "_ROOTLocLctr.v") 0;
	
	
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}
	

////////////////////////////////////////////////////////////////////////////////
//////////////////////////GENERATE SPLINE MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_SplineFKControl()
{
	circle -n "splineFKCtrl" -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;	
	scale -r  -0.333 1 1 splineFKCtrl.cv[3] splineFKCtrl.cv[7];
	move -r 0 0 -0.35 splineFKCtrl.cv[0] splineFKCtrl.cv[2];
	delete -ch splineFKCtrl;
}

global proc RRM_GenerateRigSpline(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     

	//INTEGER FOR LOOP
	$mirrorInt = 2;
	$multiplier = 1;
	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 1;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 2)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "spline";
		setAttr -l true ($modCore + "Grp.topNode");		
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$splineProxies = `ls ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = (`size $splineProxies` + 1);
		
		addAttr -ln "splineJoints"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.splineJoints") ;
		setAttr -type "string" ($modCore + "Grp.splineJoints") $splineSize;
		setAttr -l true ($modCore + "Grp.splineJoints");	
	
		
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_ScaleGrp")`;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_ScaleGrp");
			
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint -mo ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp")`;
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_ScaleGrp")`;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_ScaleGrp");
			
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
		
		//ORIENTATION AND LENGTH LOCATORS
		spaceLocator -n ($modCore + "_OrientLctr");
		parent ($modCore + "_OrientLctr") ($modCore + "Grp");	
		spaceLocator -n  ($modCore + "_OrientLengthLctr");
		parent ($modCore + "_OrientLengthLctr") ($modCore + "_OrientLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_OrientLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 0 0 1
		-worldUpType "objectrotation"  -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
		("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLengthLctr");
		$getSplineLength = `getAttr ($modCore + "_OrientLengthLctr.ty")`;
	
		//FK CONTROLS
		$splineProxies = `ls ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = `size $splineProxies`;
		int $crntNum = 1;
		while ($crntNum <= $splineSize)
		{
			$nPd = "_0";
			if ($crntNum >= 10)
			{$nPd = "_";}
			$prvNPad = "_0";
			if ($crntNum > 10)
			{$prvNPad = "_";}		
			int $testNum = $crntNum;
		
			RRM_SplineFKControl;
			rename "splineFKCtrl" ($modCore + $nPd + $crntNum + "FKCtrl");
			group -n ($modCore + $nPd + $crntNum + "FKCtrlGrp") ($modCore + $nPd + $crntNum + "FKCtrl"); xform -os -piv 0 0 0;
			delete `parentConstraint ("RRM_" + $prfx + $core + $nPd + $crntNum) ($modCore + $nPd + $crntNum + "FKCtrlGrp")`;
		
			$parentNodeLoc = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Parent")`;
			$topNodeLoc = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Top")`; 
			$scale = ((($getSplineLength + $getSplineLength / $splineSize))/3);
			scale -r $scale $scale $scale ($modCore + $nPd + $crntNum + "FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + $nPd + $crntNum + "FKCtrlGrp");
			
			parent ($modCore + $nPd + $crntNum + "FKCtrlGrp") ($modCore + "_ScaleGrp");
			
			if ($crntNum == 1)
			{
				spaceLocator -n ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				setAttr ($modCore + $nPd + $crntNum + "FKCFlipLctr.v") 0;
				parent ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_ScaleGrp");
	
				delete `orientConstraint ($modCore + "_OffsetLctr") ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				delete `pointConstraint  ($modCore) ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore) ($modCore + $nPd + $testNum + "FKCtrlGrp");
				orientConstraint -mo ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_OffsetLctr") ($modCore + $nPd + $testNum + "FKCtrlGrp");
				parentConstraint -mo ($modCore) ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				
				//PARENT ORIENT
				addAttr -ln "orient"  -at double  -min 0 -max 1 -dv 1 ($modCore + $nPd + $testNum + "FKCtrl");
				setAttr -e-keyable true ($modCore + $nPd + $testNum + "FKCtrl.orient");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + $nPd + $crntNum + "FKCFlipLctrW0");
				
				shadingNode -asUtility reverse -n ($modCore + $nPd + $testNum + "FKParentOrientReverse");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKParentOrientReverse.inputX");
				connectAttr -force ($modCore + $nPd + $testNum + "FKParentOrientReverse.outputX") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + "_OffsetLctrW1");
			}
			else
			{
				spaceLocator -n ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				setAttr ($modCore + $nPd + $crntNum + "FKCFlipLctr.v") 0;
				parent ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_ScaleGrp");
				
				delete `orientConstraint ($modCore + "_OffsetLctr") ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				delete `pointConstraint  ($modCore + $prvNPad + ($crntNum - 1) + "FKCtrl") ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + $prvNPad + ($crntNum - 1) + "FKCtrl") ($modCore + $nPd + $testNum + "FKCtrlGrp");
				orientConstraint -mo ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_OffsetLctr") ($modCore + $nPd + $testNum + "FKCtrlGrp");
				parentConstraint -mo ($modCore + $prvNPad + ($crntNum - 1) + "FKCtrl") ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				
				//PARENT ORIENT
				addAttr -ln "orient"  -at double  -min 0 -max 1 -dv 1 ($modCore + $nPd + $testNum + "FKCtrl");
				setAttr -e-keyable true ($modCore + $nPd + $testNum + "FKCtrl.orient");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + $nPd + $crntNum + "FKCFlipLctrW0");
				
				shadingNode -asUtility reverse -n ($modCore + $nPd + $testNum + "FKParentOrientReverse");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKParentOrientReverse.inputX");
				connectAttr -force ($modCore + $nPd + $testNum + "FKParentOrientReverse.outputX") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + "_OffsetLctrW1");	
			}
			$crntNum++;
		}
		
		//IK SPLINE CONTROLS
		curve -n ($modCore + "_TopIKCtrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
		-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
		-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
		-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
		-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
		-k 23 -k 24 ;
		rotate 90 0 0 ($modCore + "_TopIKCtrl");
		pickWalk -d down;
		rename ($modCore + "_TopIKCtrlShape");
		delete -ch;
		setAttr ($modCore + "_TopIKCtrl.sx") ((($getSplineLength + $getSplineLength / $splineSize))/14);
		setAttr ($modCore + "_TopIKCtrl.sy") ((($getSplineLength + $getSplineLength / $splineSize))/14);
		setAttr ($modCore + "_TopIKCtrl.sz") ((($getSplineLength + $getSplineLength / $splineSize))/14);
		select ($modCore + "_TopIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_TopIKCtrl");
		group -n ($modCore + "_TopIKCtrlGrp"); xform -os -piv 0 0 0;
		
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_TopIKCtrlGrp")`;
		//rotate -r 0 0 90 ($modCore + "_TopIKCtrlGrp");
		
		curve -n ($modCore + "_MidIKCtrl") -d 1 -p 0 0 2.5 -p -1.5 0 1 -p -3 0 1 -p -3 0 -1 -p 3 0 -1 -p 3 0 1 -p 1.5 0 1 -p 0 0 2.5 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
		pickWalk -d down;
		rename ($modCore + "_MidIKCtrlShape");
		group -n ($modCore + "_MidIKCtrlGrp") ($modCore + "_MidIKCtrl"); xform -os -piv 0 0 0;
		spaceLocator -n ($modCore + "_MidIKCtrlLctr");
		spaceLocator -n ($modCore + "_MidIKCtrlWSLctr");
		group -n ($modCore + "_MidIKCtrlLctrGrp") ($modCore + "_MidIKCtrlLctr"); xform -os -piv 0 0 0;
		
		parent ($modCore + "_TopIKCtrlGrp") ($modCore + "_MidIKCtrlGrp") ($modCore + "_MidIKCtrlLctrGrp") ($modCore + "_MidIKCtrlWSLctr") ($modCore);
		
		//HIDE LOCATORS
		setAttr ($modCore + "_MidIKCtrlLctr.v") 0;
		setAttr ($modCore + "_MidIKCtrlWSLctr.v") 0;
		
		
		//LOCATOR TO PREVENT FLIPPING OF IK CONTROL
		spaceLocator -n ($modCore + "_TopIKCtrl_FlipLctr1");
		delete `orientConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopIKCtrl_FlipLctr1")`;
		parentConstraint -mo ($modCore + "_OffsetLctr") ($modCore + "_TopIKCtrl_FlipLctr1");
		
		spaceLocator -n ($modCore + "_TopIKCtrl_FlipLctr2");
		delete `orientConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopIKCtrl_FlipLctr2")`;
		setAttr ($modCore + "_TopIKCtrl_FlipLctr1.v") 0;
		setAttr ($modCore + "_TopIKCtrl_FlipLctr2.v") 0;
		parent ($modCore + "_TopIKCtrl_FlipLctr1") ($modCore + "_TopIKCtrl_FlipLctr2") ($modCore + "_ScaleGrp");
			
		//CONSTRAIN TO FK CONTROLS
		//NUMBER OF SPLINE JOINTS
		$spineDums = `ls ("RRM" + "_" + $oppPrfx + $core + "_??") ("RRM" + "_" + $oppPrfx + $core + "_Top")`;
		$spineNum = `size $spineDums`;
		
		//GET SECOND FROM TOP
		int $splineNumTop = ($spineNum - 1);
		$nPd = "_0";
		if ($splineNumTop >=10)
			{$nPd = "_";}
			
		//GET HALF WAY POINT FOR MID IKCtrlGrp TO ATTACH TO. IF UNEVEN NUMBER, NEED TWO TARGETS
		int $midSpline = ($spineNum/2);
		int $midSpline2 = ($midSpline + 1);
		$nPdMid = "_0";
		$nPdMid2 = "_0";
		if ($midSpline >=10)
		{$nPdMid = "_";}
		if ($midSpline2 >=10)
		{$nPdMid2 = "_";}
		
		//CONSTRAIN MID IKC ASSETS TO THE CENTER
		if ($spineNum % 2 == 0)
		{
			parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + "_MidIKCtrlLctrGrp");
			delete `parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + "_MidIKCtrlWSLctr")`;
		}
		else
		{
			parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + $nPdMid2 + $midSpline2 + "FKCtrl") ($modCore + "_MidIKCtrlLctrGrp");
			setAttr ($modCore + "_MidIKCtrlLctrGrp_parentConstraint1.interpType") 2;
			delete `parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + $nPdMid2 + $midSpline2 + "FKCtrl") ($modCore + "_MidIKCtrlWSLctr")`;
		}
		
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_MidIKCtrlWSLctr");
		parentConstraint -skipRotate x -skipRotate y -skipRotate z ($modCore + "_MidIKCtrlLctr") ($modCore + "_MidIKCtrlWSLctr")($modCore + "_MidIKCtrlGrp");
		orientConstraint ($modCore + "_MidIKCtrlLctr") ($modCore + "_MidIKCtrlWSLctr")($modCore + "_MidIKCtrlGrp");
		
		//PARENT ORIENT/TRANSLATE MID IKCG
		addAttr -ln "midTranslate" -at double -min 0 -max 1 -dv 1 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable true ($modCore + "_MidIKCtrl.midTranslate");
		connectAttr -force ($modCore + "_MidIKCtrl.midTranslate") ($modCore + "_MidIKCtrlGrp_parentConstraint1." + $modCore + "_MidIKCtrlLctrW0");

		shadingNode -asUtility reverse -n ($modCore + "_MidIKCParentTranslateReverse");
		connectAttr -force ($modCore + "_MidIKCtrl.midTranslate") ($modCore + "_MidIKCParentTranslateReverse.inputX");
		connectAttr -force ($modCore + "_MidIKCParentTranslateReverse.outputX") ($modCore + "_MidIKCtrlGrp_parentConstraint1." + $modCore + "_MidIKCtrlWSLctrW1");


		addAttr -ln "midOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable true ($modCore + "_MidIKCtrl.midOrient");
		connectAttr -force ($modCore + "_MidIKCtrl.midOrient") ($modCore + "_MidIKCtrlGrp_orientConstraint1." + $modCore + "_MidIKCtrlLctrW0");
		
		shadingNode -asUtility reverse -n ($modCore + "_MidIKCParentOrientReverse");
		connectAttr -force ($modCore + "_MidIKCtrl.midOrient") ($modCore + "_MidIKCParentOrientReverse.inputX");
		connectAttr -force ($modCore + "_MidIKCParentOrientReverse.outputX") ($modCore + "_MidIKCtrlGrp_orientConstraint1." + $modCore + "_MidIKCtrlWSLctrW1");

		
		//TOP IKC
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_MAINCtrl") ($modCore + $nPd + $splineNumTop + "FKCtrl") ($modCore + "_TopIKCtrlGrp");
		parentConstraint -mo ($modCore + $nPd + $splineNumTop + "FKCtrl") ($modCore + "_TopIKCtrl_FlipLctr2");
		orientConstraint -mo ($modCore + "_TopIKCtrl_FlipLctr1") ($modCore + "_TopIKCtrl_FlipLctr2") ($modCore + "_TopIKCtrlGrp");
			
		//PARENT ORIENT/TRANSLATE TOP IKCG
		addAttr -ln "topTranslate" -at double -min 0 -max 1 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable true ($modCore + "_TopIKCtrl.topTranslate");
		connectAttr -force ($modCore + "_TopIKCtrl.topTranslate") ($modCore + "_TopIKCtrlGrp_parentConstraint1." + $modCore + $nPd + $splineNumTop + "FKCtrlW1");

		shadingNode -asUtility reverse -n ($modCore + "_TopIKCParentTranslateReverse");
		connectAttr -force ($modCore + "_TopIKCtrl.topTranslate") ($modCore + "_TopIKCParentTranslateReverse.inputX");
		connectAttr -force ($modCore + "_TopIKCParentTranslateReverse.outputX") ($modCore + "_TopIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");


		addAttr -ln "topOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable true ($modCore + "_TopIKCtrl.topOrient");
		connectAttr -force ($modCore + "_TopIKCtrl.topOrient") ($modCore + "_TopIKCtrlGrp_orientConstraint1." + $modCore + "_TopIKCtrl_FlipLctr2W1");
		
		shadingNode -asUtility reverse -n ($modCore + "_TopIKCParentOrientReverse");
		connectAttr -force ($modCore + "_TopIKCtrl.topOrient") ($modCore + "_TopIKCParentOrientReverse.inputX");
		connectAttr -force ($modCore + "_TopIKCParentOrientReverse.outputX") ($modCore + "_TopIKCtrlGrp_orientConstraint1." + $modCore + "_TopIKCtrl_FlipLctr1W0");

		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////RIBBON SPLINE////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		
		//GET SPLINE LENGTH
		spaceLocator -n ($modCore + "_StartLctr");
		parent ($modCore + "_StartLctr") ($modCore + "Grp");
		spaceLocator -n  ($modCore + "_EndLctr");
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
		pointConstraint ($modCore) ($modCore + "_StartLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none"
		($modCore + "_TopIKCtrl") ($modCore + "_StartLctr");
		pointConstraint ($modCore + "_TopIKCtrl") ($modCore + "_EndLctr");
		
		//SPLINE START POSITION
		nurbsPlane -n ($modCore + "_ribbon") -p 0 0 0 -ax 0 0 1 -w 1 -lr 3 -d 3 -u 1 -v ($splineSize) -ch 1;
		rebuildSurface -ch 1 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 0 -kc 0 -su 1 -du 1 -sv 2 -dv 3 -tol 0.01 -fr 0  -dir 0 ($modCore + "_ribbon");
		delete -ch ($modCore + "_ribbon");
		parent ($modCore + "_ribbon") ($modCore + "Grp");
		
		
		//RIBBON BLENDSHAPE
		duplicate -rr -n ($modCore + "_ribbonBlend") ($modCore + "_ribbon");
		select ($modCore + "_ribbonBlend.cv[1][*]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_ribbonBlend_lCluster");
		move  0 0 0 ($modCore + "_ribbonBlend_lCluster.scalePivot") ($modCore + "_ribbonBlend_lCluster.rotatePivot") ;
		select ($modCore + "_ribbonBlend.cv[0][*]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_ribbonBlend_rCluster");
		move 0 0 0 ($modCore + "_ribbonBlend_rCluster.scalePivot") ($modCore + "_ribbonBlend_rCluster.rotatePivot") ;
		
		select ($modCore + "_ribbonBlend") ($modCore + "_ribbon") ;
		blendShape -n ($modCore + "_ribbonBlendShape") -tc 0;
		setAttr ($modCore + "_ribbonBlendShape1." + $modName + "_" + $prfx + $core + "_ribbonBlend") 1;
		
		group -n ($modCore + "_ribbonBlend_lClusterGrp") ($modCore + "_ribbonBlend_lCluster");xform -os -piv 0 0 0;
		group -n ($modCore + "_ribbonBlend_rClusterGrp") ($modCore + "_ribbonBlend_rCluster");xform -os -piv 0 0 0;
		parent ($modCore + "_ribbonBlend_lClusterGrp") ($modCore + "_ribbonBlend_rClusterGrp") ($modCore + "Grp");
		
		//CHECK FOR NUCLEUS
		int $nucleusCheck;
		if (`objExists "nucleus1"`)
		{
			$nucleusCheck = 1;
		}

		//ORIENT RIBBON
		//HAIR
		select ($modCore + "_ribbon");
		createHair 1 ($splineSize) 10 0 0 0 0 5 0 2 1 1;

		
		//DELETE NUCLEUS IF IT WAS JUST CREATED
		$hairSystemShape = `ls -sl`;
		$nucleus = `listConnections -type "nucleus"`;
		$nucleusSize = `size $nucleus`;
		if ($nucleusCheck == 0 && $nucleusSize > 0)
		{
			delete $nucleus;
		}
		
		string $hairSystem[] = `listRelatives -parent $hairSystemShape`;
		
		delete $hairSystem[0] ($hairSystem[0] + "OutputCurves");
		select ($hairSystem[0] + "Follicles");
		rename ($hairSystem[0] + "Follicles") ($modCore + "_hairSystemFollicles");
		parent ($modCore + "_hairSystemFollicles") ($modCore + "Grp");
	
		select -hi ($modCore + "_hairSystemFollicles");
		select -d  ($modCore + "_hairSystemFollicles");
		$follicles = `ls -sl`;
		float $folliclesNum = `size $follicles`;
		$folliclesNum = $folliclesNum/3;
		int $hierarchySize = 2;
		select ($modCore + "_hairSystemFollicles");
		pickWalk -d down;
		rename ($modCore + "_01F");
		while ($hierarchySize <= $folliclesNum)
		{
			pickWalk -d right;
			$previous = `ls -sl`;
			if ($hierarchySize < 10)
			{
				string $crntValue = $hierarchySize;
				rename ($modCore + "_0" + $crntValue + "F");
			}
			else
			{
				string $crntValue = $hierarchySize;
				rename ($modCore + "_" + $crntValue + "F");
			}
			$hierarchySize++;
		}
		
		select ($modCore + "_??F");
		pickWalk -d down;
		pickWalk -d right;
		delete;
		
		select -cl;
		
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//LOCATORS FOR POSITIONS
	
		//JOINT LOCATIONS
		$ParentPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Parent")`;
		$spineTopPos = `xform -q -ws -rp ($modCore + "_TopIKCtrl")`;
		
		$splineProxies = `ls -type "transform" ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = `size $splineProxies`;
		
		$vertebrae = ($splineSize + 1);
	
		//PATHS
		curve -n ($modCore + "_SplineBtm") -d 1 -p $ParentPos[0] $ParentPos[1] $ParentPos[2] -p $spineTopPos[0] $spineTopPos[1] $spineTopPos[2];
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s ($vertebrae - 2) -d 3 -tol 0 ($modCore + "_SplineBtm");
	
		int $i = 1;
		for ($each in $splineProxies)
		{
			$splinePos = `xform -q -ws -rp $each`;
			move -ws $splinePos[0] $splinePos[1] $splinePos[2] ($modCore + "_SplineBtm.cv[" + $i + "]");
			$i++;
		}

		select ($modCore + "_SplineBtm");
		pickWalk -d down;
		rename ($modCore + "_SplineBtmShape");
		
		float $vertebraeFloat = $vertebrae;
		
		//CUT CURVE IN HALF
		detachCurve -ch 0 -cos on -rpo 1 -n ($modCore + "_SplineTop") ($modCore + "_SplineBtm.u[0.5]");
		rename ($modCore + "_SplineTop1") ($modCore + "_SplineTop");
		
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 0 -kt 0 -s 1 -d 3 -tol 0.000328084 ($modCore + "_SplineBtm");
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 0 -kt 0 -s 1 -d 3 -tol 0.000328084 ($modCore + "_SplineTop");
		
		parent ($modCore + "_SplineTop") ($modCore + "_SplineBtm") ($modCore + "Grp");

		addAttr -ln "nonControl"  -dt "string" ($modCore + "_SplineTop");
		setAttr -e-keyable true ($modCore + "_SplineTop.nonControl");
		setAttr -lock true ($modCore + "_SplineTop.nonControl");

		addAttr -ln "nonControl"  -dt "string" ($modCore + "_SplineBtm");
		setAttr -e-keyable true ($modCore + "_SplineBtm.nonControl");
		setAttr -lock true ($modCore + "_SplineBtm.nonControl");

		//ATTACH LOCATORS TO PATHS
		$i = 1;
		string $nPd = "_0"; 
		for ($each in $splineProxies)
		{
			if ($i >= 10)
			{
				$nPd = "_";
			}
			spaceLocator -n ($modCore + $nPd + $i + "CurveLctr");
			group -n ($modCore + $nPd + $i + "CurveLctrGrp");
			if ($i <= (($splineSize + 1)/2))
			{
				pathAnimation -n ($modCore + $nPd + $i + "Lctr_MP") -fractionMode true -follow true -followAxis x -upAxis z
				-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + $nPd + $i + "F") -inverseUp false -inverseFront false -bank false
				($modCore + $nPd + $i + "CurveLctrGrp") ($modCore + "_SplineBtm");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $nPd + $i + "Lctr_MP");
				float $uValue = ((float)$i/(((float)$splineSize + (float)1)/(float)2));
				if ($uValue == 1)
				{
					$uValue = 0.99999;
				}
				setAttr ($modCore + $nPd + $i + "Lctr_MP.uValue") $uValue;
			}
			else
			{
				pathAnimation -n ($modCore + $nPd + $i + "Lctr_MP") -fractionMode true -follow true -followAxis x -upAxis z
				-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + $nPd + $i + "F") -inverseUp false -inverseFront false -bank false
				($modCore + $nPd + $i + "CurveLctrGrp") ($modCore + "_SplineTop");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $nPd + $i + "Lctr_MP");
				float $uValue = (((float)$i - (((float)$splineSize + (float)1)/(float)2))/(((float)$splineSize + (float)1)/(float)2));
				if ($uValue == 1)
				{
					$uValue = 0.99999;
				}
				setAttr ($modCore + $nPd + $i + "Lctr_MP.uValue") $uValue;
			}
			delete `parentConstraint  ($modCore + $nPd + $i + "FKCtrl") ($modCore + $nPd + $i + "CurveLctr")`;
			$i++;
		}

		$curveLctrGrp = `ls ($modCore + "_??CurveLctrGrp")`;
		parent $curveLctrGrp ($modCore + "Grp");
		//CONNECT TO MAINCtrl SCALE
		for ($each in $curveLctrGrp)
		{
			connectAttr -f ($modName + "_MAINCtrl.scale") ($each + ".scale");
		}
		
		//GET POSITIONS
		$modAttachNodePos = `xform -q -ws -rp ($modCore)`;
		$spineTopJPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Top")`;
		$SpineCenter = `xform -q -ws -t ($modCore + "_SplineTop.cv[0]")`;
		
		//CREATE CLUSTERS SPLINE SPLINE
		select ($modCore + "_SplineBtm.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineBtm_BtmClstr");
		group -n ($modCore + "_SplineBtm_ClusterGrp") ($modCore + "_SplineBtm_BtmClstr");
		xform -os -piv $modAttachNodePos[0] $modAttachNodePos[1] $modAttachNodePos[2];
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_SplineBtm_ClusterGrp");
		
		select ($modCore + "_SplineBtm.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineBtm_TopClstr");
	
		select ($modCore + "_SplineTop.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineTop_BtmClstr");
		
		group -n ($modCore + "_SplineMid_ClusterGrp") ($modCore + "_SplineBtm_TopClstr")($modCore + "_SplineTop_BtmClstr");
		xform -os -piv $SpineCenter[0] $SpineCenter[1] $SpineCenter[2];
		parentConstraint -mo ($modCore + "_MidIKCtrl") ($modCore + "_SplineMid_ClusterGrp");
		
		select ($modCore + "_SplineTop.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineTop_TopClstr");
		group -n ($modCore + "_SplineTop_ClusterGrp") ($modCore + "_SplineTop_TopClstr");
		xform -os -piv $spineTopJPos[0] $spineTopJPos[1] $spineTopJPos[2];
		parentConstraint -mo ($modCore + "_TopIKCtrl") ($modCore + "_SplineTop_ClusterGrp");
											 
		parent ($modCore + "_SplineTop_ClusterGrp") ($modCore + "_SplineMid_ClusterGrp") ($modCore + "_SplineBtm_ClusterGrp") ($modCore + "_ScaleGrp");
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//TOP AND BOTTOM JOINTS
		select -cl;
		joint -n ($modCore + "_TopJnt");
		delete `parentConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopJnt")`;
		rotate -r -os 0 0 90 ($modCore + "_TopJnt");
		makeIdentity -apply true -r 1 ($modCore + "_TopJnt");
		parentConstraint -mo ($modCore + "_TopIKCtrl") ($modCore + "_TopJnt");
		//CONNECT SCALE
		connectAttr -f ($modCore + "_TopIKCtrl.scaleX") ($modCore + "_TopJnt.scaleY");
		connectAttr -f ($modCore + "_TopIKCtrl.scaleY") ($modCore + "_TopJnt.scaleX");
		connectAttr -f ($modCore + "_TopIKCtrl.scaleZ") ($modCore + "_TopJnt.scaleZ");
			
		parent ($modCore + "_TopJnt") ($modCore + "_ScaleGrp");
			
		select -cl;
		joint -n ($modCore + "_TopJntIK") -p 0 2 0 ;
		
		select -cl;
		joint -n ($modCore + "_Btm01JntIK") -p 0 -2 0 ;
		
		select -cl;
		joint -n ($modCore + "_MidJntIK") -p 0 0 0 ;
		
		string $selectedList[] = `ls ($modCore + "_TopJntIK") ($modCore + "_Btm01JntIK") ($modCore + "_MidJntIK")`;
		
		string $crntObject;
		
		for ($crntObject in $selectedList)		
		{
			setAttr ($crntObject + ".radius") .5;
		}
		
		//GROUP AND SCALE
		group -n ($modCore + "_ribbonSpineGrp") ($modCore + "_ribbon");
		parent ($modCore + "_Btm01JntIK") ($modCore + "_MidJntIK") ($modCore + "_TopJntIK") ($modCore + "_ScaleGrp");
		
		$splineLength = `xform -q -t ($modCore + "_EndLctr")`;
		setAttr (($modCore + "_ribbonSpineGrp.scale"), ($splineLength[1] / 4), ($splineLength[1] / 4), ($splineLength[1] / 4));
		
		
		//CONNECT TO RIG
		delete `parentConstraint ($modCore + "_OrientLctr") ($modCore + "_ribbonSpineGrp")`;
		delete `pointConstraint ($modCore + "_OrientLctr") ($modCore + "_OrientLengthLctr") ($modCore + "_ribbonSpineGrp")`;
	
		parentConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopJntIK") ;
		
		parentConstraint ($modCore + "_MidIKCtrl") ($modCore + "_MidJntIK") ;
		
		parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_Btm01JntIK") ;
		
		select ($modCore + "_ribbon") ($modCore + "_TopJntIK") ($modCore + "_Btm01JntIK") ($modCore + "_MidJntIK");

		//DETERMINE VERSION NUMBER
		$versionNum = `getApplicationVersionAsFloat`;
		if ($versionNum >= 2013)
		{
			skinCluster -n ($modCore + "_ribbonSkinClstr")  -bindMethod 1 -toSelectedBones -nw 1 -mi 3 -dr 4 -rui 1;
		}
		else
		{
			skinCluster -n ($modCore + "_ribbonSkinClstr") -toSelectedBones -ignoreHierarchy -mi 3 -dr 1 -rui 1;
		}
		
		//GENERATE JOINTS
		string $splineJoints[];
		int $crntNum = 0;
		float $splineLoc[];
		for ($crntProxy in $splineProxies)
		{
			$crntNum++;
			$numPadding = "_0";
			if ($crntNum >= 10)
			{$numPadding = "_";}
			curve -d 1 -p -4 0 0 -p 4 0 0 -k 0 -k 1 -n ($modCore + $numPadding + $crntNum + "CurveCtrl");
			pickWalk -d down;
			rename ($modCore + $numPadding + $crntNum + "CurveCtrlShape");
			circle -c 5 0 0 -nr 0 1 0 -n ($modCore + $numPadding + $crntNum + "CurveCtrl2");
			circle -c -5 0 0 -nr 0 1 0 -n ($modCore + $numPadding + $crntNum + "CurveCtrl3");
			select ($modCore + $numPadding + $crntNum + "CurveCtrl2") ($modCore + $numPadding + $crntNum + "CurveCtrl3");
			pickWalk -d down;
			select -add ($modCore + $numPadding + $crntNum + "CurveCtrl");
			parent -r -s;
			delete ($modCore + $numPadding + $crntNum + "CurveCtrl2") ($modCore + $numPadding + $crntNum + "CurveCtrl3");
			setAttr (($modCore + $numPadding + $crntNum + "CurveCtrl.scale"), ($getSplineLength*.06),($getSplineLength*.06),($getSplineLength*.06));
			makeIdentity -apply true -s 1 ($modCore + $numPadding + $crntNum + "CurveCtrl");
				
			group -n ($modCore + $numPadding + $crntNum + "CurveCtrlGrp") ($modCore + $numPadding + $crntNum + "CurveCtrl");

			delete `parentConstraint ("RRM_" + $prfx + $core + $numPadding + $crntNum)  ($modCore + $numPadding + $crntNum + "CurveCtrlGrp")`;
			pointConstraint -mo ($modCore + $numPadding + $crntNum + "CurveLctr") ($modCore + $numPadding + $crntNum + "FKCtrl") ($modCore + $numPadding + $crntNum + "CurveCtrlGrp");
			orientConstraint -mo ($modCore + $numPadding + $crntNum + "F") ($modCore + $numPadding + $crntNum + "CurveLctr");
			orientConstraint ($modCore + $numPadding + $crntNum + "CurveLctr") ($modCore + $numPadding + $crntNum + "FKCtrl") ($modCore + $numPadding + $crntNum + "CurveCtrlGrp");
			setAttr ($modCore + $numPadding + $crntNum + "CurveLctr_orientConstraint1.interpType") 2;
			setAttr ($modCore + $numPadding + $crntNum + "CurveCtrlGrp_orientConstraint1.interpType") 2;
			
			select -cl;
			joint -n ($modCore + $numPadding + $crntNum + "Jnt");

			parent ($modCore + $numPadding + $crntNum + "CurveCtrlGrp") ($modCore + $numPadding + $crntNum + "Jnt") ($modCore + "_ScaleGrp");

			delete `parentConstraint ($modCore + $numPadding + $crntNum + "CurveCtrl") ($modCore + $numPadding + $crntNum + "Jnt")`;
			rotate -r -os 0 0 90 ($modCore + $numPadding + $crntNum + "Jnt");
			makeIdentity -apply true -r 1 ($modCore + $numPadding + $crntNum + "Jnt");
			parentConstraint -mo ($modCore + $numPadding + $crntNum + "CurveCtrl") ($modCore + $numPadding + $crntNum + "Jnt");
			$splineJoints = `ls ($modCore + $numPadding + $crntNum + "Jnt")`;
		}	

		//SPLINE FOLLOW FK
		addAttr -ln "followFKCtrl"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable true ($modCore + "_TopIKCtrl.followFKCtrl");
		
		//SELECT FKC
		$spineGrp = `ls ($modCore + "_??CurveCtrlGrp")`;
		string $nPd = "0";
		$i = 1;
		for ($each in $spineGrp)
		{
			if ($i >= 10)
			{
				$nPd = "";
			}
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 0;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 0;
	    
			setDrivenKeyframe -currentDriver ($modCore + "_TopIKCtrl.followFKCtrl")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1");
			
			setAttr ($modCore + "_TopIKCtrl.followFKCtrl") 1;
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0") 0;
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 1;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0") 0;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 1;
	    
			setDrivenKeyframe -currentDriver ($modCore + "_TopIKCtrl.followFKCtrl")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1");
			
			setAttr ($modCore + "_TopIKCtrl.followFKCtrl") 0;
			
			$i++;
		}
		
		//CREATE CURVE FOR SPLINE LENGTH
		$Parent_Pos = `xform -q -ws -t ("RRM_" + $prfx + $core + "_Parent")`;
		$spineMidJntIK_Pos = `xform -q -ws -t ($modCore + "_MidJntIK")`;
		$spineTop_Pos = `xform -q -ws -t ($modCore + "_TopJntIK")`;
		
		curve -n ($modCore + "_LengthCurve") -d 3
		-p $Parent_Pos[0] $Parent_Pos[1] $Parent_Pos[2]
		-p (( $spineMidJntIK_Pos[0] - $Parent_Pos[0]) /3.4 + $Parent_Pos[0])
		(( $spineMidJntIK_Pos[1] - $Parent_Pos[1]) /3.4 + $Parent_Pos[1])
		(( $spineMidJntIK_Pos[2] - $Parent_Pos[2]) /3.4 + $Parent_Pos[2])
		
		-p (( $spineMidJntIK_Pos[0] - $Parent_Pos[0]) /1.35 + $Parent_Pos[0])
		(( $spineMidJntIK_Pos[1] - $Parent_Pos[1]) /1.35 + $Parent_Pos[1])
		(( $spineMidJntIK_Pos[2] - $Parent_Pos[2]) /1.35 + $Parent_Pos[2])
		
		-p (($spineTop_Pos[0] - $spineMidJntIK_Pos[0]) /3.7 + $spineMidJntIK_Pos[0])
		(($spineTop_Pos[1] - $spineMidJntIK_Pos[1]) /3.7 + $spineMidJntIK_Pos[1])
		(($spineTop_Pos[2] - $spineMidJntIK_Pos[2]) /3.7 + $spineMidJntIK_Pos[2])
		
		-p (($spineTop_Pos[0] - $spineMidJntIK_Pos[0]) /1.4 + $spineMidJntIK_Pos[0])
		(($spineTop_Pos[1] - $spineMidJntIK_Pos[1]) /1.4 + $spineMidJntIK_Pos[1])
		(($spineTop_Pos[2] - $spineMidJntIK_Pos[2]) /1.4 + $spineMidJntIK_Pos[2])
		-p $spineTop_Pos[0] $spineTop_Pos[1] $spineTop_Pos[2]
		-k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 3 -k 3;
		pickWalk -d down;
		rename ($modCore + "_LengthCtrlShape");
		select ($modCore + "_LengthCurve");
		arclen -ch 1;
		string $curveInfoNode[] = `listConnections -t curveInfo -d 1 -s 0 ($modCore + "_LengthCtrlShape")`;
		rename $curveInfoNode[0] ($modCore + "_LengthInfo");	
		
		parent ($modCore + "_LengthCurve") ($modCore + "Grp");
	
		
		//ATTACH CURVE TO RIG
		select ($modCore + "_LengthCurve.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr01");
		
		select ($modCore + "_LengthCurve.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr02");
		
		select ($modCore + "_LengthCurve.cv[4:5]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr03");
		
		connectAttr -f ($modName + "_" + $modAttachNode + "Jnt.matrix") ($modCore + "_LengthClstr01Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr01Cluster.relative") 0;
		parent ($modCore + "_LengthClstr01") ($modCore + "_ScaleGrp");
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_LengthClstr01");
		
		connectAttr -f ($modCore + "_MidIKCtrl.matrix") ($modCore + "_LengthClstr02Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr02Cluster.relative") 0;
		parent ($modCore + "_LengthClstr02") ($modCore + "_MidIKCtrl");
		
		connectAttr -f ($modCore + "_TopIKCtrl.matrix") ($modCore + "_LengthClstr03Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr03Cluster.relative") 0;
		parent ($modCore + "_LengthClstr03") ($modCore + "_TopIKCtrl");
		
		//SCALE
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HierarchyCompensate_MD");
		setAttr ($modCore + "_HierarchyCompensate_MD.operation") 2;
		connectAttr -f ($modCore + "_LengthInfo.arcLength") ($modCore + "_HierarchyCompensate_MD.input1X");
		connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modCore + "_HierarchyCompensate_MD.input2X");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthRatio_MD");
		connectAttr -f ($modCore + "_HierarchyCompensate_MD.outputX") ($modCore + "_LengthRatio_MD.input1X");
		setAttr ($modCore + "_LengthRatio_MD.operation") 2;
		
		float $SpineLengthValue = `getAttr ($modCore + "_LengthInfo.arcLength")`;
		setAttr ($modCore + "_LengthRatio_MD.input2X") $SpineLengthValue;
		
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_TopJntIK.scaleY");
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_MidJntIK.scaleY");
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_Btm01JntIK.scaleY");
		
		//INVERSE SCALE
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthRatioInverse_MD");
		connectAttr -f ($modCore + "_HierarchyCompensate_MD.outputX") ($modCore + "_LengthRatioInverse_MD.input2X");
		setAttr ($modCore + "_LengthRatioInverse_MD.operation") 2;
		
		setAttr ($modCore + "_LengthRatioInverse_MD.input1X") $SpineLengthValue;
		
		shadingNode -asUtility blendColors -n ($modCore + "_LengthRatioInverse_Blnd");
		setAttr ($modCore + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_LengthRatioInverse_MD.outputX") ($modCore + "_LengthRatioInverse_Blnd.color1R");
	
		$spineJnt = `ls ($modCore + "_??Jnt")`;
		int $i= 0;
		for ($crntJnt in $spineJnt)
		{
			$i++;
			string $numPad = "_0";
			if ($i >= 10)
			{
				$numPad = "_";
			}
			//CONNECT MICRO CONTROL TO SCALE
			shadingNode -asUtility multiplyDivide -n ($modCore + $numPad + $i + "CurveCtrl_Scale_MD");
			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl.scaleX") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input2Y");
			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl.scaleY") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input2X");
			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl.scaleZ") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input2Z");
		
			connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1X");
			connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1Y");
			connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1Z");

			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.output") ($crntJnt + ".scale");
		}
		
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_TopJntIK.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_TopJntIK.scaleZ");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_MidJntIK.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_MidJntIK.scaleZ");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_Btm01JntIK.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_Btm01JntIK.scaleZ");
		
		//ADD ATTRIBUTES TO TOPIKC
		//PARENT ORIENT
		$parentOrient = ($modCore + "_TopIKCtrl");
		RRM_ParentOrient($modCore, $modName, $modAttachNode, $parentOrient); 
			
		//AUTO VOLUME
		addAttr -ln "autoVolume"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable true ($modCore + "_TopIKCtrl.autoVolume");
		connectAttr -force ($modCore + "_TopIKCtrl.autoVolume") ($modCore + "_LengthRatioInverse_Blnd.blender");
		setAttr ($modCore + "_TopIKCtrl.autoVolume") 1;
	
		//SPLINE CURVE
		addAttr -ln "splineCurve"  -at double  -min 0.001 -max 5 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable true ($modCore + "_TopIKCtrl.splineCurve");
		
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		//RIBBON SPLINE
		
		//CREATE LOCATORS FOR TX
		spaceLocator -n ($modCore + "_BtmTX_Lctr") -p 0 0 0;
		parent ($modCore + "_BtmTX_Lctr") ($modCore + "_ScaleGrp");
		pointConstraint ($modCore + "_MidIKCtrl") ($modCore + "_BtmTX_Lctr");
		
		spaceLocator -n ($modCore + "_TopTX_Lctr") -p 0 0 0;
		parent ($modCore + "_TopTX_Lctr") ($modCore + "_TopIKCtrl");
		pointConstraint ($modCore + "_MidIKCtrl") ($modCore + "_TopTX_Lctr");
		
		//SET DRIVEN KEY
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIKCtrl.translateX") -4;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") .8;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") 1.2;
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIKCtrl.translateX") 4;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") 1.2;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") .8;
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIKCtrl.translateX") 0;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") 1;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") 1;
		
		selectKey -k ($modCore + "_ribbonBlend_lClusterGrp_scaleY") ($modCore + "_ribbonBlend_rClusterGrp_scaleY") ;
		keyTangent -itt spline -ott spline ;
		
		//ATTACH NODE LOCATOR WITH ZEROED VALUES
		spaceLocator -n ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr");
		group -n ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp");
		delete `pointConstraint ($modCore) ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp")`;
		delete `aimConstraint -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_MidIKCtrl")
		($modCore + "_TopIKCtrl") ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp")`;
		parent ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp") ($modCore + "_ScaleGrp");
		makeIdentity -apply true -t 1 -r 0 -s 1 ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp");
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr");
		
	
		//CONNECT SPLINE IK MIDDLE TO TOP AND BOTTOM SPLINE IK
		shadingNode -n ($modCore + "_SplineMid_Blnd") -asUtility blendColors;
		connectAttr -f ($modCore + "_TopIKCtrl.translate") ($modCore + "_SplineMid_Blnd.color1");
		connectAttr -f ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.translate") ($modCore + "_SplineMid_Blnd.color2");
		//connectAttr -f ($modCore + "_SplineMid_Blnd.output") ($modCore + "_MidIKCtrlLctr.translate");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_SplineMid_Rot_Mid");
		connectAttr -force ($modCore + "_TopIKCtrl.rotate") ($modCore + "_SplineMid_Rot_Mid.input1");
		setAttr ($modCore + "_SplineMid_Rot_Mid.operation") 2;
		setAttr ($modCore + "_SplineMid_Rot_Mid.input2Y") 2;
		connectAttr -force ($modCore + "_SplineMid_Rot_Mid.outputY") ($modCore + "_MidIKCtrlLctr.rotateY");
		
		spaceLocator -n ($modCore + "_MidSplineAimLctr");
		spaceLocator -n ($modCore + "_MidSplineTargetLctr");
		group -n ($modCore + "_MidSplineLctrGrp") ($modCore + "_MidSplineAimLctr") ($modCore + "_MidSplineTargetLctr");
		parent ($modCore + "_MidSplineLctrGrp") ($modCore + "_ScaleGrp");
		delete `pointConstraint ($modCore) ($modCore + "_MidSplineLctrGrp")`;
		delete `aimConstraint -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_MidIKCtrl")
		($modCore + "_TopIKCtrl") ($modCore + "_MidSplineLctrGrp")`;
		delete `pointConstraint ($modCore + "_TopIKCtrl") ($modCore + "_MidSplineTargetLctr")`;
		
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MidSplineAimLctr") ($modCore + "_MidSplineTargetLctr");

		connectAttr -f ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.translate") ($modCore + "_MidSplineAimLctr.translate");
		connectAttr -f ($modCore + "_TopIKCtrl.translate") ($modCore + "_MidSplineTargetLctr.translate");
		
		aimConstraint -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none" -skip y ($modCore + "_MidSplineTargetLctr") ($modCore + "_MidSplineAimLctr");
		connectAttr -f ($modCore + "_MidSplineAimLctr.rotateX") ($modCore + "_MidIKCtrlLctr.rotateX");
		connectAttr -f ($modCore + "_MidSplineAimLctr.rotateZ") ($modCore + "_MidIKCtrlLctr.rotateZ");
		//CREATE ATTRIBUTES FOR IK/FK MIDIKCtrlGrp INFLUENCE
		addAttr -ln "topIKInfPos"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable true ($modCore + "_MidIKCtrl.topIKInfPos");
		addAttr -ln "topIKInfRot"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable true ($modCore + "_MidIKCtrl.topIKInfRot");
		
		//CREATE LOCATOR FOR IK/FK MIDIKCtrlGrp INFLUENCE
		spaceLocator -n ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		group -n ($modCore + "_MidIKCtrlLctrGrp_InfLctrGrp");
		delete `parentConstraint ($modCore + "_MidIKCtrl") ($modCore + "_MidIKCtrlLctrGrp_InfLctrGrp")`;
		parent ($modCore + "_MidIKCtrlLctrGrp_InfLctrGrp") ($modCore + "_ScaleGrp");
		makeIdentity -apply true -t 1 ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_TopIKCtrl") ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "none" -skip y ($modCore + "_TopIKCtrl") ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		setAttr ($modCore + "_MidIKCtrlLctrGrp_InfLctr.v") 0;
		
		//ROTATE BLEND
		shadingNode -asUtility blendColors -n ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend");
		connectAttr -force ($modCore + "_MidSplineAimLctr.rotate") ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.color2");
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_InfLctr.rotate") ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.color1");
		connectAttr -force ($modCore + "_MidIKCtrl.topIKInfRot") ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.blender");
		
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.outputR") ($modCore + "_MidIKCtrlLctr.rotateX");
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.outputB") ($modCore + "_MidIKCtrlLctr.rotateZ");
		
		//TRANSLATE BLEND
		shadingNode -asUtility blendColors -n ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend");
		connectAttr -force ($modCore + "_SplineMid_Blnd.output") ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.color2");
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_InfLctr.translate") ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.color1");
		connectAttr -force ($modCore + "_MidIKCtrl.topIKInfPos") ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.blender");
		
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.output") ($modCore + "_MidIKCtrlLctr.translate");
	
		//SPLINE LENGTH
		addAttr -ln "splineLength"  -at double ($modCore + "_MidIKCtrl");
		setAttr -e-channelBox true ($modCore + "_MidIKCtrl.splineLength");
		addAttr -ln "splineLength"  -at double ($modCore + "_TopIKCtrl");
		setAttr -e-channelBox true ($modCore + "_TopIKCtrl.splineLength");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_Length_MD");
		setAttr ($modCore + "_Length_MD.operation") 2;
		$splineLength[0] = `getAttr ($modCore + "_LengthInfo.arcLength")`;
		setAttr ($modCore + "_Length_MD.input2X") $splineLength[0];
		connectAttr -f ($modCore + "_LengthInfo.arcLength") ($modCore + "_Length_MD.input1X");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthComp_MD");
		setAttr ($modCore + "_LengthComp_MD.operation") 2;
		connectAttr -force ($modCore + "_Length_MD.outputX") ($modCore + "_LengthComp_MD.input1X");
		connectAttr -force ($modName + "_MAINCtrl.scaleY") ($modCore + "_LengthComp_MD.input2X");
		
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_MidIKCtrl.splineLength");
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_TopIKCtrl.splineLength");
	
		shadingNode -asUtility blendColors -n ($modCore + "_Spline_Blnd");
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_Spline_Blnd.color1R");
		connectAttr -f ($modCore + "_TopIKCtrl.splineCurve") ($modCore + "_Spline_Blnd.color2R");
		
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineBtm_ClusterGrp.sy");
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineMid_ClusterGrp.sy");
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineTop_ClusterGrp.sy");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
	
		//VISIBILITY
		$SpineCurveLctrs = `ls ($modCore + "_??CurveLctr")`;
		for ($crntLctr in $SpineCurveLctrs)
		{
			setAttr ($crntLctr + ".v") 0;
		}
		
	
		//SPLINE MICROS
		addAttr -ln "splineMicro"  -at bool  ($modCore + "_TopIKCtrl");
		setAttr -e-k true ($modCore + "_TopIKCtrl.splineMicro");
		
		$splineCurveCtrlGrp = `ls ($modCore + "_??CurveCtrlGrp")`;
		for ($crntCtrlGrp in $splineCurveCtrlGrp)
		{
			connectAttr -f ($modCore + "_TopIKCtrl.splineMicro") ($crntCtrlGrp + ".v");
		}
	
		setAttr ($modCore + "_StartLctr.v") 0;
		setAttr ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.v") 0;
	
		setAttr ($modCore + "_SplineBtm_BtmClstr.v") 0;
		setAttr ($modCore + "_SplineBtm_TopClstr.v") 0;
		setAttr ($modCore + "_SplineTop_BtmClstr.v") 0;
		setAttr ($modCore + "_SplineTop_TopClstr.v") 0;
	
		setAttr ($modCore + "_LengthClstr01.v") 0;
		setAttr ($modCore + "_LengthClstr02.v") 0;
		setAttr ($modCore + "_LengthClstr03.v") 0;
	
	
		setAttr ($modCore + "_ribbon.v") 0;
		setAttr ($modCore + "_ribbonBlend.v") 0;
		setAttr ($modCore + "_ribbonBlend_rCluster.v") 0;
		setAttr ($modCore + "_ribbonBlend_lCluster.v") 0;
		setAttr ($modCore + "_BtmTX_Lctr.v") 0;
		setAttr ($modCore + "_TopTX_Lctr.v") 0;
		setAttr ($modCore + "_Btm01JntIK.v") 0;
		setAttr ($modCore + "_MidJntIK.v") 0;
		setAttr ($modCore + "_TopJntIK.v") 0;
		setAttr ($modCore + "_LengthCurve.template") 1;
		setAttr ($modCore + "_SplineTop.v") 0;
		setAttr ($modCore + "_SplineBtm.v") 0;
	
		addAttr -ln "nonControl"  -dt "string" ($modCore + "_LengthCurve");
		setAttr -e-keyable true ($modCore + "_LengthCurve.nonControl");
		setAttr -lock true ($modCore + "_LengthCurve.nonControl");
		
		$spineF = `ls ($modCore + "_??F")`;
		for ($crntF in $spineF)
		{
			setAttr ($crntF + ".v") 0;
		}
		
		setAttr ($modCore + "_MidSplineTargetLctr.v") 0;
		setAttr ($modCore + "_MidSplineAimLctr.v") 0;
		
		setAttr -l 1 -k 0 ($modCore + "_TopIKCtrl.v");

		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.v");
		
	
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			if (!`objExists ($crntModControl + ".modCoreName")`)
			{
				addAttr -ln "modCoreName"  -dt "string" $crntModControl;
				setAttr -e-keyable true ($crntModControl + ".modCoreName");
				setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
				setAttr -e-lock true ($crntModControl + ".modCoreName");
			}
			//ADD MODULE TYPE
			if (!`objExists ($crntModControl + ".moduleType")`)
			{
				addAttr -ln "moduleType"  -dt "string" ($crntModControl);
				setAttr -e -keyable true ($crntModControl + ".moduleType");
				setAttr -type "string" ($crntModControl + ".moduleType") "spline";
				setAttr -l true ($crntModControl + ".moduleType");
			}
		}
		
		//CLEAN UP
		delete ($modCore + "_OrientLctr");
		
		select -cl;
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}



//////////////////////////////////////////////////////////////////////////////
///////////////////////////////    TOON LIMB    ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////

global proc RRM_ToonLimbs(string $modName, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $wristDummy = "_WristJntDummy";
	string $FKCtrlGrp = "FKCtrlGrp2";
	int $segInteger = 1;
	float $limbLength;

	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFKCtrlGrp";
		$wrist = "_Ankle";
		$wristDummy = "_AnkleJnt";
		$FKCtrlGrp = "FKCtrlGrp";
		select ("RRM_" + $prfx + $core + "_Hip") ("RRM_" + $prfx + $core + "_Ankle");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Knee");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Knee1") ("RRM_" + $prfx + $core + "_Knee1");
		}
		//SET MULTIPLIER TO NOT MIRROR
		$multiplier = 1;
	}
	else
	{
		select ("RRM_" + $prfx + $core + "_Shoulder") ("RRM_" + $prfx + $core + "_Wrist");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow1") ("RRM_" + $prfx + $core + "_Elbow1");
		}
	}
	$segments = `ls -sl`;
	$segSize = `size $segments`;
		
	float $middleLimbLength;

	if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")` && !`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
	{
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".translateX")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	else
	{
		$elbow1 = "_Elbow1";
		$elbow2 = "_Elbow2";
		if ($limbType == "leg")
		{
			$elbow1 = "_Knee1";
			$elbow2 = "_Knee2";
		}			
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$middleLimbLength = `getAttr ($modCore + $elbow2 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".translateX")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	
	//ADD CURVE ATTRIBUTES TO IK FK SWITCH
	addAttr -ln ($elbowType + "Curve")  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable true ($modCore + "_SwitchCtrl." + $elbowType + "Curve");
	
	addAttr -ln "curve"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable true ($modCore + "_SwitchCtrl.curve");
	
	shadingNode -asUtility multiplyDivide -n ($modCore + "_Curve_MD1");
	connectAttr -force ($modCore + "_SwitchCtrl.curve") ($modCore + "_Curve_MD1.input1X");
	setAttr ($modCore + "_Curve_MD1.input2X") 2;
	shadingNode -asUtility multiplyDivide -n ($modCore + "_Curve_MD2");
	connectAttr -force ($modCore + "_Curve_MD1.outputX") ($modCore + "_Curve_MD2.input1X");
	connectAttr -force ($modCore + $shoulder + "FKCtrl.scaleX") ($modCore + "_Curve_MD2.input2X");
	
	//ADD VISIBILITY ATTRIBUTES FOR CURVE CONTROLLERS
	addAttr -ln ($limbType + "Twist")  -at bool  -min 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable true ($modCore + "_SwitchCtrl." + $limbType + "Twist");

	addAttr -ln ($limbType + "CurveMacro")  -at bool  -min 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable true ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro");
	
	addAttr -ln ($limbType + "CurveMicro")  -at bool  -min 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable true ($modCore + "_SwitchCtrl." + $limbType + "CurveMicro");

	
	//GROUP FOR NODES
	group -em -n ($modCore + "_curveNodesGrp");
	parent ($modCore + "_curveNodesGrp") ($modCore + "_ScaleGrp");
	group -em -n ($modCore + "_extraCurveNodesGrp");
	setAttr ($modCore + "_extraCurveNodesGrp.inheritsTransform") 0; 
	parent ($modCore + "_extraCurveNodesGrp") ($modName + "_MAINCtrl");
	
	
	while ($segInteger < $segSize || $segInteger <= 3)
	{
		//UPPER
		$seg = "_Upper";
		$segStart = $shoulder;
		$segEnd = $elbow1;
		$startPos = `xform -q -ws -rp ($modCore + $segStart + "Jnt")`;
		$endPos = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		string $segParentStartOrient = ($modCore + $clavicle + "Jnt");
		if ($limbType == "leg")
		{
			$segParentStartOrient = $modAttachNode;
		}
		string $segEndOrient = ($modCore + $elbow1 + "Jnt");
		
		string $topSegPosAttach = ($modCore + $shoulder + "Jnt");
		string $topSegRotAttach = ($modCore + $parentNode);
		string $btmSegPosAttach = ($modCore + $elbow1 + "_CurveCtrl");
		string $btmSegRotAttach = ($modCore + $elbow1 + "_CurveCtrl");
		string $ikSplineUpObject2 = ($modCore + $shoulder + "Jnt");
		string $segStartUpOrientControl = ($modCore + $seg + "_TwistCtrl");
		string $segEndUpOrientControl = ($modCore + $elbow1 + "_CurveCtrl");
		
		if ($segInteger == 2)
		{//LOWER
			$seg = "_Lower";
			$segStart = $elbow2;
			$segEnd = $wrist;
			$startPos = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
			$endPos = `xform -q -ws -rp ($modCore + $wrist + "Jnt")`;
			$segParentStartOrient = ($modCore + $elbow2 + "Jnt");
			$segEndOrient = ($modCore + $wrist + "Jnt");

			$topSegPosAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$topSegRotAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$btmSegPosAttach = ($modCore + $wrist + "Jnt");
			$btmSegRotAttach = ($modCore + $wrist + "Jnt");
			$ikSplineUpObject2 = ($modCore + $wrist + "JntGrp1");
			if ($limbType == "leg")
			{
				$ikSplineUpObject2 = ($modCore + $wrist + "Jnt");
			}
			$segStartUpOrientControl = ($modCore + $elbow2 + "_CurveCtrl");
			$segEndUpOrientControl = ($modCore + $seg + "_TwistCtrl");
		}
		else if ($segInteger == 3)
		{//MIDDLE
			$seg = "_Middle";
			$segStart = $elbow1;
			$segEnd = $elbow2;
			$startPos = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
			$endPos = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
			$segParentStartOrient = ($modCore + $elbow1 + "Jnt");
			$segEndOrient = ($modCore + $elbow2 + "Jnt");

			$topSegPosAttach = ($modCore + $elbow1 + "_CurveCtrl");
			$topSegRotAttach = ($modCore + $elbow1 + "_CurveCtrl");
			$btmSegPosAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$btmSegRotAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$ikSplineUpObject2 = ($modCore + $elbow2 + "_CurveCtrl");
			$segStartUpOrientControl = ($modCore + $elbow1 + "_CurveCtrl");
			$segEndUpOrientControl = ($modCore + $elbow2 + "_CurveCtrl");
		}
		
		float $segLength;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			if ($segInteger != 2)
			{
				$segLength = `getAttr ($modCore + $segEnd + "Jnt.tx")`;
			}
			else
			{
				$segLength = `getAttr ($modCore + $wristDummy + ".tx")`;
			}
		}
		else
		{
			$elbow1TX = `getAttr ($modCore + $elbow1 + "Jnt.tx")`;
			$elbow2TX = `getAttr ($modCore + $elbow2 + "Jnt.tx")`;
			$segLength = (($elbow1TX + $elbow2TX)*.667);
		}

		// SEGMENTS CHECK
		if (`objExists ("RRM_" + $prfx + $core + $seg + "1")`)
		{
			//CREATE MAIN SPLINE CURVES FOR CONTROL GROUP ATTACHMENT
			curve -n ($modCore + $seg + "CurveAttach") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1;
			delete -ch ($modCore + $seg + "CurveAttach");
			pickWalk -d down;
			rename ($modCore + $seg + "CurveShape");
	
			rebuildCurve -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 ($modCore + $seg + "CurveAttach");
				
			//CREATE GUIDE SPLINE CURVES FOR MACRO CONTROL ATTACHMENT
			curve -n ($modCore + $seg + "CurveGuide") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1 ;
			pickWalk -d down;
			rename ($modCore + $seg + "CurveGuideShape");
			
			rebuildCurve -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 1 -d 3 -tol 0.01 ($modCore + $seg + "CurveGuide");
			delete -ch ($modCore + $seg + "CurveAttach") ($modCore + $seg + "CurveGuide");
			
			parent ($modCore + $seg + "CurveAttach") ($modCore + $seg + "CurveGuide") ($modCore + "_extraCurveNodesGrp");
			setAttr ($modCore + $seg + "CurveAttach.template") 1;
			setAttr ($modCore + $seg + "CurveGuide.v") 0;
			
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.tx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.ty");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.tz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.rx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.ry");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.rz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.sx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.sy");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.sz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.v");
				
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.tx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.ty");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.tz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.rx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.ry");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.rz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.sx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.sy");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.sz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveGuide.v");

			addAttr -ln "nonControl"  -dt "string" ($modCore + $seg + "CurveGuide");
			setAttr -e-keyable true ($modCore + $seg + "CurveGuide.nonControl");
			setAttr -lock true ($modCore + $seg + "CurveGuide.nonControl");

			addAttr -ln "nonControl"  -dt "string" ($modCore + $seg + "CurveAttach");
			setAttr -e-keyable true ($modCore + $seg + "CurveAttach.nonControl");
			setAttr -lock true ($modCore + $seg + "CurveAttach.nonControl");

			//HIDE SHOULDER AND ELBOW JOINTS SO THEY DON'T GET CONFUSED WITH THE TOON JOINTS
			//DETERMINE VERSION NUMBER
			$versionNum = `getApplicationVersionAsFloat`;
			if ($versionNum >= 2011)
			{
				setAttr ($modCore + $segStart + "Jnt.drawStyle") 2;
				if ($segInteger != 2)
				{
					setAttr ($modCore + $segEnd + "Jnt.drawStyle") 2;
				}
			}
			else
			{
				setAttr ($modCore + $segStart + "Jnt.visibility") 0;
				if ($segInteger != 2)
				{
					setAttr ($modCore + $segEnd + "Jnt.visibility") 0;
				}				
			}
			curve -n ($modCore + $seg + "_CurveCtrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
			setAttr ($modCore + $seg + "_CurveCtrl.rotateOrder") 1;
			pickWalk -d down;
			rename ($modCore + $seg + "_CurveCtrlShape");
			
			setAttr (($modCore + $seg + "_CurveCtrl.scale"), ($limbLength*.75), ($limbLength*.75), ($limbLength*.75));
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $seg + "_CurveCtrl");
			connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro") ($modCore + $seg + "_CurveCtrl.v");
			
			group -n ($modCore + $seg + "_CurveCtrlGrp") ($modCore + $seg + "_CurveCtrl");
			setAttr ($modCore + $seg + "_CurveCtrlGrp.rotateOrder") 1;
			pathAnimation -n ($modCore + $seg + "Guide_MP") -fractionMode true -followAxis x -upAxis y -worldUpType "objectrotation"
			-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $segStart + "Jnt") ($modCore + $seg + "_CurveCtrlGrp") ($modCore + $seg + "CurveGuide");
			cutKey -cl -t ":" -f ":" -at "u" ($modCore + $seg + "Guide_MP");
			setAttr ($modCore + $seg + "Guide_MP.uValue") .5;
			
			connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $seg + "_CurveCtrlGrp.scale");
			parent ($modCore + $seg + "_CurveCtrlGrp") ($modCore + "_extraCurveNodesGrp");
			
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_CurveCtrl.rx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_CurveCtrl.ry");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_CurveCtrl.rz");
			//setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_CurveCtrl.sx");
			//setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_CurveCtrl.sy");
			//setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_CurveCtrl.sz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_CurveCtrl.v");

	
			
			if (($segInteger == 1) || ($segInteger == 3 && !`objExists ($modCore + $segEnd + "_CurveCtrl")`))
			{//ELBOW1 CONTROL
				curve -n ($modCore + $segEnd + "_CurveCtrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
				setAttr ($modCore + $segEnd + "_CurveCtrl.rotateOrder") 1;
				pickWalk -d down;
				rename ($modCore + $segEnd + "_CurveCtrlShape");
				setAttr (($modCore + $segEnd + "_CurveCtrl.scale"), ($limbLength/1), ($limbLength/1), ($limbLength/1));
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $segEnd + "_CurveCtrl");
	
				group -n ($modCore + $segEnd + "_CurveCtrlGrp") ($modCore + $segEnd + "_CurveCtrl");
				parent ($modCore + $segEnd + "_CurveCtrlGrp") ($modCore + "_curveNodesGrp");
				pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveCtrlGrp");
				delete `orientConstraint ($modCore + $segStart + "Jnt") ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveCtrlGrp")`;
				orientConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveCtrlGrp");
				setAttr ($modCore + $segEnd + "_CurveCtrlGrp_orientConstraint1.interpType") 2;
				
				connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $segEnd + "_CurveCtrlGrp.scale");
				parent ($modCore + $segEnd + "_CurveCtrlGrp") ($modCore + "_extraCurveNodesGrp");
				
				connectAttr -f ($modCore + "_SwitchCtrl." + $elbowType + "Curve") ($modCore + $segEnd + "_CurveCtrlGrp_orientConstraint1." + $modCore + $segStart + "JntW0");

				connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro") ($modCore + $segEnd + "_CurveCtrl.v");				
				setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $segEnd + "_CurveCtrl.v");
			}//ELBOW1 CONTROL
			
			if (($segInteger == 2 && $elbow2 == "_Elbow2") || ($segInteger != 1 && !`objExists ($modCore + $segStart + "_CurveCtrl")`))
			{//ELBOW2 CONTROL
				curve -n ($modCore + $segStart + "_CurveCtrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
				setAttr ($modCore + $segStart + "_CurveCtrl.rotateOrder") 1;
				pickWalk -d down;
				rename ($modCore + $segStart + "_CurveCtrlShape");
				setAttr (($modCore + $segStart + "_CurveCtrl.scale"), ($limbLength/1), ($limbLength/1), ($limbLength/1));
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $segStart + "_CurveCtrl");
	
				group -n ($modCore + $segStart + "_CurveCtrlGrp") ($modCore + $segStart + "_CurveCtrl");
				parent ($modCore + $segStart + "_CurveCtrlGrp") ($modCore + "_curveNodesGrp");
				pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveCtrlGrp");
				delete `orientConstraint ($modCore + $elbow1 + "Jnt") ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveCtrlGrp")`;
				orientConstraint -mo ($modCore + $elbow1 + "Jnt") ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveCtrlGrp");
				setAttr ($modCore + $segStart + "_CurveCtrlGrp_orientConstraint1.interpType") 2;
				
				connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $segStart + "_CurveCtrlGrp.scale");
				parent ($modCore + $segStart + "_CurveCtrlGrp") ($modCore + "_extraCurveNodesGrp");

				connectAttr -f ($modCore + "_SwitchCtrl." + $elbowType + "Curve") ($modCore + $segStart + "_CurveCtrlGrp_orientConstraint1." + $modCore + $elbow1 + "JntW0");
				connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro") ($modCore + $segStart + "_CurveCtrl.v");				
				setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $segStart + "_CurveCtrl.v");
			}//ELBOW2 CONTROL
				
			//CURVE CLUSTERS
			select ($modCore + $seg + "CurveAttach.cv[0:1]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopClstr");
			group -em -n ($modCore + $seg + "TopClstrGrp");
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + "TopClstrGrp")`;
			parent ($modCore + $seg + "TopClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "TopClstrGrp");
			parent -w ($modCore + $seg + "TopClstrGrp");
			parent ($modCore + $seg + "TopClstr") ($modCore + $seg + "TopClstrGrp");
	
			pointConstraint -mo  $topSegPosAttach ($modCore + $seg + "TopClstrGrp");
			orientConstraint -mo $topSegRotAttach ($modCore + $seg + "TopClstrGrp");
			
			select ($modCore + $seg + "CurveAttach.cv[3:4]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmClstr");
			group -em -n ($modCore + $seg + "BtmClstrGrp");
			delete `pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmClstrGrp")`;
			parent ($modCore + $seg + "BtmClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "BtmClstrGrp");
			parent -w ($modCore + $seg + "BtmClstrGrp");
			parent ($modCore + $seg + "BtmClstr") ($modCore + $seg + "BtmClstrGrp");
				
			delete `orientConstraint $segEndOrient ($modCore + $seg + "BtmClstrGrp")`;

			pointConstraint -mo  $btmSegPosAttach ($modCore + $seg + "BtmClstrGrp");
			orientConstraint -mo $btmSegRotAttach ($modCore + $seg + "BtmClstrGrp");
			
			select ($modCore + $seg + "CurveAttach.cv[2]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "MidClstr");
			
			parentConstraint ($modCore + $seg + "_CurveCtrl") ($modCore + $seg + "MidClstr");
			parent ($modCore + $seg + "MidClstr") ($modCore + "_extraCurveNodesGrp");
			setAttr ($modCore + $seg + "MidClstr.v") 0;
	
			//GUIDE CURVE CLUSTERS
			select ($modCore + $seg + "CurveGuide.cv[0:1]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopGuideClstr");
			group -em -n ($modCore + $seg + "TopGuideClstrGrp");
			delete `pointConstraint ($modCore + $segStart + "FKCtrl") ($modCore + $seg + "TopGuideClstrGrp")`;
			parent ($modCore + $seg + "TopGuideClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "TopGuideClstrGrp");
			parent -w ($modCore + $seg + "TopGuideClstrGrp");
			parent ($modCore + $seg + "TopGuideClstr") ($modCore + $seg + "TopGuideClstrGrp"); 
			
			pointConstraint -mo  $topSegPosAttach ($modCore + $seg + "TopGuideClstrGrp");
			orientConstraint -mo $topSegRotAttach ($modCore + $seg + "TopGuideClstrGrp");
	
			select ($modCore + $seg + "CurveGuide.cv[2:3]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmGuideClstr");
			group -em -n ($modCore + $seg + "BtmGuideClstrGrp");
			delete `pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmGuideClstrGrp")`;
			parent ($modCore + $seg + "BtmGuideClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "BtmGuideClstrGrp");
			parent -w ($modCore + $seg + "BtmGuideClstrGrp");
			parent ($modCore + $seg + "BtmGuideClstr") ($modCore + $seg + "BtmGuideClstrGrp");
	
			delete `orientConstraint $segEndOrient ($modCore + $seg + "BtmGuideClstrGrp")`;
			
			pointConstraint -mo  $btmSegPosAttach ($modCore + $seg + "BtmGuideClstrGrp");
			orientConstraint -mo $btmSegRotAttach ($modCore + $seg + "BtmGuideClstrGrp");
	
			//CONNECT SCALE TO OF THE CLUSTER GROUPS TO CURVE ATTRIBUTE TO MAKE THE ARM CURVES STRAIGHT	
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "TopClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "BtmClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "TopGuideClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "BtmGuideClstrGrp.scaleX");
			
			//PARENT CLUSTERS
			parent ($modCore + $seg + "TopClstrGrp") ($modCore + $seg + "BtmClstrGrp")
			($modCore + $seg + "TopGuideClstrGrp") ($modCore + $seg + "BtmGuideClstrGrp")
			($modCore + "_curveNodesGrp");
			
			//HIDE CLUSTERS
			setAttr ($modCore + $seg + "TopClstrGrp.v") 0;
			setAttr ($modCore + $seg + "BtmClstrGrp.v") 0;
			setAttr ($modCore + $seg + "TopGuideClstrGrp.v") 0;
			setAttr ($modCore + $seg + "BtmGuideClstrGrp.v") 0;
			
			
			//CREATE NON-FLIP JOINT CHAIN
			select -cl;
			joint -n ($modCore + $seg + $segStart + "_NoRollJnt");
			joint -n ($modCore + $seg + $segEnd + "_NoRollJnt") -p $segLength 0 0;
			setAttr ($modCore + $seg + $segStart + "_NoRollJnt.v") 0;
			setAttr ($modCore + $seg + $segEnd + "_NoRollJnt.v") 0;
			group -n ($modCore + $seg + $segStart + "_NoRollJntGrp") ($modCore + $seg + $segStart + "_NoRollJnt"); 
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoRollJntGrp")`;
			delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoRollJnt")`;
			makeIdentity -apply true -r 1 ($modCore + $seg + $segStart + "_NoRollJnt");
			parentConstraint -mo $segParentStartOrient ($modCore + $seg + $segStart + "_NoRollJntGrp");
			pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoRollJnt");
			select -cl;
			
			//parent ($modCore + $seg + $segEnd + "_NoRollJnt") ($modCore + $seg + $segStart + "_NoRollJnt");
			setAttr (($modCore + $seg + $segEnd + "_NoRollJnt.rotate"), 0, 0, 0);
			setAttr (($modCore + $seg + $segEnd + "_NoRollJnt.jointOrient"), 0, 0, 0);
			$segNoFlipLength = `getAttr ($modCore + $seg + $segEnd + "_NoRollJnt.translateX")`;
			
			//CREATE IK RP HANDLE
			select ($modCore + $seg + $segStart + "_NoRollJnt.rotatePivot") ($modCore + $seg + $segEnd + "_NoRollJnt.rotatePivot") ;
			ikHandle -n ($modCore + $seg + $segStart + "_NoRollIKHandle") -sol ikRPsolver;
			setAttr (($modCore + $seg + $segStart + "_NoRollIKHandle.poleVector"), 0, 0, 0);
			parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segStart + "_NoRollIKHandle");
			
			parent ($modCore + $seg + $segStart + "_NoRollJntGrp") ($modCore + $seg + $segStart + "_NoRollIKHandle") ($modCore + "_curveNodesGrp");
			setAttr ($modCore + $seg + $segStart + "_NoRollIKHandle.v") 0;

			//CREATE TWIST JOINT CHAIN
			select -cl;
			joint -n ($modCore + $seg + $segStart + "_TwistStartJnt");
			setAttr ($modCore + $seg + $segStart + "_TwistStartJnt.v") 0;
			delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistStartJnt")`;
			if ($prfx == "r_" && $limbType == "arm")
			{
				rotate -r -os 0 180 0 ($modCore + $seg + $segStart + "_TwistStartJnt");
			}
			pointConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistStartJnt");
			select -cl;
			
			joint -n ($modCore + $seg + $segStart + "_TwistEndJnt") -p $endPos[0] $endPos[1] $endPos[2];
			setAttr ($modCore + $seg + $segStart + "_TwistEndJnt.v") 0;
			parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistStartJnt");
			setAttr (($modCore + $seg + $segStart + "_TwistEndJnt.jointOrient"), 0, 0, 0);
			$segNoFlipLength = `getAttr ($modCore + $seg + $segStart + "_TwistEndJnt.translateX")`;
			
			group -em -n ($modCore + $seg + $segStart + "_TwistJointsGrp");
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistJointsGrp")`;
			makeIdentity -apply true -t 1 ($modCore + $seg + $segStart + "_TwistJointsGrp");
			parentConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistJointsGrp");
			parent ($modCore + $seg + $segStart + "_TwistStartJnt") ($modCore + $seg + $segStart + "_TwistJointsGrp");
			
			parent ($modCore + $seg + $segStart + "_TwistJointsGrp") ($modCore + "_curveNodesGrp");
			
			
			//CREATE NON-FLIP SETUP FOR WRIST/ANKLE TWIST CTRL
			if ($segInteger == 2)
			{
				//ROLL JOINT CHAIN
				select -cl;
				joint -n ($modCore + $segEnd + "_RollBtmStartJnt");
				setAttr ($modCore + $segEnd + "_RollBtmStartJnt.v") 0;
				group -n ($modCore + $segEnd + "_RollBtmStartJntGrp"); 
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_RollBtmStartJntGrp")`;

				parent ($modCore + $segEnd + "_RollBtmStartJntGrp") ($modCore + $segEnd + "Jnt");
				
				select -cl;
				joint -n ($modCore + $segEnd + "_RollBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_RollBtmEndJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_RollBtmEndJnt")`;
				setAttr (($modCore + $segEnd + "_RollBtmEndJnt.translate"), 2, 0, 0);
				parent ($modCore + $segEnd + "_RollBtmEndJnt") ($modCore + $segEnd + "_RollBtmStartJnt");
				setAttr (($modCore + $segEnd + "_RollBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_RollBtmEndJnt.translate"), 2, 0, 0);				
				
				
				//NO ROLL SINGLE CHAIN RP
				select -cl;
				joint -n ($modCore + $segEnd + "_NoRollBtmStartJnt");
				setAttr ($modCore + $segEnd + "_NoRollBtmStartJnt.v") 0;
				group -n ($modCore + $segEnd + "_NoRollBtmStartJntGrp"); 
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoRollBtmStartJntGrp")`;
				
				select -cl;
				joint -n ($modCore + $segEnd + "_NoRollBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_NoRollBtmEndJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoRollBtmEndJnt")`;
				setAttr (($modCore + $segEnd + "_NoRollBtmEndJnt.translate"), 2, 0, 0);
				parent ($modCore + $segEnd + "_NoRollBtmEndJnt") ($modCore + $segEnd + "_NoRollBtmStartJnt");
				setAttr (($modCore + $segEnd + "_NoRollBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_NoRollBtmEndJnt.translate"), 2, 0, 0);
				
				//CREATE IK RP HANDLE
				select ($modCore + $segEnd + "_NoRollBtmStartJnt.rotatePivot") ($modCore + $segEnd + "_NoRollBtmEndJnt.rotatePivot") ;
				ikHandle -n ($modCore + $segEnd + "_NoRollBtmIKHandle") -sol ikRPsolver;
				setAttr (($modCore + $segEnd + "_NoRollBtmIKHandle.poleVector"), 0, 0, 0);
				parent ($modCore + $segEnd + "_NoRollBtmIKHandle") ($modCore + $segEnd + "_RollBtmEndJnt");
				//parentConstraint -mo ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoRollBtmIKHandle");
				
				//parent ($modCore + $segEnd + "_NoRollBtmStartJntGrp") /*($modCore + $seg + $segStart + "_NoRollIKHandle")*/ ($modCore + $seg + "_TwistCtrlGrp");
				parent ($modCore + $seg + $segStart + "_NoRollIKHandle") ($modCore + $segEnd + "_RollBtmStartJntGrp");
				
				//SPLINE JOINT CHAIN
				select -cl;
				joint -n ($modCore + $segEnd + "_SplineIKBtmStartJnt");
				group -n ($modCore + $segEnd + "_SplineIKBtmStartJntGrp");
				parent ($modCore + $segEnd + "_SplineIKBtmStartJntGrp") ($modCore + "_ScaleGrp");
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIKBtmStartJntGrp")`;

				parentConstraint -mo ($modCore + $segEnd + "JntDummy") ($modCore + $segEnd + "_SplineIKBtmStartJntGrp");

				select -cl;
				
				joint -n ($modCore + $segEnd + "_SplineIKBtmRollValJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_SplineIKBtmRollValJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIKBtmRollValJnt")`;
				parent ($modCore + $segEnd + "_SplineIKBtmRollValJnt") ($modCore + $segEnd + "_SplineIKBtmStartJnt");
				setAttr (($modCore + $segEnd + "_SplineIKBtmRollValJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIKBtmRollValJnt.rotate"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIKBtmRollValJnt.translate"), (1), 0, 0);
				
				select -cl;
				joint -n ($modCore + $segEnd + "_SplineIKBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_SplineIKBtmEndJnt.v") 0; //-p $endPos[0] $endPos[1] $endPos[2];
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIKBtmEndJnt")`;
				parent ($modCore + $segEnd + "_SplineIKBtmEndJnt") ($modCore + $segEnd + "_SplineIKBtmRollValJnt");
				setAttr (($modCore + $segEnd + "_SplineIKBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIKBtmEndJnt.translate"), (1), 0, 0);
				
				//CREATE SPLINE IK HANDLE
				select ($modCore + $segEnd + "_SplineIKBtmStartJnt.rotatePivot") ($modCore + $segEnd + "_SplineIKBtmEndJnt.rotatePivot");
				ikHandle -n  ($modCore + $segEnd + "_SplineIKBtmIKHandle") -sol ikSplineSolver;
				$splineIKCurve = `listConnections -s 1 -d 0 -type "nurbsCurve" ($modCore + $segEnd + "_SplineIKBtmIKHandle")`;
				rename $splineIKCurve ($modCore + $segEnd + "_SplineIKBtmIKCurve");
					
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.dTwistControlEnable") 1;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpType") 4;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpAxis") 3;
				setAttr (($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpVector"), 0, 0, 1);
				setAttr (($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpVectorEnd"), 0, 0, 1);
				
				//FIRST ROTATION LOCATOR
				spaceLocator -n ($modCore + $segEnd + "_SplineIKUpLctr1");
				parent ($modCore + $segEnd + "_SplineIKUpLctr1") ($modCore + "_ScaleGrp");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr1.inheritsTransform") 0;
				parentConstraint ($modCore + $segEnd + "_NoRollBtmStartJnt") ($modCore + $segEnd + "_SplineIKUpLctr1");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr1_parentConstraint1.interpType") 2;

				//SECOND ROTATION LOCATOR
				spaceLocator -n ($modCore + $segEnd + "_SplineIKUpLctr2");
				parent ($modCore + $segEnd + "_SplineIKUpLctr2") ($modCore + "_ScaleGrp");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr2.inheritsTransform") 0;
				parentConstraint ($modCore + $segEnd + "_RollBtmStartJnt") ($modCore + $segEnd + "_SplineIKUpLctr2");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr2_parentConstraint1.interpType") 2;

				connectAttr -f ($modCore + $segEnd + "_SplineIKUpLctr1.xformMatrix") ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpMatrix");
				connectAttr -f ($modCore + $segEnd + "_SplineIKUpLctr2.xformMatrix") ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpMatrixEnd");

				parent ($modCore + $segEnd + "_SplineIKBtmIKHandle") ($modCore + $segEnd + "_NoRollBtmStartJntGrp");
				parent ($modCore + $segEnd + "_SplineIKBtmIKCurve") ($modCore + $segEnd + "_RollBtmStartJntGrp");

				//HIDE AND LOCK ATTRIBUTES
				setAttr ($modCore + $segEnd + "_NoRollBtmStartJnt.v") 0;
				setAttr ($modCore + $segEnd + "_RollBtmStartJnt.v") 0;
				setAttr ($modCore + $segEnd + "_NoRollBtmIKHandle.v") 0;
				setAttr ($modCore + $segEnd + "_SplineIKBtmStartJnt.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr1.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr2.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKCurve.visibility") 0;
			}
	
	
			//////////////////////////////////////////////////////////////////////////////
			////////////////////////////CREATE ARM ROLL JOINTS////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
		
			$rollProxies = `ls ("RRM_" + $prfx + $core + $seg + "?")`;
			$sizeRollProxies = `size $rollProxies`;
			int $rpNum = 1;
			for ($eachRP in $rollProxies)
			{//CREATE TWIST JOINTS
				$rpNumRev = (($sizeRollProxies + 1) - $rpNum);
				
				//EXTRA TWIST JOINTS
				float $rpNumFloat = $rpNum;
				float $sizeRollProxiesFloat = $sizeRollProxies;
				
				duplicate -n ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum) ($modCore + $seg + $segStart + "_TwistEndJnt");
				float $noFlipSpacing = ($segNoFlipLength /($sizeRollProxiesFloat + 1));
				setAttr ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum + ".translateX") $noFlipSpacing;
				parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum);
				
				if ($rpNum == $sizeRollProxies)
				{
					//ADD TWIST
					//CREATE TWIST CONTROLS
					if ($segInteger == 1)
					{
						circle -n ($modCore + $seg + "_TwistCtrl") -c 0 0 0 -nr 0 1 0 -sw 45 -r 0.8 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;
						rotate -r 0 -22.5 0 ($modCore + $seg + "_TwistCtrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_TwistCtrl");
						curve -n ($modCore + $seg + $segStart + "_WedgeCtrl") -d 1 -p -0.306147 0 -0.739104 -p 0 0 -0.432436 -p 0.306147 0 -0.739104 -k 0 -k 1 -k 2 ;
						pickWalk -d down;
						rename ($modCore + $seg + $segStart + "_WedgeCtrlShape");
						curve -n ($modCore + $seg + $segStart + "_lineCtrl") -d 1 -p 0 0 -0.432436 -p 0 0 0 -k 0 -k 1 ;
						pickWalk -d down;
						rename ($modCore + $seg + $segStart + "_lineCtrlShape");
						parent -r -s ($modCore + $seg + $segStart + "_WedgeCtrlShape") ($modCore + $seg + $segStart + "_lineCtrlShape") ($modCore + $seg + "_TwistCtrl");
						delete ($modCore + $seg + $segStart + "_WedgeCtrl") ($modCore + $seg + $segStart + "_lineCtrl");
						setAttr (($modCore + $seg + "_TwistCtrl.rotate"), 0, -90, (90*$multiplier));
						setAttr (($modCore + $seg + "_TwistCtrl.scale"), ($limbLength/2), ($limbLength/2), ($limbLength/2));
						makeIdentity -apply true -r 1 -s 1 ($modCore + $seg + "_TwistCtrl");
						connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "Twist") ($modCore + $seg + "_TwistCtrl.v");				
						spaceLocator -n ($modCore + $seg + $segEnd + "_TwistLctr");
						group -n ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + "_TwistCtrl"); xform -os -piv 0 0 0;
						setAttr ($modCore + $seg + "_TwistCtrlGrp.rotateOrder") 1;
						group -n ($modCore + $seg + $segStart + "_TwistGrp") ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + $segEnd + "_TwistLctr"); xform -os -piv 0 0 0;
						
						parent ($modCore + $seg + $segStart + "_TwistGrp") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $seg + $segEnd + "_TwistLctr.v") 0;
						
						delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistGrp")`;
						orientConstraint -mo ($modCore + $shoulder + $FKCtrlGrp) ($modCore + $seg + $segStart + "_TwistGrp");
						pointConstraint -mo ($modCore + $shoulder + "FKCtrl") ($modCore + $seg + $segStart + "_TwistGrp");
						orientConstraint -mo ($modCore + $seg + $segStart + "_NoRollJnt") ($modCore + $seg + "_TwistCtrlGrp");
						parentConstraint $ikSplineUpObject2 ($modCore + $seg + $segEnd + "_TwistLctr");
					}
					else if ($segInteger == 2)
					{
						circle -n ($modCore + $seg + "_TwistCtrl") -c 0 0 0 -nr 0 1 0 -sw 45 -r 0.8 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;
						rotate -r 0 -22.5 0 ($modCore + $seg + "_TwistCtrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_TwistCtrl");
						curve -n ($modCore + $seg + $segEnd + "_WedgeCtrl") -d 1 -p -0.306147 0 -0.739104 -p 0 0 -0.432436 -p 0.306147 0 -0.739104 -k 0 -k 1 -k 2 ;
						pickWalk -d down;
						rename ($modCore + $seg + $segEnd + "_WedgeCtrlShape");
						curve -n ($modCore + $seg + $segEnd + "_lineCtrl") -d 1 -p 0 0 -0.432436 -p 0 0 0 -k 0 -k 1 ;
						pickWalk -d down;
						rename ($modCore + $seg + $segEnd + "_lineCtrlShape");
						parent -r -s ($modCore + $seg + $segEnd + "_WedgeCtrlShape") ($modCore + $seg + $segEnd + "_lineCtrlShape") ($modCore + $seg + "_TwistCtrl");
						delete ($modCore + $seg + $segEnd + "_WedgeCtrl") ($modCore + $seg + $segEnd + "_lineCtrl");
						setAttr (($modCore + $seg + "_TwistCtrl.rotate"), 0, -90, (90*$multiplier));
						setAttr (($modCore + $seg + "_TwistCtrl.scale"), ($limbLength/2.5), ($limbLength/2.5), ($limbLength/2.5));
						makeIdentity -apply true -r 1 -s 1 ($modCore + $seg + "_TwistCtrl");
						connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "Twist") ($modCore + $seg + "_TwistCtrl.v");				
						spaceLocator -n ($modCore + $seg + $segEnd + "_TwistLctr");
						group -n ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + "_TwistCtrl"); xform -os -piv 0 0 0;
						setAttr ($modCore + $seg + "_TwistCtrlGrp.rotateOrder") 1;
						group -n ($modCore + $seg + $segEnd + "_TwistGrp") ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + $segEnd + "_TwistLctr"); xform -os -piv 0 0 0;
						
						parent ($modCore + $seg + $segEnd + "_TwistGrp") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $seg + $segEnd + "_TwistLctr.v") 0;
						
						delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp")`;
						pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp");
						parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + $segStart + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp");
						connectAttr -f ($modCore + $segEnd + "_SplineIKBtmRollValJnt.rotateX") ($modCore + $seg + "_TwistCtrlGrp.rotateX");
						parentConstraint $ikSplineUpObject2 ($modCore + $seg + $segEnd + "_TwistLctr");
					}
					
					if (`objExists ($modCore + $segEnd + "_NoRollBtmStartJntGrp")`)
					{
						parent ($modCore + $segEnd + "_NoRollBtmStartJntGrp") ($modCore + $segEnd + "_SplineIKBtmStartJntGrp") ($modCore + $seg + $segEnd + "_TwistGrp");
					}
					
					if ($limbType == "leg" && $crntSide == "right" && `objExists ($modCore + $seg + "_TwistCtrl")`)
					{
						rotate -r 180 0 0  ($modCore + $seg + "_TwistCtrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_TwistCtrl");
					}
					if (`objExists ($modCore + $seg + "_TwistCtrl")`)
					{
						setAttr -lock true -keyable false -channelBox false ($modCore + $seg + "_TwistCtrl.tx");
						setAttr -lock true -keyable false -channelBox false ($modCore + $seg + "_TwistCtrl.ty");
						setAttr -lock true -keyable false -channelBox false ($modCore + $seg + "_TwistCtrl.tz");
						setAttr -lock true -keyable false -channelBox false ($modCore + $seg + "_TwistCtrl.sx");
						setAttr -lock true -keyable false -channelBox false ($modCore + $seg + "_TwistCtrl.sy");
						setAttr -lock true -keyable false -channelBox false ($modCore + $seg + "_TwistCtrl.sz");
						setAttr -lock true -keyable false -channelBox false ($modCore + $seg + "_TwistCtrl.v");
					}
					
					spaceLocator -n ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr");
					spaceLocator -n ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr");
					parentConstraint $segStartUpOrientControl ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr");
					parentConstraint $segEndUpOrientControl ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr");
					
					parent ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr") ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr") ($modCore + "Grp");
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr.v") 0;
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr.v") 0;
					
					
					//SPLINE SETUP/////
					//CREATE ONE EXTRA JOINT TO BETTER DISTRIBUTE THE ROLL
					duplicate -n ($modCore + $seg + $segStart + "_TwistJointExtraJnt") ($modCore + $seg + $segStart + "_TwistEndJnt");
					setAttr ($modCore + $seg + $segStart + "_TwistJointExtraJnt.v") 0;
					float $noFlipSpacing = ($segNoFlipLength /(($sizeRollProxiesFloat + 1)*2));
					setAttr ($modCore + $seg + $segStart + "_TwistJointExtraJnt" + ".translateX") $noFlipSpacing;
					parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistJointExtraJnt");
					
					//SPLINE IK
					select ($modCore + $seg + $segStart + "_TwistStartJnt.rotatePivot") ($modCore + $seg + $segStart + "_TwistEndJnt.rotatePivot") ;
					ikHandle -n ($modCore + $seg + $segStart + "_TwistSplineIKHandle") -sol ikSplineSolver;
					$splineIKCurve = `listConnections -s 1 -d 0 -type "nurbsCurve" ($modCore + $seg + $segStart + "_TwistSplineIKHandle")`;
					rename $splineIKCurve ($modCore + $seg + $segStart + "_TwistSplineIKCurve");
					parentConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistSplineIKCurve");
					
					parent ($modCore + $seg + $segStart + "_TwistSplineIKHandle") ($modCore + "_curveNodesGrp");
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKHandle.v") 0;
	
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dTwistControlEnable") 1;
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dWorldUpType")  4;
	
					connectAttr -f ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr.xformMatrix") ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dWorldUpMatrix");
					connectAttr -f ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr.xformMatrix") ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dWorldUpMatrixEnd");

					addAttr -ln "nonControl"  -dt "string" ($modCore + $seg + $segStart + "_TwistSplineIKCurve");
					setAttr -e-keyable true ($modCore + $seg + $segStart + "_TwistSplineIKCurve.nonControl");
					setAttr -lock true ($modCore + $seg + $segStart + "_TwistSplineIKCurve.nonControl");

					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKCurve.v") 0;
					
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.tx");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.ty");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.tz");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.rx");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.ry");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.rz");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.sx");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.sy");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.sz");
					setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.v");
				}
				
				////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////
				//INDIVIDUAL ARM JOINTS AND CONTROLS
				////////////////////////////////////////////////////////////////////////////////////////////////
				circle -n ($modCore + $seg + "_Curve" + $rpNum + "Cb") -c 0 0 2.5 -nr 1 0 0 -sw 360 -r 0.5 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
				circle -n ($modCore + $seg + "_Curve" + $rpNum + "Cc") -c 0 0 -2.5 -nr 1 0 0 -sw 360 -r 0.5 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
				curve -n  ($modCore + $seg + "_Curve" + $rpNum + "Ctrl") -d 1 -p 0 0 -2 -p 0 0 2 -k 0 -k 1 ;
				pickWalk -d down;
				rename ($modCore + $seg + "_Curve" + $rpNum + "CtrlShape");
	
				parent -r -s ($modCore + $seg + "_Curve" + $rpNum + "CbShape") ($modCore + $seg + "_Curve" + $rpNum + "CcShape") ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
				delete ($modCore + $seg + "_Curve" + $rpNum + "Cb") ($modCore + $seg + "_Curve" + $rpNum + "Cc");
				
				setAttr ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.rotateOrder") 1;
				connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMicro") ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.v");
				setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.v");
				
	
				scale -r ($segLength/6) ($segLength/6) ($segLength/6) ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
				delete -ch ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
					
				group -n ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp") ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
				setAttr ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp.rotateOrder") 1;
				
				connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp.scale");
				parent ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp") ($modCore + "_extraCurveNodesGrp");
				
				select -cl;
				joint -n ($modCore + $seg + "_Curve" + $rpNum + "Jnt");
				parentConstraint ($modCore + $seg + "_Curve" + $rpNum + "Ctrl") ($modCore + $seg + "_Curve" + $rpNum + "Jnt");
				
				shadingNode -asUtility multiplyDivide -n ($modCore + $seg + "_Curve" + $rpNum + "JntMD");
				connectAttr -f ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.scale") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input1");
				connectAttr -f ($modCore + $segStart + "JntIKFK_BlndScale.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2X");
				connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2Y");
				connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2Z");

				connectAttr -f ($modCore + $seg + "_Curve" + $rpNum + "JntMD.output") ($modCore + $seg + "_Curve" + $rpNum + "Jnt.scale");
				
				parent ($modCore + $seg + "_Curve" + $rpNum + "Jnt") ($modCore + "_curveNodesGrp");
	
				//ATTACH TO PATH
				float $segDivider = ($sizeRollProxies + 1);
				float $percentage = ($rpNumFloat/$segDivider);
	
				//NO FLIP JOINTS UP
				pathAnimation -n ($modCore + $seg + "" + $rpNum + "_MP") -fractionMode true -followAxis x -upAxis y-worldUpType "objectrotation"
				-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum) ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp") ($modCore + $seg + "CurveAttach");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $seg + "" + $rpNum + "_MP");
				setAttr ($modCore + $seg + "" + $rpNum + "_MP.uValue") $percentage;
				
				//MOVE CURVE AND JOINT TO THE PROXY
				delete `pointConstraint ("RRM_" + $prfx + $core + $seg + $rpNum) ($modCore + $seg + "_Curve" + $rpNum + "Ctrl")`;
				makeIdentity -apply true -t 1 ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
	
				select -cl;
				$rpNum++;
			}//CREATE TWIST JOINTS
			
			//CREATE TOP CURVE JOINT
			if (!`objExists ($modCore + $segStart + "_CurveJnt")`)
			{
				select -cl;
				joint -n ($modCore + $segStart + "_CurveJnt");
				delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveJnt")`;
				makeIdentity -apply true -r 1 ($modCore + $segStart + "_CurveJnt");
				if ($segInteger == 1)
				{
					//TARGET LOCATOR
					spaceLocator -n ($modCore + $segStart + "_CurveJnt_AimLctr");
					group -n ($modCore + $segStart + "_CurveJnt_AimLctrGrp");
					pathAnimation -n ($modCore + $segStart + "_CurveJnt_AimLctr_MP") -fractionMode true -followAxis x -upAxis y-worldUpType "objectrotation"
					-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $seg + $segStart + "_NoRollJnt") ($modCore + $segStart + "_CurveJnt_AimLctrGrp") ($modCore + $seg + "CurveAttach");
					cutKey -cl -t ":" -f ":" -at "u" ($modCore + $segStart + "_CurveJnt_AimLctr_MP");
					setAttr ($modCore + $segStart + "_CurveJnt_AimLctr_MP.uValue") 0.002;
					
					parent ($modCore + $segStart + "_CurveJnt_AimLctrGrp") ($modCore + "_extraCurveNodesGrp");
					setAttr ($modCore + $segStart + "_CurveJnt_AimLctrGrp.v") 0;
					
					pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveJnt");
					aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
					-worldUpVector 0 1 0 -worldUpObject ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr") ($modCore + $segStart + "_CurveJnt_AimLctr") ($modCore + $segStart + "_CurveJnt");

					connectAttr -f ($modCore + $segStart + "JntIKFK_BlndScale.outputR") ($modCore + $segStart + "_CurveJnt.scaleX");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJnt.scaleY");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJnt.scaleZ");
				}
				else
				{
					parentConstraint ($modCore + $segStart + "_CurveCtrl") ($modCore + $segStart + "_CurveJnt");
					shadingNode -asUtility multiplyDivide -n ($modCore + $segStart + "_CurveJntMD");
					connectAttr -f ($modCore + $segStart + "_CurveCtrl.scale") ($modCore + $segStart + "_CurveJntMD.input1");
					connectAttr -f ($modCore + $segStart + "JntIKFK_BlndScale.outputR") ($modCore + $segStart + "_CurveJntMD.input2X");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJntMD.input2Y");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJntMD.input2Z");
	
					connectAttr -f ($modCore + $segStart + "_CurveJntMD.output") ($modCore + $segStart + "_CurveJnt.scale");
				}
				parent ($modCore + $segStart + "_CurveJnt") ($modCore + "_curveNodesGrp");
			}
			//CREATE BOTTOM CURVE JOINT
			if (($segInteger != 2) && (!`objExists ($modCore + $segEnd + "_CurveJnt")`))
			{
				select -cl;
				joint -n ($modCore + $segEnd + "_CurveJnt");
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveJnt")`;
				makeIdentity -apply true -r 1 ($modCore + $segEnd + "_CurveJnt");
				if ($segInteger == 1)
				{				
					parentConstraint ($modCore + $segEnd + "_CurveCtrl") ($modCore + $segEnd + "_CurveJnt");
				}
				else
				{
					parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveJnt");
				}
				shadingNode -asUtility multiplyDivide -n ($modCore + $segEnd + "_CurveJntMD");
				connectAttr -f ($modCore + $segEnd + "_CurveCtrl.scale") ($modCore + $segEnd + "_CurveJntMD.input1");
				connectAttr -f ($modCore + $segEnd + "JntIKFK_BlndScale.outputR") ($modCore + $segEnd + "_CurveJntMD.input2X");
				connectAttr -f ($modCore + $segEnd + "JntIKFK_AutoBlnd.outputR") ($modCore + $segEnd + "_CurveJntMD.input2Y");
				connectAttr -f ($modCore + $segEnd + "JntIKFK_AutoBlnd.outputR") ($modCore + $segEnd + "_CurveJntMD.input2Z");

				connectAttr -f ($modCore + $segEnd + "_CurveJntMD.output") ($modCore + $segEnd + "_CurveJnt.scale");

				parent ($modCore + $segEnd + "_CurveJnt") ($modCore + "_curveNodesGrp");
			}
	    }//CREATE JOINTS AND CONTROLS FOR EACH PROXY
	    else
	    {//CREATE CONNECTOR LINES ONLY
			//CREATE GUIDE SPLINE CURVES FOR MACRO CONTROL ATTACHMENT
			curve -n ($modCore + $seg + "CurveAttach") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1 ;
			pickWalk -d down;
			rename ($modCore + $seg + "CurveAttachShape");
			delete -ch ($modCore + $seg + "CurveAttach");
			
			//CREATE CLUSTERS FOR EACH END
			select ($modCore + $seg + "CurveAttach.cv[0]");
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopGuideClstr");
			
			pointConstraint  ($modCore + $segStart + "Jnt") ($modCore + $seg + "TopGuideClstr");
			
			select ($modCore + $seg + "CurveAttach.cv[1]");
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmGuideClstr");
						
			pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmGuideClstr");

			parent ($modCore + $seg + "CurveAttach") ($modCore + "_extraCurveNodesGrp");
			setAttr ($modCore + $seg + "CurveAttach.template") 1;
			
			parent ($modCore + $seg + "TopGuideClstr") ($modCore + $seg + "BtmGuideClstr") ($modCore + "_curveNodesGrp");
			setAttr ($modCore + $seg + "TopGuideClstr.v") 0;
			setAttr ($modCore + $seg + "BtmGuideClstr.v") 0;
				
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.tx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.ty");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.tz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.rx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.ry");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.rz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.sx");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.sy");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.sz");
			setAttr -lock 1 -keyable 0 -channelBox 0 ($modCore + $seg + "CurveAttach.v");
	    }
		$segInteger ++;
	}
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE ARM MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRigArm(string $modName, string $moduleName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	int $inverseFront = 0;
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}

	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;

	//ARM
	while ($i !=2)
	{
		if (!`objExists ($topNode + ".pair")`)
		{
			$prfx = "";
			$oppPrfx = "";
			select $topNode;
			
			$crntSide = `getAttr ($topNode + ".single")`;
			if ($crntSide == "right")
			{
				$multiplier = -1;
				$inverseFront = 1;
			}
		}
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "arm";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFICtrl ATTRIBUTES
		//UPPER ROLL JOINTS
		int $sizeUpperCJnt = 0;
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
			$sizeUpperCJnt = `size $UpperCJnt`;
		}
		addAttr -ln "upperRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.upperRoll") ;
		setAttr -type "string" ($modCore + "Grp.upperRoll") $sizeUpperCJnt;
		setAttr -l true ($modCore + "Grp.upperRoll");
		
		int $sizeLowerCJnt = 0;
		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$LowerCJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
			$sizeLowerCJnt = `size $LowerCJnt`;
		}
		addAttr -ln "lowerRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.lowerRoll") ;
		setAttr -type "string" ($modCore + "Grp.lowerRoll") $sizeLowerCJnt;
		setAttr -l true ($modCore + "Grp.lowerRoll");
	
	
		addAttr -ln "elbowNum"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.elbowNum") ;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr -type "string" ($modCore + "Grp.elbowNum") "1";
		}
		else
		{
			setAttr -type "string" ($modCore + "Grp.elbowNum") "2";
		}		
		setAttr -l true ($modCore + "Grp.elbowNum");
		
	
		int $sizeMiddleCJnt = 0;
		if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
		{
			$MiddleCJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
			$sizeMiddleCJnt = `size $MiddleCJnt`;
		}
		addAttr -ln "midRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.midRoll") ;
		setAttr -type "string" ($modCore + "Grp.midRoll") $sizeMiddleCJnt;
		setAttr -l true ($modCore + "Grp.midRoll");
		
		
	
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
		
		
		//CONTROLS
		
		//SCALE
		float $ArmLength;
		float $elbowLength[];
		float $elbow1Length[];
		float $elbow2Length[];
		float $WristLength[];
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_EndLctr")`;
			$elbowLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_EndLctr")`;
			$WristLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			$ArmLength = (($elbowLength[0] + $WristLength[0]) /2);
			delete ($modCore + "_StartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_EndLctr")`;
			$elbow1Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_EndLctr")`;
			$elbow2Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_EndLctr")`;
			$WristLength = `xform -q -t ($modCore + "_EndLctr")`;

			$ArmLength = (($elbow1Length[0] + $elbow2Length[0]) /2);
			delete ($modCore + "_StartLctr");
		}	

		//CLAVICLE CONTROL
		circle -n ($modCore + "_ClavicleCtrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
		delete -ch ($modCore + "_ClavicleCtrl");
		setAttr ($modCore + "_ClavicleCtrl.rotateOrder") 1;
		move -r ($multiplier * 1.35) 2 0 ($modCore + "_ClavicleCtrl.cv[3]") ($modCore + "_ClavicleCtrl.cv[7]") ;
		move -r ($multiplier * 0.5) 1.25 0 ($modCore + "_ClavicleCtrl.cv[2]") ($modCore + "_ClavicleCtrl.cv[4]") ($modCore + "_ClavicleCtrl.cv[0]") ($modCore + "_ClavicleCtrl.cv[6]") ;
		group -n ($modCore + "_ClavicleCtrlGrp") ($modCore + "_ClavicleCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_ClavicleCtrlGrp.rotateOrder") 1;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ClavicleCtrlGrp")`;
		
		setAttr (($modCore + "_ClavicleCtrlGrp.scale"), (($ArmLength/2) * 0.4), (($ArmLength/2) * 1), (($ArmLength/2) * 1.25));
		
		makeIdentity -apply true -t 0 -s 1 ($modCore + "_ClavicleCtrlGrp");
		
		//SHOULDER FK CONTROL
		circle -n ($modCore + "_ShoulderFKCtrl") -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
		delete -ch ($modCore + "_ShoulderFKCtrl");
		setAttr ($modCore + "_ShoulderFKCtrl.rotateOrder") 1;
		group -n ($modCore + "_ShoulderFKCtrlGrp") ($modCore + "_ShoulderFKCtrl");
		group -n ($modCore + "_ShoulderFKCtrlGrp2") ($modCore + "_ShoulderFKCtrlGrp");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_ShoulderFKCtrlGrp2")`;
		float $upVector = 1;
		float $elbowLocCheck;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			$elbowLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Elbow.translateZ")`;
		}
		else
		{
			$elbowLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Elbow1.translateZ")`;
		}
		if ($elbowLocCheck > 0.0001)
		{
			$upVector = -1;
		}
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow")
			("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ShoulderFKCtrlGrp2")`;
		}
		else
		{
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow1")
			("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_ShoulderFKCtrlGrp2")`;
		}
		
	
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_ShoulderFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_ShoulderFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_ShoulderFKCtrl");
		
		setAttr (($modCore + "_ShoulderFKCtrl.scale"), ($ArmLength/2), ($ArmLength/2), ($ArmLength/2));
		makeIdentity -apply true -s 1 ($modCore + "_ShoulderFKCtrlGrp2");
			
		//ELBOW FK CONTROL
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			duplicate -n ($modCore + "_ElbowFKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
			parent -w ($modCore + "_ElbowFKCtrlGrp");
			select ($modCore + "_ElbowFKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_ElbowFKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ElbowFKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
			-worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_ElbowFKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_ElbowFKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_ElbowFKCtrlGrp");
		}
		else
		{
			duplicate -n ($modCore + "_Elbow1FKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
			parent -w ($modCore + "_Elbow1FKCtrlGrp");
			select ($modCore + "_Elbow1FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Elbow1FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_Elbow1FKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
			-worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow1")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_Elbow1FKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_Elbow1FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Elbow1FKCtrlGrp");
			
			duplicate -n ($modCore + "_Elbow2FKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
			parent -w ($modCore + "_Elbow2FKCtrlGrp");
			select ($modCore + "_Elbow2FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Elbow2FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_Elbow2FKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_Elbow2FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Elbow2FKCtrlGrp");
		}

		//WRIST FK CONTROL
		duplicate -n ($modCore + "_WristFKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
		parent -w ($modCore + "_WristFKCtrlGrp");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_WristFKCtrlGrp")`;
		scale -r 0.8 0.8 0.8 ($modCore + "_WristFKCtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_WristFKCtrlGrp");
		select ($modCore + "_WristFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_WristFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_WristFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_WristFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_WristFKCtrl");
	
	
		//////////////////////JOINTS//////////////////////
		select -cl;
		joint -n ($modCore + "_ClavicleJnt");
		setAttr ($modCore + "_ClavicleJnt.rotateOrder") 1;
		delete `parentConstraint ($modCore + "_ClavicleCtrl") ($modCore + "_ClavicleJnt")`;
		
		select -cl;
		joint -n ($modCore + "_ShoulderJnt");
		setAttr ($modCore + "_ShoulderJnt.rotateOrder") 1;
		delete `parentConstraint ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJnt")`;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -cl;
			joint -n ($modCore + "_ElbowJnt");
			setAttr ($modCore + "_ElbowJnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_ElbowFKCtrl") ($modCore + "_ElbowJnt")`;
		
			select -cl;
			joint -n ($modCore + "_WristJnt");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJnt")`;
			select -cl;
			joint -n ($modCore + "_WristJntDummy");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_ClavicleJnt") ($modCore + "_ShoulderJnt")
			($modCore + "_ElbowJnt") ($modCore + "_WristJnt") ($modCore + "_WristJntDummy");
			
			parent ($modCore + "_ShoulderJnt") ($modCore + "_ClavicleJnt");
			parent ($modCore + "_ElbowJnt")  ($modCore + "_ShoulderJnt");
			parent ($modCore + "_WristJnt") ($modCore + "_ElbowJnt");
			parent ($modCore + "_WristJntDummy") ($modCore + "_ElbowJnt");
		}
		else
		{
			select -cl;
			joint -n ($modCore + "_Elbow1Jnt");
			setAttr ($modCore + "_Elbow1Jnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_Elbow1FKCtrl") ($modCore + "_Elbow1Jnt")`;
		
			select -cl;
			joint -n ($modCore + "_Elbow2Jnt");
			setAttr ($modCore + "_Elbow2Jnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_Elbow2FKCtrl") ($modCore + "_Elbow2Jnt")`;
	
			select -cl;
			joint -n ($modCore + "_WristJnt");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJnt")`;
			select -cl;
			joint -n ($modCore + "_WristJntDummy");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_ClavicleJnt") ($modCore + "_ShoulderJnt")
			($modCore + "_Elbow1Jnt") ($modCore + "_Elbow2Jnt") ($modCore + "_WristJnt") ($modCore + "_WristJntDummy");
	
			parent ($modCore + "_ShoulderJnt") ($modCore + "_ClavicleJnt");
			parent ($modCore + "_Elbow1Jnt")  ($modCore + "_ShoulderJnt");
			parent ($modCore + "_Elbow2Jnt") ($modCore + "_Elbow1Jnt"); 
			parent ($modCore + "_WristJnt") ($modCore + "_Elbow2Jnt");
			parent ($modCore + "_WristJntDummy") ($modCore + "_Elbow2Jnt");
		}
		//HIDE WRIST DUMMY 
		setAttr ($modCore + "_WristJntDummy.v") 0;
		//ELBOW ORIENTATION
		if (`objExists ($modCore + "_ElbowJnt")`)
		{
			if ($elbowLocCheck > 0.0001)
			{
				setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * 60);
			}
			else
			{
				setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * -60);
			}
			group -em -n ($modCore + "_WristJntGrp1");
			pointConstraint ($modCore + "_WristJntDummy") ($modCore + "_WristJntGrp1");
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1")`;
			group -em -n ($modCore + "_WristJntGrp2") ;
			delete `pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_WristJntGrp2")`;
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp2")`;	
			parentConstraint -mo ($modCore + "_ElbowJnt") ($modCore + "_WristJntGrp2");
		}
		else
		{
			if ($elbowLocCheck > 0.0001)
			{
				setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * 30);
			}
			else
			{
				setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * -30);
			}
			group -em -n ($modCore + "_WristJntGrp1");
			pointConstraint ($modCore + "_WristJntDummy") ($modCore + "_WristJntGrp1");
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1")`;
			group -em -n ($modCore + "_WristJntGrp2") ;
			delete `pointConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_WristJntGrp2")`;
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp2")`;	
			parentConstraint -mo ($modCore + "_Elbow2Jnt") ($modCore + "_WristJntGrp2");
		}
		parent ($modCore + "_WristJntGrp1") ($modCore + "_WristJntGrp2");
		parent ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1");	
	
		
		
		////////////////////IK/FK JOINTS////////////////////////////////////	
		//ARM FK
		duplicate -n ($modCore + "_ShoulderJntFK") ($modCore + "_ShoulderJnt");
		select ($modCore + "_ShoulderJntFK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			rename ($modCore + "_ElbowJntFK");
			pickWalk -d down;
			rename ($modCore + "_WristJntFK");
		}
		else
		{
			rename ($modCore + "_Elbow1JntFK");
			pickWalk -d down;
			rename ($modCore + "_Elbow2JntFK");
			pickWalk -d down;
			rename ($modCore + "_WristJntFK");
		}
		
		//ARM IK
		duplicate -n ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderJnt");
		select ($modCore + "_ShoulderJntIK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			rename ($modCore + "_ElbowJntIK");
			pickWalk -d down;
			rename ($modCore + "_WristJntIK");
		}
		else
		{
			rename ($modCore + "_Elbow1JntIK");
			pickWalk -d down;
			rename ($modCore + "_Elbow2JntIK");
			pickWalk -d down;
			rename ($modCore + "_WristJntIK");
		}	
	
		//DETACH FK ARM JOINTS FOR SCALE COMPENSATION
	
		parent -w ($modCore + "_WristJntFK");
		group -n ($modCore + "_WristJntFKGrp1") ($modCore + "_WristJntFK");
		group -n ($modCore + "_WristJntFKGrp2") ($modCore + "_WristJntFKGrp1");
		$WristLocation = `xform -q -ws -t ($modCore + "_WristJnt")`;
		move $WristLocation[0] $WristLocation[1] $WristLocation[2] ($modCore + "_WristJntFKGrp2.scalePivot") ($modCore + "_WristJntFKGrp2.rotatePivot") ;
		pointConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJntFKGrp1");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ElbowJntFK") ($modCore + "_WristJntFKGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Elbow2JntFK") ($modCore + "_WristJntFKGrp2");
		}
			
		$elbowLocation = `xform -q -ws -t ($modCore + "_ShoulderJnt")`;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parent -w ($modCore + "_ElbowJntFK") ($modCore + "_WristJntFK");
			group -n ($modCore + "_ElbowJntFKGrp1") ($modCore + "_ElbowJntFK");
			group -n ($modCore + "_ElbowJntFKGrp2") ($modCore + "_ElbowJntFKGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_ElbowJnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_ElbowJntFKGrp1.scalePivot") ($modCore + "_ElbowJntFKGrp1.rotatePivot") ;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_ElbowJntFKGrp2.scalePivot") ($modCore + "_ElbowJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_ElbowFKCtrl") ($modCore + "_ElbowJntFKGrp1");
			parentConstraint -mo ($modCore + "_ShoulderJntFK") ($modCore + "_ElbowJntFKGrp2");
		}
		else
		{
			parent -w ($modCore + "_Elbow1JntFK") ($modCore + "_Elbow2JntFK") ($modCore + "_WristJntFK");
			
			group -n ($modCore + "_Elbow1JntFKGrp1") ($modCore + "_Elbow1JntFK");
			group -n ($modCore + "_Elbow1JntFKGrp2") ($modCore + "_Elbow1JntFKGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_Elbow1Jnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_Elbow1JntFKGrp2.scalePivot") ($modCore + "_Elbow1JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Elbow1FKCtrl") ($modCore + "_Elbow1JntFKGrp1");
			parentConstraint -mo ($modCore + "_ShoulderJntFK") ($modCore + "_Elbow1JntFKGrp2");
	
			group -n ($modCore + "_Elbow2JntFKGrp1") ($modCore + "_Elbow2JntFK");
			group -n ($modCore + "_Elbow2JntFKGrp2") ($modCore + "_Elbow2JntFKGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_Elbow2Jnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_Elbow1JntFKGrp2.scalePivot") ($modCore + "_Elbow1JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Elbow2FKCtrl") ($modCore + "_Elbow2JntFKGrp1");
			parentConstraint -mo ($modCore + "_Elbow1JntFK") ($modCore + "_Elbow2JntFKGrp2");
		}
	
		//IK CONTROLS///////////////////////////////////////////////////////////////		
		circle -n ($modCore + "_WristIKCtrl") -c 0 0 0 -nr 0 1 0 -sw 180 -r 1 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;
		circle -n ($modCore + "_WristIKCtrl2") -c 0 0 0 -nr 0 1 0 -sw 180 -r 1 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;
		rotate -r 0 0 -90 ($modCore + "_WristIKCtrl2");
		circle -n ($modCore + "_WristIKCtrl3") -c 0 0 0 -nr 0 1 0 -sw 90 -r 1 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;
		rotate -r 90 0 0 ($modCore + "_WristIKCtrl3");
		curve -n ($modCore + "_WristIKCtrl4") -d 1 -p 0 0 1 -p 0 0 -1 -k 0 -k 1 ;
		pickWalk -d down;
		rename 	($modCore + "_WristIKCtrl4Shape");
		curve -n ($modCore + "_WristIKCtrl5") -d 1 -p 0 1 0 -p 0 0 0 -p -1 0 0 -k 0 -k 1 -k 2 ;
		pickWalk -d down;
		rename 	($modCore + "_WristIKCtrl5Shape");
		makeIdentity -apply true -r 1 ($modCore + "_WristIKCtrl2") ($modCore + "_WristIKCtrl3") ($modCore + "_WristIKCtrl4") ($modCore + "_WristIKCtrl5");
		parent -r -s  ($modCore + "_WristIKCtrl2Shape") ($modCore + "_WristIKCtrl3Shape") ($modCore + "_WristIKCtrl4Shape") ($modCore + "_WristIKCtrl5Shape") ($modCore + "_WristIKCtrl");
		delete ($modCore + "_WristIKCtrl2") ($modCore + "_WristIKCtrl3") ($modCore + "_WristIKCtrl4") ($modCore + "_WristIKCtrl5");
		if ($crntSide == "left")
		{
			rotate -r -ws 0 180 0 ($modCore + "_WristIKCtrl");
		}
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristIKCtrl"); 
		
		//SCALE CONTROL
		spaceLocator -n ($modCore + "_armLengthAimLctr");
		spaceLocator -n ($modCore + "_armLengthTargetLctr");
		parent ($modCore + "_armLengthTargetLctr") ($modCore + "_armLengthAimLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_armLengthAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_armLengthAimLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_armLengthTargetLctr");
		$armLength = `getAttr ($modCore + "_armLengthTargetLctr.tx")`;
		scale -r ($armLength/4) ($armLength/4) ($armLength/4) ($modCore + "_WristIKCtrl");
		makeIdentity -apply true -s 1 ($modCore + "_WristIKCtrl");
		delete -ch ($modCore + "_WristIKCtrl");
		delete ($modCore + "_armLengthAimLctr");
		
		group -n ($modCore + "_WristIKCtrlGrp") ($modCore + "_WristIKCtrl"); xform -os -piv 0 0 0;
		delete `parentConstraint ($modCore + "_WristJnt") ($modCore + "_WristIKCtrlGrp")`;
		
	
		//ELBOW IK CONTROL
		curve -n ($modCore + "_ElbowIKCtrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
		-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
		-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
		-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
		-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
		-k 23 -k 24 ;
		pickWalk -d down;
		rename ($modCore + "_ElbowIKCtrlShape");
		
		move -r 0 0 0.95 ($modCore + "_ElbowIKCtrl.cv[12]")  ($modCore + "_ElbowIKCtrl.cv[0]") ($modCore + "_ElbowIKCtrl.cv[24]") ($modCore + "_ElbowIKCtrl.cv[18]") ($modCore + "_ElbowIKCtrl.cv[6]") ;
		move -r 0 0 -0.65 ($modCore + "_ElbowIKCtrl.cv[3]") ($modCore + "_ElbowIKCtrl.cv[9]") ($modCore + "_ElbowIKCtrl.cv[15]") ($modCore + "_ElbowIKCtrl.cv[21]") ;
		group -n ($modCore + "_ElbowIKCtrlGrp") ($modCore + "_ElbowIKCtrl");
		
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ElbowIKCtrlGrp")`;
			setAttr (($modCore + "_ElbowIKCtrl.scale"), ($ArmLength / 14), ($ArmLength / 14), ($ArmLength / 14));
			setAttr ($modCore + "_ElbowIKCtrl.tz") ($ArmLength * -2);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKCtrl");
		}
		else
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_ElbowIKCtrlGrp")`;
			setAttr (($modCore + "_ElbowIKCtrl.scale"), ($ArmLength / 14), ($ArmLength / 14), ($ArmLength / 14));
			setAttr ($modCore + "_ElbowIKCtrl.tz") ($ArmLength * -2);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKCtrl");
		}
		
		//LOWER ARM CONTROL
		if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			curve -n ($modCore + "_LowerArmIKCtrl") -d 1 -p -1 0 4 -p -4 0 4 -p -3 0 5 -p -2 0 6 -p -1 0 7 -p 0 0 8 -p 1 0 7 -p 2 0 6 -p 3 0 5 -p 4 0 4 -p 1 0 4 -p 1 0 3 -p 1 0 2 -p 1 0 1 -p 1 0 0 -p 1 0 -1 -p 1 0 -2 -p 1 0 -3 -p 1 0 -4 -p 4 0 -4 -p 3 0 -5 -p 2 0 -6 -p 1 0 -7 -p 0 0 -8 -p -1 0 -7 -p -2 0 -6 -p -3 0 -5 -p -4 0 -4 -p -1 0 -4 -p -1 0 -3 -p -1 0 -2 -p -1 0 -1 -p -1 0 0 -p -1 0 1 -p -1 0 2 -p -1 0 3 -p -1 0 4 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 ;
			pickWalk -d down;
			rename ($modCore + "_LowerArmIKCtrlShape");
			nonLinear -type bend -lowBound -1 -highBound 1 -curvature 0.6;
			$bend = `ls -sl`;
			rename $bend ($modCore + "_LowerArmIKCBend");
			rotate -a -os -90 0 -90 ($modCore + "_LowerArmIKCBend");
	
			delete -ch ($modCore + "_LowerArmIKCtrl");
			rotate 0 0 90 ($modCore + "_LowerArmIKCtrl");
			setAttr (($modCore + "_LowerArmIKCtrl.scale"), ($ArmLength/14), ($ArmLength/14), ($ArmLength/14));
			makeIdentity -apply true -r 1 -s 1 ($modCore + "_LowerArmIKCtrl");
	
			group -n ($modCore + "_LowerArmIKCtrlGrp") ($modCore + "_LowerArmIKCtrl");
			group -n ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_LowerArmIKCtrlGrp");
			parent ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerArmIKCtrlGrp.rotateOrder") 1;
			setAttr ($modCore + "_LowerArmIKCtrlGrp2.rotateOrder") 1;
	
			spaceLocator -n ($modCore + "_lowerArmIKLctr");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_lowerArmIKLctr")`;
			parent ($modCore + "_lowerArmIKLctr") ($modCore + "_ShoulderFKCtrl");
			setAttr ($modCore + "_lowerArmIKLctr.v") 0;
			
			delete `pointConstraint ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKCtrlGrp2")`;
			//ALIGN GROUP
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow2")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIKCtrlGrp2")`;
			//AIM CONSTRAIN GROUP WITH OFFSET
			aimConstraint -offset 0 0 0 -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_WristIKCtrl")
			($modCore + "_lowerArmIKLctr") ($modCore + "_LowerArmIKCtrlGrp2");
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow2")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIKCtrlGrp")`;
			pointConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKCtrlGrp2");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIKCtrl")`;
			$WristPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Wrist")`;
			move -a $WristPos[0] $WristPos[1] $WristPos[2] ($modCore + "_LowerArmIKCtrl.scalePivot") ($modCore + "_LowerArmIKCtrl.rotatePivot") ;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_LowerArmIKCtrl");
			
			//ADD ORIENTATION ATTRIBUTE FOR LOWER LEG IKCtrl ORIENTATION
			spaceLocator -n ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset");
			delete `parentConstraint ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset")`;
			parentConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset");
			
			orientConstraint -mo ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset") ($modCore + "_LowerArmIKCtrlGrp");
			parent ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset") ($modCore + "_WristIKCtrl");
			
			addAttr -ln "autoOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_LowerArmIKCtrl");
			setAttr -e-keyable true ($modCore + "_LowerArmIKCtrl.autoOrient");
			connectAttr -f ($modCore + "_LowerArmIKCtrl.autoOrient") ($modCore + "_LowerArmIKCtrlGrp_orientConstraint1." + $modCore + "_LowerArmIKCtrlGrp2W0");
			
			shadingNode -asUtility reverse -n ($modCore + "_LowerArmIKCtrl_Reverse");
			connectAttr -f ($modCore + "_LowerArmIKCtrl.autoOrient") ($modCore + "_LowerArmIKCtrl_Reverse.inputX");
			connectAttr -f ($modCore + "_LowerArmIKCtrl_Reverse.outputX") ($modCore + "_LowerArmIKCtrlGrp_orientConstraint1." + $modCore + "_LowerArmIKCtrlGrp2_LctrOffsetW1");
			setAttr ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset.v") 0;
			
			spaceLocator -n ($modCore + "_LowerElbowIKOffsetLctr");
			delete `pointConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_LowerElbowIKOffsetLctr")`;
			
		}
	
		//ELBOW AIM LOCATORS
		spaceLocator -n ($modCore + "_ElbowIKCtrl_TargetLctr");
		spaceLocator -n ($modCore + "_ElbowIKCtrl_ShoulderLctr");
		spaceLocator -n ($modCore + "_ElbowIKCtrl_WristLctr");
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_ElbowIKCtrl_ShoulderLctr")`;
		parentConstraint -mo ($modCore + "_ClavicleCtrl") ($modCore + "_ElbowIKCtrl_ShoulderLctr");
		
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_ElbowIKCtrl_WristLctr")`;
		parentConstraint -mo ($modCore + "_WristIKCtrl")  ($modCore + "_ElbowIKCtrl_WristLctr");
		
		parent ($modCore + "_ElbowIKCtrl_ShoulderLctr") ($modCore + "_ElbowIKCtrl_WristLctr") ($modCore + "_ScaleGrp");
		setAttr ($modCore + "_ElbowIKCtrl_ShoulderLctr.v") 0;
		setAttr ($modCore + "_ElbowIKCtrl_WristLctr.v") 0;
			
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{	
			delete `pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_ElbowIKCtrl_TargetLctr")`;
			pointConstraint -mo ($modCore + "_ElbowIKCtrl_ShoulderLctr") ($modCore + "_ElbowIKCtrl_WristLctr") ($modCore + "_ElbowIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_ElbowIKCtrl_TargetLctr") ($modCore + "_ElbowIKCtrl");
		}
		else
		{
			pointConstraint ($modCore + "_ElbowIKCtrl_ShoulderLctr") ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ElbowIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_ElbowIKCtrl_TargetLctr") ($modCore + "_ElbowIKCtrl");
		}
	
	
		//IK SCALE
		
		//CREATE DUMMY WRIST JOINT
		select ($modCore + "_WristJntIK");
		duplicate -n ($modCore + "_WristJntIKDummy");
		parent -w;
		group -n ($modCore + "_WristJntIKDummyGrp1");
		group -n ($modCore + "_WristJntIKDummyGrp2");
		
		move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_WristJntIKDummyGrp2.scalePivot") ($modCore + "_WristJntIKDummyGrp2.rotatePivot") ;
		pointConstraint ($modCore + "_WristJntIK") ($modCore + "_WristJntIKDummyGrp1");
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + "_WristIKCtrl") ($modCore + "_WristJntIKDummy");
		setAttr ($modCore + "_WristJntIKDummy_parentConstraint1.interpType") 2;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ElbowJntIK") ($modCore + "_WristJntIKDummyGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Elbow2JntIK") ($modCore + "_WristJntIKDummyGrp2");
		}
		
		//NODES
		spaceLocator -n ($modCore + "_ArmLengthOriginLctr");
		pointConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ArmLengthOriginLctr");
		
		spaceLocator -n ($modCore + "_ArmLengthEndLctr");
		parent ($modCore + "_ArmLengthEndLctr") ($modCore + "_ArmLengthOriginLctr");
	
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			pointConstraint ($modCore + "_WristIKCtrl") ($modCore + "_ArmLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_WristIKCtrl") ($modCore + "_ArmLengthOriginLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_LowerArmIKCLctr");
			setAttr ($modCore + "_LowerArmIKCLctr.v") 0;
			delete `parentConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_LowerArmIKCLctr")`;
			parent  ($modCore + "_LowerArmIKCLctr") ($modCore + "_LowerArmIKCtrl");
			pointConstraint ($modCore + "_LowerArmIKCLctr") ($modCore + "_ArmLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ArmLengthOriginLctr");
		}
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ArmLength_MD");
		setAttr ($modCore + "_ArmLength_MD.operation") 2;
		connectAttr -f ($modCore + "_ArmLengthEndLctr.translateX") ($modCore + "_ArmLength_MD.input1X");
		setAttr ($modCore + "_ArmLength_MD.input2X") ($ArmLength*2);
		
		shadingNode -asUtility condition -n ($modCore + "_ArmLength_Condition");
		connectAttr -f ($modCore + "_ArmLength_MD.outputX") ($modCore + "_ArmLength_Condition.firstTerm");
		setAttr ($modCore + "_ArmLength_Condition.secondTerm") 1;
		setAttr ($modCore + "_ArmLength_Condition.operation") 2;
		connectAttr -f ($modCore + "_ArmLength_MD.outputX") ($modCore + "_ArmLength_Condition.colorIfTrueR");
		
		shadingNode -asUtility blendColors -n ($modCore + "_ArmLength_Blnd");
		connectAttr -f ($modCore + "_ArmLength_Condition.outColorR") ($modCore + "_ArmLength_Blnd.color1R");
		setAttr ($modCore + "_ArmLength_Blnd.color2") -type double3 1 0 1 ;
		
		//ADD STRETCH TO IK WRIST CONTROL
		addAttr -ln "stretch"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");

		//ARM IK LOCK
		
		//ARM IK LOCK LOCATORS
		spaceLocator -n ($modCore + "_ShoulderIKLockLctr");
		spaceLocator -n ($modCore + "_ElbowIKLockLctr");
		spaceLocator -n ($modCore + "_WristIKLockLctr");
		parent ($modCore + "_ElbowIKLockLctr") ($modCore + "_ShoulderIKLockLctr");
		parent ($modCore + "_WristIKLockLctr") ($modCore + "_ElbowIKLockLctr");
		pointConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderIKLockLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_ElbowIKCtrl") ($modCore + "_ShoulderIKLockLctr");
		pointConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKLockLctr");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_WristIKCtrl") ($modCore + "_ElbowIKLockLctr");
			pointConstraint ($modCore + "_WristIKCtrl") ($modCore + "_WristIKLockLctr");

			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderLockLength_MD");
			setAttr ($modCore + "_ShoulderLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_ElbowIKLockLctr.translateX") ($modCore + "_ShoulderLockLength_MD.input1X");
			setAttr ($modCore + "_ShoulderLockLength_MD.input2X") $elbowLength[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_elbowLockLength_MD");
			setAttr ($modCore + "_elbowLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_WristIKLockLctr.translateX") ($modCore + "_elbowLockLength_MD.input1X");
			setAttr ($modCore + "_elbowLockLength_MD.input2X") $WristLength[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_ShoulderLock_Blnd");
			connectAttr -f ($modCore + "_ShoulderLockLength_MD.outputX") ($modCore + "_ShoulderLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_ShoulderLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_elbowLock_Blnd");
			connectAttr -f ($modCore + "_elbowLockLength_MD.outputX") ($modCore + "_elbowLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_elbowLock_Blnd.color2R");
		}
		else
		{
			parent ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ShoulderIKLockLctr");
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_LowerArmIKCtrl") ($modCore + "_LowerElbowIKOffsetLctr");
			
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ElbowIKLockLctr");
			pointConstraint ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_WristIKLockLctr");

			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderLockLength_MD");
			setAttr ($modCore + "_ShoulderLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_ElbowIKLockLctr.translateX") ($modCore + "_ShoulderLockLength_MD.input1X");
			setAttr ($modCore + "_ShoulderLockLength_MD.input2X") $elbow1Length[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_elbowLockLength_MD");
			setAttr ($modCore + "_elbowLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_WristIKLockLctr.translateX") ($modCore + "_elbowLockLength_MD.input1X");
			setAttr ($modCore + "_elbowLockLength_MD.input2X") $elbow2Length[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_ShoulderLock_Blnd");
			connectAttr -f ($modCore + "_ShoulderLockLength_MD.outputX") ($modCore + "_ShoulderLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_ShoulderLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_elbowLock_Blnd");
			connectAttr -f ($modCore + "_elbowLockLength_MD.outputX") ($modCore + "_elbowLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_elbowLock_Blnd.color2R");
			
			//AUTO STRETCH ON LOWER ARM IK CONTROL
			addAttr -ln "lowerScale" -at double -min 0.01 -dv 1 ($modCore + "_LowerArmIKCtrl");
			setAttr -e-keyable true ($modCore + "_LowerArmIKCtrl.lowerScale");
			
			//GET ARM LENGTH
			
			$elbow1Length2 = `getAttr ($modCore + "_Elbow1Jnt.tx")`;
			$elbow2Length2 = `getAttr ($modCore + "_Elbow2Jnt.tx")`;
			$WristLength2 = `getAttr ($modCore + "_WristJntDummy.tx")`;
			$FullArmLength = ($elbow1Length2 + $elbow2Length2 + $WristLength2);
			
			//ARM LENGTH LOCATORS
			spaceLocator -n ($modCore + "_FullArmLengthAimLctr");
			spaceLocator -n ($modCore + "_FullArmLengthEndLctr");
			parent ($modCore + "_FullArmLengthEndLctr") ($modCore + "_FullArmLengthAimLctr");
			parent ($modCore + "_FullArmLengthAimLctr") ($modCore + "_ScaleGrp");
			pointConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_FullArmLengthAimLctr");
			pointConstraint ($modCore + "_WristIKCtrl")   ($modCore + "_FullArmLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_WristIKCtrl") ($modCore + "_FullArmLengthAimLctr");

			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullArmLength_MD");
			setAttr ($modCore + "_FullArmLength_MD.operation") 2;
			connectAttr -force ($modCore + "_FullArmLengthEndLctr.translateX") ($modCore + "_FullArmLength_MD.input1X");
			setAttr ($modCore + "_FullArmLength_MD.input2X") $FullArmLength;
			
			shadingNode -asUtility condition -n ($modCore + "_FullArmLength_Condition");
			connectAttr -force ($modCore + "_FullArmLength_MD.outputX") ($modCore + "_FullArmLength_Condition.firstTerm");
			setAttr ($modCore + "_FullArmLength_Condition.secondTerm") 1;
			setAttr ($modCore + "_FullArmLength_Condition.operation") 2;
			connectAttr -force ($modCore + "_FullArmLength_MD.outputX") ($modCore + "_FullArmLength_Condition.colorIfTrueR");
			
			shadingNode -asUtility blendColors -n ($modCore + "_FullArmLength_Blnd");
			connectAttr -force ($modCore + "_WristIKCtrl.stretch") ($modCore + "_FullArmLength_Blnd.blender");
			connectAttr -force ($modCore + "_FullArmLength_Condition.outColorR") ($modCore + "_FullArmLength_Blnd.color1R");
			setAttr ($modCore + "_FullArmLength_Blnd.color2R") 1;
			
			setAttr ($modCore + "_FullArmLengthAimLctr.v") 0;

			
			//MULTIPLY STRETCH WITH LOWER SCALE
			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullArmLength2_MD");
			connectAttr -force ($modCore + "_LowerArmIKCtrl.lowerScale") ($modCore + "_FullArmLength2_MD.input1X");
			connectAttr -force ($modCore + "_FullArmLength_Blnd.outputR") ($modCore + "_FullArmLength2_MD.input2X");
			connectAttr -force ($modCore + "_FullArmLength2_MD.outputX") ($modCore + "_LowerArmIKCtrl.scaleX");
			connectAttr -force ($modCore + "_FullArmLength2_MD.outputX") ($modCore + "_Elbow2JntIK.scaleX");
		}
		
	
		//ADD STRETCH TO IK WRIST CONTROL
		setAttr -e-k true ($modCore + "_WristIKCtrl.stretch");
		connectAttr -f ($modCore + "_WristIKCtrl.stretch") ($modCore + "_ArmLength_Blnd.blender");
		
		//ADD ELBOW LOCK TO IK WRIST CONTROL
		addAttr -ln "elbowLock"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");
		setAttr -e-k true ($modCore + "_WristIKCtrl.elbowLock");
		connectAttr -f ($modCore + "_WristIKCtrl.elbowLock") ($modCore + "_ShoulderLock_Blnd.blender");
		connectAttr -f ($modCore + "_WristIKCtrl.elbowLock") ($modCore + "_elbowLock_Blnd.blender");
		
		//ADD ARM SCALE
		addAttr -ln "armScale"  -at double  -min 0.01 -dv 1 ($modCore + "_WristIKCtrl");
		setAttr -e-k true ($modCore + "_WristIKCtrl.armScale");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderScale_MD");
		connectAttr -force ($modCore + "_ShoulderLock_Blnd.outputR") ($modCore + "_ShoulderScale_MD.input1X");
		connectAttr -force ($modCore + "_WristIKCtrl.armScale") ($modCore + "_ShoulderScale_MD.input2X");
		connectAttr -force ($modCore + "_ShoulderScale_MD.outputX") ($modCore + "_ShoulderJntIK.scaleX");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ElbowScale_MD");
		connectAttr -force ($modCore + "_elbowLock_Blnd.outputR") ($modCore + "_ElbowScale_MD.input1X");
		connectAttr -force ($modCore + "_WristIKCtrl.armScale") ($modCore + "_ElbowScale_MD.input2X");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -force ($modCore + "_ElbowScale_MD.outputX") ($modCore + "_ElbowJntIK.scaleX");
		}
		else
		{
			connectAttr -force ($modCore + "_ElbowScale_MD.outputX") ($modCore + "_Elbow1JntIK.scaleX");
		}
		
	
		//////////////////////////////////HAND IKFK SWITCH CONTROL///////////////////////////////////////////
		curve -n ($modCore + "_SwitchCtrl") -d 1 -p 0 0 0 -p -2 0 -2 -p -1 0 -2 -p -1 0 -5 -p 1 0 -5 -p 1 0 -2
		-p 2 0 -2 -p 0 0 0 -p 0 2 -2 -p 0 1 -2 -p 0 1 -5 -p 0 -1 -5 -p 0 -1 -2
		-p 0 -2 -2 -p 0 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10
		-k 11 -k 12 -k 13 -k 14 ;

		pickWalk -d down;
		rename ($modCore + "_SwitchCtrlShape");
		
		move -r -os -wd 0 0 -8 ($modCore + "_SwitchCtrl");
		group -n ($modCore + "_SwitchCtrlGrp") ($modCore + "_SwitchCtrl"); xform -os -piv 0 0 0;
		scale -r 0.2 0.2 0.2 ($modCore + "_SwitchCtrlGrp");
		makeIdentity -apply true -t 0 -r 1 -s 1 ($modCore + "_SwitchCtrlGrp");
		delete `pointConstraint ($modCore + "_WristJnt") ($modCore + "_SwitchCtrlGrp")`;
		parent ($modCore + "_SwitchCtrlGrp") ($modCore + "_WristIKCtrlGrp");
		makeIdentity -apply false -r 1 ($modCore + "_SwitchCtrlGrp");
		parent -w ($modCore + "_SwitchCtrlGrp");
		
		setAttr (($modCore + "_SwitchCtrlGrp.scale"), ($ArmLength / 3.5), ($ArmLength / 3.5), ($ArmLength / 3.5));
		
		addAttr -ln "switchIkFk"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.switchIkFk");
		addAttr -ln "autoVolume"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.autoVolume");
		setAttr ($modCore + "_SwitchCtrl.autoVolume") 1;
		
		xform -cp ($modCore + "_SwitchCtrl");
		
		parentConstraint -mo ($modCore + "_WristJnt") ($modCore + "_SwitchCtrlGrp");
		
		//PARENT ORIENT
		$parentOrient = ($modCore + "_SwitchCtrl");
		RRM_ParentOrient($modCore, $modName, $modAttachNode, $parentOrient); 	
	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		
		////////////////////////////////////SIDE////////////////////////////////////
		//ARM
		parentConstraint -mo ($modCore + "_ScaleGrp") ($modCore + "_ClavicleCtrlGrp");
		
		//FK
		parentConstraint -mo ($modCore + "_ClavicleCtrl") ($modCore + "_ClavicleJnt");
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_ClavicleCtrl") ($modCore + "_ShoulderFKCtrlGrp");
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
		($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ClavicleCtrl") ($modName + "_MAINCtrl") ($modCore + "_ShoulderFKCtrlGrp2");

		setAttr ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1.interpType") 2;
		
		//SHOULDER ORIENT
		addAttr -ln "shoulderOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_ShoulderFKCtrl");
		setAttr -e-k true ($modCore + "_ShoulderFKCtrl.shoulderOrient");
	
		setAttr ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2");
		setAttr ($modCore + "_ShoulderFKCtrl.shoulderOrient") 0;
		setAttr ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2");
		setAttr ($modCore + "_ShoulderFKCtrl.shoulderOrient") 1;
		
		//CHEST & CLAVICLE INFLUENCE
		addAttr -ln "clavicleInfluence"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_ShoulderFKCtrl");
		setAttr -e-keyable true ($modCore + "_ShoulderFKCtrl.clavicleInfluence");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderFK_Inf_MD");
		connectAttr -force ($modCore + "_ShoulderFKCtrl.clavicleInfluence") ($modCore + "_ShoulderFK_Inf_MD.input1Y");
		setAttr ($modCore + "_ShoulderFK_Inf_MD.input1X") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.clavicleInfluence") ($modCore + "_ShoulderFK_Inf_MD.input1X");
		setAttr ($modCore + "_ShoulderFKCtrl.clavicleInfluence") 1;
		setAttr ($modCore + "_ShoulderFK_Inf_MD.input1X") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.clavicleInfluence") ($modCore + "_ShoulderFK_Inf_MD.input1X");
		setAttr ($modCore + "_ShoulderFKCtrl.clavicleInfluence") 0;
		
		connectAttr -force  ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFK_Inf_MD.input2X");
		connectAttr -force  ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFK_Inf_MD.input2Y");
		connectAttr -force  ($modCore + "_ShoulderFK_Inf_MD.outputX") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		connectAttr -force  ($modCore + "_ShoulderFK_Inf_MD.outputY") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modCore + "_ClavicleCtrlW1");
		
		selectKey -k -f 0 -f 1 ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1_" + $modName + "_MAINCtrlW2") ;
		selectKey -add -k -f 0 -f 1 ($modCore + "_ShoulderFK_Inf_MD_input1X") ;
		keyTangent -itt spline -ott spline ;

		parentConstraint -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJntFK");
		pointConstraint  -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJnt");
		pointConstraint  -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJntIK");
	
		connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_ShoulderJntFK.scaleX");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ElbowFKCtrlGrp");
		
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_ElbowJntFK");
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_WristFKCtrlGrp");
	
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_ElbowFKCtrl.scaleX");
		}
		else
		{
			parentConstraint -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow1FKCtrlGrp");
		
			parentConstraint -mo ($modCore + "_Elbow1FKCtrl") ($modCore + "_Elbow1JntFK");
			parentConstraint -mo ($modCore + "_Elbow1FKCtrl") ($modCore + "_Elbow2FKCtrlGrp");
	
			parentConstraint -mo ($modCore + "_Elbow2FKCtrl") ($modCore + "_Elbow2JntFK");
			parentConstraint -mo ($modCore + "_Elbow2FKCtrl") ($modCore + "_WristFKCtrlGrp");
	
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_Elbow1FKCtrl.scaleX");
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_Elbow2FKCtrl.scaleX");
		}		
			
		parentConstraint -mo ($modCore + "_WristFKCtrl") ($modCore + "_WristJntFK");
		setAttr ($modCore + "_WristJntFK_parentConstraint1.interpType") 2;
		
		//CONNECT SCALE TO FK CONTROLS
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_ElbowJntFK.scaleX");
		}
		else
		{
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_Elbow1JntFK.scaleX");
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_Elbow2JntFK.scaleX");
		}
	
		//IK
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{	
			select ($modCore + "_ShoulderJntIK.rotatePivot") ($modCore + "_WristJntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_ArmIKHandle") -sol ikRPsolver;
			parent ($modCore + "_ArmIKHandle") ($modCore + "_WristIKCtrl");
		}
		else
		{
			select ($modCore + "_Elbow2JntIK.rotatePivot") ($modCore + "_WristJntIK.rotatePivot");
			ikHandle -n ($modCore + "_LowerArmIKHandle") -sol ikSCsolver;
			parentConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKHandle");
			setAttr ($modCore + "_LowerArmIKHandle.v") 0;
	
			select ($modCore + "_ShoulderJntIK.rotatePivot") ($modCore + "_Elbow2JntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_ArmIKHandle") -sol ikRPsolver;
			parent ($modCore + "_ArmIKHandle") ($modCore + "_LowerArmIKCtrl");
			
		}
		poleVectorConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ArmIKHandle") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z -weight 1 ($modCore + "_WristIKCtrl") ($modCore + "_WristJntIK");
		setAttr ($modCore + "_WristJntIK_parentConstraint1.interpType") 2;
	
		//CHECK POLE VECTOR
		if (`objExists ($modCore + "_Elbow1Jnt")`)
		{
			$lSelectionOrient = `getAttr ($modCore + "_ShoulderJntIK.rotate")`;
			if ($lSelectionOrient[0] > 90 || $lSelectionOrient[0] < -90 || $lSelectionOrient[2] > 90 || $lSelectionOrient[2] < -90)
			{
				setAttr ($modCore + "_ArmIKHandle.twist") 180;
			}
				
		}
	
		//CONNECT IK AND FK JOINTS TO ORIGINALS
		//SHOULDER
		shadingNode -asUtility blendColors -n ($modCore + "_ShoulderJntIKFK_BlndScale");
		connectAttr -f ($modCore + "_ShoulderJntFK.scale") ($modCore + "_ShoulderJntIKFK_BlndScale.color1");
		connectAttr -f ($modCore + "_ShoulderJntIK.scale") ($modCore + "_ShoulderJntIKFK_BlndScale.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ShoulderJntIKFK_BlndScale.blender");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderVolume_MD");
		setAttr ($modCore + "_ShoulderVolume_MD.input1X") 1;
		setAttr ($modCore + "_ShoulderVolume_MD.operation") 2;
		connectAttr -f ($modCore + "_ShoulderJntIKFK_BlndScale.outputR") ($modCore + "_ShoulderVolume_MD.input2X");
		
		shadingNode -asUtility blendColors -n ($modCore + "_ShoulderJntIKFK_AutoBlnd");
		setAttr ($modCore + "_ShoulderJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_ShoulderVolume_MD.outputX") ($modCore + "_ShoulderJntIKFK_AutoBlnd.color1R");
		connectAttr -f ($modCore + "_ShoulderJntIKFK_AutoBlnd.outputR") ($modCore + "_ShoulderJnt.scaleY");
		connectAttr -f ($modCore + "_ShoulderJntIKFK_AutoBlnd.outputR") ($modCore + "_ShoulderJnt.scaleZ");
		connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_ShoulderJntIKFK_AutoBlnd.blender");
		
		shadingNode -asUtility blendColors -n  ($modCore + "_ShoulderJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_ShoulderJntFK.rotate") ($modCore + "_ShoulderJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_ShoulderJntIK.rotate") ($modCore + "_ShoulderJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ShoulderJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_ShoulderJntIKFK_BlndScale.outputR") ($modCore + "_ShoulderJnt.scaleX");
		connectAttr -f ($modCore + "_ShoulderJntIKFK_BlndRotate.output") ($modCore + "_ShoulderJnt.rotate");
		
		
		//ELBOW
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIKFK_BlndScale");
			connectAttr -f ($modCore + "_ElbowJntFK.scale") ($modCore + "_ElbowJntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_ElbowJntIK.scale") ($modCore + "_ElbowJntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ElbowJntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_ElbowVolume_MD");
			setAttr ($modCore + "_ElbowVolume_MD.input1X") 1;
			setAttr ($modCore + "_ElbowVolume_MD.operation") 2;
			connectAttr -f ($modCore + "_ElbowJntIKFK_BlndScale.outputR") ($modCore + "_ElbowVolume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIKFK_AutoBlnd");
			setAttr ($modCore + "_ElbowJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_ElbowVolume_MD.outputX") ($modCore + "_ElbowJntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_ElbowJntIKFK_AutoBlnd.outputR") ($modCore + "_ElbowJnt.scaleY");
			connectAttr -f ($modCore + "_ElbowJntIKFK_AutoBlnd.outputR") ($modCore + "_ElbowJnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_ElbowJntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_ElbowJntFK.rotate") ($modCore + "_ElbowJntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_ElbowJntIK.rotate") ($modCore + "_ElbowJntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ElbowJntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_ElbowJntIKFK_BlndScale.outputR") ($modCore + "_ElbowJnt.scaleX");
			connectAttr -f ($modCore + "_ElbowJntIKFK_BlndRotate.output") ($modCore + "_ElbowJnt.rotate");
		}
		else
		{
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Elbow1JntFK.scale") ($modCore + "_Elbow1JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Elbow1JntIK.scale") ($modCore + "_Elbow1JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow1JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Elbow1Volume_MD");
			setAttr ($modCore + "_Elbow1Volume_MD.input1X") 1;
			setAttr ($modCore + "_Elbow1Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Elbow1JntIKFK_BlndScale.outputR") ($modCore + "_Elbow1Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Elbow1JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Elbow1Volume_MD.outputX") ($modCore + "_Elbow1JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Elbow1JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow1Jnt.scaleY");
			connectAttr -f ($modCore + "_Elbow1JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow1Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Elbow1JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Elbow1JntFK.rotate") ($modCore + "_Elbow1JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Elbow1JntIK.rotate") ($modCore + "_Elbow1JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow1JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Elbow1JntIKFK_BlndScale.outputR") ($modCore + "_Elbow1Jnt.scaleX");
			connectAttr -f ($modCore + "_Elbow1JntIKFK_BlndRotate.output") ($modCore + "_Elbow1Jnt.rotate");
	
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Elbow2JntFK.scale") ($modCore + "_Elbow2JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Elbow2JntIK.scale") ($modCore + "_Elbow2JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow2JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Elbow2Volume_MD");
			setAttr ($modCore + "_Elbow2Volume_MD.input1X") 1;
			setAttr ($modCore + "_Elbow2Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Elbow2JntIKFK_BlndScale.outputR") ($modCore + "_Elbow2Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Elbow2JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Elbow2Volume_MD.outputX") ($modCore + "_Elbow2JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Elbow2JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow2Jnt.scaleY");
			connectAttr -f ($modCore + "_Elbow2JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow2Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Elbow2JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Elbow2JntFK.rotate") ($modCore + "_Elbow2JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Elbow2JntIK.rotate") ($modCore + "_Elbow2JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow2JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Elbow2JntIKFK_BlndScale.outputR") ($modCore + "_Elbow2Jnt.scaleX");
			connectAttr -f ($modCore + "_Elbow2JntIKFK_BlndRotate.output") ($modCore + "_Elbow2Jnt.rotate");
		}
	
		//WRIST
		orientConstraint -mo ($modCore + "_WristJntFK") ($modCore + "_WristJntIKDummy") ($modCore + "_WristJntGrp1");
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1.interpType") 2;
		setAttr ($modCore + "_SwitchCtrl.switchIkFk") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0");
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1");
		setAttr ($modCore + "_SwitchCtrl.switchIkFk") 1;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0") 1;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0");
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1");
		
		shadingNode -asUtility blendColors -n ($modCore + "_WristJntIKFK_BlndScale");
		connectAttr -f ($modCore + "_WristJntFK.scale") ($modCore + "_WristJntIKFK_BlndScale.color1");
		connectAttr -f ($modCore + "_WristJntIK.scale") ($modCore + "_WristJntIKFK_BlndScale.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntIKFK_BlndScale.blender");
		
		connectAttr -f ($modCore + "_WristJntIKFK_BlndScale.output") ($modCore + "_WristJnt.scale");
		

		//ELBOWIKCtrl FOLLOW
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_WristIKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_ElbowIKCtrlGrp");
		addAttr -ln "follow"  -at "enum" -en "Main:Wrist:Shoulder:Wrist and Shoulder:" ($modCore + "_ElbowIKCtrl");
		setAttr -e-keyable true ($modCore + "_ElbowIKCtrl.follow");
		setAttr ($modCore + "_ElbowIKCtrl.follow") 0;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2") 0;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2");
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 1;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0") 0;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2");
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 2;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2") 1;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2");
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 3;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 1;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2");
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 0;
		
		
		//CONNECTOR LINE
		curve -n ($modCore + "_ElbowIKConnectorCtrl") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		pickWalk -d down;
		rename ($modCore + "_ElbowIKConnectorCtrlShape");
		delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKConnectorCtrl") `;
		parent ($modCore + "_ElbowIKConnectorCtrl") ($modCore + "_ElbowIKCtrl");
		spaceLocator -n ($modCore + "_ElbowIKAimConnectorLctr");
		spaceLocator -n ($modCore + "_ElbowIKTargetConnectorLctr");
		parent ($modCore + "_ElbowIKTargetConnectorLctr") ($modCore + "_ElbowIKAimConnectorLctr");
		delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKAimConnectorLctr")`;
		parent ($modCore + "_ElbowIKAimConnectorLctr") ($modCore + "_ElbowIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKAimConnectorLctr");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_ElbowIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_ElbowJnt") ($modCore + "_ElbowIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_ElbowJnt") ($modCore + "_ElbowIKConnectorCtrl");
		}
		else
		{
			pointConstraint  ($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIKConnectorCtrl");
		}
		connectAttr -f ($modCore + "_ElbowIKTargetConnectorLctr.tz") ($modCore + "_ElbowIKConnectorCtrl.sz");
		setAttr ($modCore + "_ElbowIKAimConnectorLctr.v") 0;
		
		addAttr -ln "nonControl"  -dt "string" ($modCore + "_ElbowIKConnectorCtrl");
		setAttr -e-keyable true ($modCore + "_ElbowIKConnectorCtrl.nonControl");
		setAttr -lock true ($modCore + "_ElbowIKConnectorCtrl.nonControl");
		
		//VISIBILITY TOGGLES////////////////////////////////////////////////////////////////////
	
		//ARM
		shadingNode -asUtility condition -n ($modCore + "_ArmIKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ArmIKViz.firstTerm");
		setAttr ($modCore + "_ArmIKViz.secondTerm") 0.7;
		setAttr ($modCore + "_ArmIKViz.operation") 3;
			
		connectAttr -f ($modCore + "_ArmIKViz.outColorR") ($modCore + "_ElbowIKCtrl.v");
		connectAttr -f ($modCore + "_ArmIKViz.outColorR") ($modCore + "_WristIKCtrl.v");
		if (`objExists ($modCore + "_LowerArmIKCtrl")`)
		{
			connectAttr -f ($modCore + "_ArmIKViz.outColorR") ($modCore + "_LowerArmIKCtrl.v");
			setAttr -lock true -keyable false -channelBox false ($modCore + "_LowerArmIKCtrl.v");
		}
		shadingNode -asUtility condition -n ($modCore + "_ArmFKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ArmFKViz.firstTerm");
		setAttr ($modCore + "_ArmFKViz.secondTerm") 0.3;
		setAttr ($modCore + "_ArmFKViz.operation") 5;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_ElbowFKCtrl.v");
		}
		else
		{
			connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_Elbow1FKCtrl.v");
			connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_Elbow2FKCtrl.v");
		}
		connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_WristFKCtrl.v");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
	
		//JOINTS
		setAttr ($modCore + "_ShoulderJntIK.v") 0;
		setAttr ($modCore + "_ShoulderJntFK.v") 0;
		setAttr ($modCore + "_WristJntFK.v") 0;
	
	
		setAttr ($modCore + "_ArmLengthOriginLctr.v") 0;
		setAttr ($modCore + "_WristJntIKDummyGrp2.v") 0;
		setAttr ($modCore + "_WristJntFKGrp2.v") 0;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr ($modCore + "_ElbowJntFKGrp2.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Elbow1JntFKGrp2.v") 0;
			setAttr ($modCore + "_Elbow2JntFKGrp2.v") 0;
		}
		
		
		setAttr ($modCore + "_ElbowIKCtrl_TargetLctr.v") 0;
		
		//CONTROLS
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFKCtrl.v");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.v");
		}
		else
		{
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.v");
			
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.v");
			
			
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.v");
			transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_LowerArmIKCtrl");
		}
		
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_WristIKCtrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.v");

		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.v");
		setAttr ($modCore + "_ElbowIKConnectorCtrl.template") 1;
		
		setAttr ($modCore + "_ArmIKHandle.v") 0;
		
		
		//LOCK GROUPS
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		select -cl;
		//WRIST FK LOCATOR
		spaceLocator -n ($modCore + "_WristFKLctr");
		delete `parentConstraint ($modCore + "_WristIKCtrlGrp") ($modCore + "_WristFKLctr")`;
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristFKLctr");
		parent ($modCore + "_WristFKLctr") ($modCore + "_WristIKCtrlGrp");
		parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristFKLctr");
		
		//WRIST IK LOCATOR
		spaceLocator -n ($modCore + "_WristIKLctr");
		delete `parentConstraint ($modCore + "_WristFKCtrlGrp") ($modCore + "_WristIKLctr")`;
		parent ($modCore + "_WristIKLctr") ($modCore + "_WristFKCtrlGrp");
		orientConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_WristIKLctr");
		setAttr ($modCore + "_WristIKLctr_orientConstraint1.interpType") 2;
		
		//ELBOW FK LOCATOR
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			spaceLocator -n ($modCore + "_Elbow_FKAimLctr");
			delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_Elbow_FKAimLctr")`;
			parent ($modCore + "_Elbow_FKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow_FKAimLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_Elbow1_FKAimLctr");
			parent ($modCore + "_Elbow1_FKAimLctr") ($modCore + "_Elbow1FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Elbow1_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_ElbowIKCtrl") ($modCore + "_Elbow1_FKAimLctr")`;
	
			parent ($modCore + "_Elbow1_FKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow1_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Elbow1FKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow1_FKAimLctr");
			
			spaceLocator -n ($modCore + "_Elbow2_FKAimLctr");
			parent ($modCore + "_Elbow2_FKAimLctr") ($modCore + "_Elbow2FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Elbow2_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_ElbowIKCtrl") ($modCore + "_Elbow2_FKAimLctr")`;
	
			parent ($modCore + "_Elbow2_FKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow2_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Elbow2FKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow2_FKAimLctr");
		}		
		
		//SHOULDER FK LOCATOR
		spaceLocator -n ($modCore + "_ShoulderFKOrientLctr");
		delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderFKOrientLctr")`;
		parent ($modCore + "_ShoulderFKOrientLctr") ($modCore + "_ShoulderFKCtrlGrp");
		orientConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderFKOrientLctr");
		
		//HIDE SNAP LOCATORS
		setAttr ($modCore + "_ShoulderFKOrientLctr.v") 0;
		if (`objExists ($modCore + "_Elbow_FKAimLctr.v")`)
		{
			setAttr ($modCore + "_Elbow_FKAimLctr.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Elbow1_FKAimLctr.v") 0;
			setAttr ($modCore + "_Elbow2_FKAimLctr.v") 0;
		}		
		setAttr ($modCore + "_WristIKLctr.v") 0;
		setAttr ($modCore + "_WristFKLctr.v") 0;
		
		setAttr ($modCore + "_ShoulderIKLockLctr.v") 0;
		
		
		//PARENT TO MAIN CONTROL
		
		//SET ALL CONSTRAINTS TO SHORTEST INTERPOLATION
		select ;
		
		string $selectedParentConstraints[] = `ls ($modCore + "*_parentConstraint1")`;
		for ($crntParentConstraint in $selectedParentConstraints)
		{setAttr ($crntParentConstraint + ".interpType") 2;}
		
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1.interpType") 2;
		
		if (`objExists ($modCore + "_Shoulder_CurveJnt")`)
		{
			setAttr ($modCore + "_LowerTwist75Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwist25Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwistHalfLctr_parentConstraint1.interpType") 2;
		}
		
		//HIERARCHY CLEAN-UP
		parent ($modCore + "_ClavicleCtrlGrp") ($modCore + "_ClavicleJnt")
		($modCore + "_WristJntFKGrp2") ($modCore + "_WristIKCtrlGrp") ($modCore + "_ElbowIKCtrlGrp")
		($modCore + "_ElbowIKCtrl_TargetLctr") ($modCore + "_WristJntIKDummyGrp2")
		($modCore + "_ArmLengthOriginLctr") ($modCore + "_ShoulderIKLockLctr")
		($modCore + "_SwitchCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp2")
		($modCore + "_WristFKCtrlGrp") ($modCore + "_WristJntGrp2")
		($modCore + "_WristJntFK")
		($modCore + "_ScaleGrp");
			
		if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parent ($modCore + "_LowerArmIKHandle") ($modCore + "_ScaleGrp");
		}

		//CREATE CONSTRAINT FOR WRIST IKCtrlGrp
		//CHECK IF ATTACHED TO ROOT
		if ($modAttachNode == "ROOT")
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modCore + "_WristIKCtrlGrp");
		}
		else
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_WristIKCtrlGrp");
		}

		//ADD DYNAMIC PARENTING CHANNELS
		addAttr -ln "follow" -at double  -min 1 -max 1 -dv 1 ($modCore + "_WristIKCtrl");
		setAttr -e -keyable true ($modCore + "_WristIKCtrl.follow");
		setAttr -lock true ($modCore + "_WristIKCtrl.follow");
		if ($modAttachNode != "ROOT")
		{
			addAttr -ln "parent" -at double -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");
			setAttr -e-keyable true ($modCore + "_WristIKCtrl.parent");
		}
		addAttr -ln "ROOT"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");
		setAttr -e-keyable true ($modCore + "_WristIKCtrl.ROOT");

		addAttr -ln "ROOTType" -at "enum" -en "ROOTC:ROOTsecondaryC:" ($modCore + "_WristIKCtrl");
		setAttr -e-keyable true ($modCore + "_WristIKCtrl.ROOTType");


		//IK WRIST DYNAMIC CONSTRAINTS
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_WristIKCtrl.parent") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW3");
		}
		
		//ROOT CONNECTIONS
		shadingNode -asUtility multiplyDivide -n ($modCore + "_WristIKROOTInf_MD");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOT") ($modCore + "_WristIKROOTInf_MD.input1X");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOT") ($modCore + "_WristIKROOTInf_MD.input1Y");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOTType") ($modCore + "_WristIKROOTInf_MD.input2Y");
		
		shadingNode -asUtility reverse -n ($modCore + "_WristIKROOTInf_Reverse");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOTType") ($modCore + "_WristIKROOTInf_Reverse.inputX");
		connectAttr -f ($modCore + "_WristIKROOTInf_Reverse.outputX") ($modCore + "_WristIKROOTInf_MD.input2X");

		connectAttr -f ($modCore + "_WristIKROOTInf_MD.outputX") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -f ($modCore + "_WristIKROOTInf_MD.outputY") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_ROOTSecondaryCtrlW2");
		
		shadingNode -asUtility plusMinusAverage -n ($modCore + "_WristIKParent_PMA");
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_WristIKCtrl.parent") ($modCore + "_WristIKParent_PMA.input1D[0]");
		}
		connectAttr -f ($modCore + "_WristIKCtrl.ROOT") ($modCore + "_WristIKParent_PMA.input1D[1]");
		
		shadingNode -asUtility condition -n ($modCore + "_WristIKParent_Condition");
		setAttr ($modCore + "_WristIKParent_Condition.operation") 4;
		setAttr ($modCore + "_WristIKParent_Condition.secondTerm") 1;
		connectAttr -f ($modCore + "_WristIKParent_PMA.output1D") ($modCore + "_WristIKParent_Condition.firstTerm");
		connectAttr -force ($modCore + "_WristIKParent_PMA.output1D") ($modCore + "_WristIKParent_Condition.colorIfTrueR");
		
		shadingNode -asUtility reverse -n ($modCore + "_WristIKParent_Reverse");
		connectAttr -f ($modCore + "_WristIKParent_Condition.outColorR") ($modCore + "_WristIKParent_Reverse.inputX");
		connectAttr -f ($modCore + "_WristIKParent_Reverse.outputX") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		
		//SINGLE ELBOW
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			//WRIST IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_WristIKtoFKLctr");
			delete `parentConstraint ($modCore + "_WristIKCtrlGrp") ($modCore + "_WristIKtoFKLctr")`;
			parent ($modCore + "_WristIKtoFKLctr") ($modCore + "_WristIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristIKtoFKLctr");
			parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristIKtoFKLctr");
			
			//WRIST FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_WristFKtoIKLctr");
			setAttr ($modCore + "_WristFKtoIKLctr.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_WristFKCtrlGrp") ($modCore + "_WristFKtoIKLctr")`;
			parent ($modCore + "_WristFKtoIKLctr") ($modCore + "_WristFKCtrlGrp");
			orientConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_WristFKtoIKLctr");
			setAttr ($modCore + "_WristFKtoIKLctr_orientConstraint1.interpType") 2;
			
			//ELBOW IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_ElbowIKtoFKAimLctr");
			delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKtoFKAimLctr")`;
			parent ($modCore + "_ElbowIKtoFKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKtoFKAimLctr");
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_ElbowIKtoFKAimLctr");
			
			//SHOULDER FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_ShoulderFKtoIKOrientLctr");
			setAttr ($modCore + "_ShoulderFKtoIKOrientLctr.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderFKtoIKOrientLctr")`;
			parent ($modCore + "_ShoulderFKtoIKOrientLctr") ($modCore + "_ShoulderFKCtrlGrp");
			orientConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderFKtoIKOrientLctr");
			
			//TURN OFF VISIBILITY
			setAttr ($modCore + "_WristIKtoFKLctr.v") 0;
			setAttr ($modCore + "_WristFKtoIKLctr.v") 0;
			setAttr ($modCore + "_ElbowIKtoFKAimLctr.v") 0;
			setAttr ($modCore + "_ShoulderFKtoIKOrientLctr.v") 0;
		}
		
		//ELBOW HIERARCHY CLEANUP////////////////////////////////////////////////////////
		if (`objExists ($modCore + "_ElbowJntFKGrp2")`)
		{
			parent ($modCore + "_ElbowJntFKGrp2")  ($modCore + "_ElbowFKCtrlGrp")
			($modCore + "_ScaleGrp");
		}
		else
		{
			parent ($modCore + "_Elbow1FKCtrlGrp") ($modCore + "_Elbow2FKCtrlGrp")
			($modCore + "_Elbow1JntFKGrp2") ($modCore + "_Elbow2JntFKGrp2")
			($modCore + "_ScaleGrp");
		}
		
		select $topNode;
	
		if (`objExists ("RRM_" + $prfx + $core + "_Lower1")` || `objExists ("RRM_" + $prfx + $core + "_Middle1")` || `objExists ("RRM_" + $prfx + $core + "_Upper1")`)
		{
			RRM_ToonLimbs($modName, "arm", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, $modAttachNode, $topNode);
		}
		
		//ADD JOINT ANGLE ATTRIBUTES
		addAttr -ln "shoulderAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "shoulderAngleX");
		addAttr -ln "shoulderAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "shoulderAngleY");
		addAttr -ln "shoulderAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "shoulderAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			addAttr -ln "elbowAngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable true ($modCore + "_SwitchCtrl.elbowAngleY");
		}
		else
		{
			addAttr -ln "elbow1AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable true ($modCore + "_SwitchCtrl.elbow1AngleY");
			addAttr -ln "elbow2AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable true ($modCore + "_SwitchCtrl.elbow2AngleY");
		}
		
		addAttr -ln "wristAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "wristAngleX");
		addAttr -ln "wristAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "wristAngleY");
		addAttr -ln "wristAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "wristAngleZ");
		
		//CONNECT JOINT ANGLE ATTRIBUTES
		connectAttr -force ($modCore + "_ShoulderJnt.rotateX") ($modCore + "_SwitchCtrl." + "shoulderAngleX");
		connectAttr -force ($modCore + "_ShoulderJnt.rotateY") ($modCore + "_SwitchCtrl." + "shoulderAngleY");
		connectAttr -force ($modCore + "_ShoulderJnt.rotateZ") ($modCore + "_SwitchCtrl." + "shoulderAngleZ"); 
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			connectAttr -force ($modCore + "_ElbowJnt.rotateY") ($modCore + "_SwitchCtrl.elbowAngleY");
		}
		else
		{
			connectAttr -force ($modCore + "_Elbow1Jnt.rotateY") ($modCore + "_SwitchCtrl.elbow1AngleY");
			connectAttr -force ($modCore + "_Elbow2Jnt.rotateY") ($modCore + "_SwitchCtrl.elbow2AngleY");
		}
			
	
		connectAttr -force ($modCore + "_WristJntGrp1.rotateX") ($modCore + "_SwitchCtrl.wristAngleX");
		connectAttr -force ($modCore + "_WristJntGrp1.rotateY") ($modCore + "_SwitchCtrl.wristAngleY");
		connectAttr -force ($modCore + "_WristJntGrp1.rotateZ") ($modCore + "_SwitchCtrl.wristAngleZ");
		
		setAttr -lock true ($modCore + "_SwitchCtrl.shoulderAngleX");  
		setAttr -lock true ($modCore + "_SwitchCtrl.shoulderAngleY");  
		setAttr -lock true ($modCore + "_SwitchCtrl.shoulderAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			setAttr -lock true ($modCore + "_SwitchCtrl.elbowAngleY");
		}
		else
		{
			setAttr -lock true ($modCore + "_SwitchCtrl.elbow1AngleY");
			setAttr -lock true ($modCore + "_SwitchCtrl.elbow2AngleY");
		}
		
		setAttr -lock true ($modCore + "_SwitchCtrl.wristAngleX");  
		setAttr -lock true ($modCore + "_SwitchCtrl.wristAngleY");  
		setAttr -lock true ($modCore + "_SwitchCtrl.wristAngleZ");
		
		
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		string $crntModControl;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable true ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock true ($crntModControl + ".modCoreName");

			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable true ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "arm";
			setAttr -l true ($crntModControl + ".moduleType");
		}

		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$inverseFront = 1;
	
		if (!`objExists ($topNode + ".pair")`)
		{
			$i = 2;
		}
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE LEG MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRigLeg(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     
	$core = `getAttr ($topNode + ".core")`;

	//INTEGER FOR LOOP
	$mirrorInt = 1;
		
	string $prfx = "l_";
	string $oppPrfx = "r_";
	int $inverseFront = 0;
	$i = 2;
	if (!`objExists ($topNode + ".pair")`)
	{
		$prfx = "";
		$mirrorInt = 2;
	}

	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;

	while ($mirrorInt <=2)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
		
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "leg";
		setAttr -l true ($modCore + "Grp.topNode");
			
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		//UPPER ROLL JOINTS
		int $sizeUpperCJnt = 0;
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
			$sizeUpperCJnt = `size $UpperCJnt`;
		}
		addAttr -ln "upperRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.upperRoll") ;
		setAttr -type "string" ($modCore + "Grp.upperRoll") $sizeUpperCJnt;
		setAttr -l true ($modCore + "Grp.upperRoll");
		
		int $sizeLowerCJnt = 0;
		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$LowerCJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
			$sizeLowerCJnt = `size $LowerCJnt`;
		}
		addAttr -ln "lowerRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.lowerRoll") ;
		setAttr -type "string" ($modCore + "Grp.lowerRoll") $sizeLowerCJnt;
		setAttr -l true ($modCore + "Grp.lowerRoll");
	
		addAttr -ln "kneeNum"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.kneeNum") ;
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr -type "string" ($modCore + "Grp.kneeNum") "1";
		}
		else
		{
			setAttr -type "string" ($modCore + "Grp.kneeNum") "2";
		}		
		setAttr -l true ($modCore + "Grp.kneeNum");
		
	
		int $sizeMiddleCJnt = 0;
		if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
		{
			$MiddleCJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
			$sizeMiddleCJnt = `size $MiddleCJnt`;
		}
		addAttr -ln "midRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.midRoll") ;
		setAttr -type "string" ($modCore + "Grp.midRoll") $sizeMiddleCJnt;
		setAttr -l true ($modCore + "Grp.midRoll");
			
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip")  ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
	
		//HIP FK CONTROL
		circle -n ($modCore + "_HipFKCtrl") -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
		delete -ch ($modCore + "_HipFKCtrl");
		group -n ($modCore + "_HipFKCtrlGrp") ($modCore + "_HipFKCtrl");
		setAttr ($modCore + "_HipFKCtrlGrp.rotateOrder") 1;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_HipFKCtrlGrp")`;
		float $upVector = 1;
		float $kneeLocCheck;
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			$kneeLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Knee.translateZ")`;
		}
		else
		{
			$kneeLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Knee1.translateZ")`;
		}
		if ($kneeLocCheck < -0.0001)
		{
			$upVector = -1;
		}
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee")
			("RRM_" + $prfx + $core + "_Knee") ($modCore + "_HipFKCtrlGrp")`;
		}
		else
		{
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee1")
			("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_HipFKCtrlGrp")`;
		}
		
		float $lLegLength;
		float $lKneeLength[];
		float $lKnee1Length[];
		float $lKnee2Length[];
		float $lAnkleLength[];
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Knee") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_EndLctr")`;
			$lKneeLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_EndLctr")`;
			$lAnkleLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			$lLegLength = (($lKneeLength[0] + $lAnkleLength[0]) /2);
			delete ($modCore + "_StartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_EndLctr")`;
			$lKnee1Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_EndLctr")`;
			$lKnee2Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			$lKneeLength[0] = ($lKnee1Length[0] + $lKnee2Length[0]);
	
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_EndLctr")`;
			$lAnkleLength = `xform -q -t ($modCore + "_EndLctr")`;
	
			$lLegLength = (($lKnee1Length[0] + $lKnee2Length[0]) /2);
			delete ($modCore + "_StartLctr");
		}
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_HipFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_HipFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_HipFKCtrl");
		
		setAttr (($modCore + "_HipFKCtrl.scale"), ($lLegLength/2), ($lLegLength/2), ($lLegLength/2));
		makeIdentity -apply true -s 1 ($modCore + "_HipFKCtrlGrp");
			
		//KNEE FK CONTROL
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			duplicate -n ($modCore + "_KneeFKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
			select ($modCore + "_KneeFKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_KneeFKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_KneeFKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation"
			-worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_KneeFKCtrlGrp")`;

			scale -r 0.8 0.8 0.8 ($modCore + "_KneeFKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_KneeFKCtrlGrp");
		}
		else
		{
			duplicate -n ($modCore + "_Knee1FKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
			select ($modCore + "_Knee1FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Knee1FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_Knee1FKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation"
			-worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee1")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_Knee1FKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_Knee1FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Knee1FKCtrlGrp");
			
			duplicate -n ($modCore + "_Knee2FKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
			select ($modCore + "_Knee2FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Knee2FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_Knee2FKCtrlGrp")`;
			rotate -r -os 0 0 -90 ($modCore + "_Knee2FKCtrlGrp");
			scale -r 0.8 0.8 0.8 ($modCore + "_Knee2FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Knee2FKCtrlGrp");
		}
		
		
		//ANKLE FK CONTROL
		duplicate -n ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_AnkleFKCtrlGrp")`;
		delete `orientConstraint -offset 0 0 -90 ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_AnkleFKCtrlGrp")`;
		scale -r 0.8 0.8 0.8 ($modCore + "_AnkleFKCtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_AnkleFKCtrlGrp");
		select ($modCore + "_AnkleFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_AnkleFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_AnkleFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_AnkleFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_AnkleFKCtrl");
	
		//BALL CONTROL LOCATORS
		spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
		spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
		
		delete `pointConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_StartLctr")`;
		delete `pointConstraint -skip x -skip z ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
		delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + "_AnkleFKCtrlGrp")
		("RRM_" + $prfx + $core + "_Toe") ($modCore + "_StartLctr")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_EndLctr")`;
		$lFootLength = `xform -q -t ($modCore + "_EndLctr")`;
		delete ($modCore + "_StartLctr");
	
		//BALL FK CONTROL
		circle -n ($modCore + "_BallFKCtrl") -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
		move -r 0 0 0.5 ($modCore + "_BallFKCtrl.cv[0:7]");
	
		delete -ch ($modCore + "_BallFKCtrl");
		group -n ($modCore + "_BallFKCtrlGrp") ($modCore + "_BallFKCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_BallFKCtrlGrp.rotateOrder") 1;
	
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ball") ($modCore + "_BallFKCtrlGrp")`;
		delete `orientConstraint -offset 0 -90 -90 ("RRM_" + $prfx + $core + "_Ball") ($modCore + "_BallFKCtrlGrp")`;
		scale -r ($lFootLength[0]/5) ($lFootLength[0]/5) ($lFootLength[0]/4) ($modCore + "_BallFKCtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_BallFKCtrlGrp");
		select ($modCore + "_BallFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_BallFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_BallFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_BallFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_BallFKCtrl");
		
		//TOE FK CONTROL
		circle -n ($modCore + "_ToeFKCtrl") -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
		move -r 0 0 0.5 ($modCore + "_ToeFKCtrl.cv[0:7]");
	
		delete -ch ($modCore + "_ToeFKCtrl");
		group -n ($modCore + "_ToeFKCtrlGrp") ($modCore + "_ToeFKCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_ToeFKCtrlGrp.rotateOrder") 1;
	
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_ToeFKCtrlGrp")`;
		delete `orientConstraint -offset 0 -90 -90 ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_ToeFKCtrlGrp")`;
		scale -r ($lFootLength[0]/5) ($lFootLength[0]/5) ($lFootLength[0]/4) ($modCore + "_ToeFKCtrlGrp");
		select ($modCore + "_ToeFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_ToeFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_ToeFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_ToeFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_ToeFKCtrl");
		
		//////////////////////JOINTS//////////////////////
		select -cl;
		joint -n ($modCore + "_HipJnt");
		delete `parentConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJnt")`;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -cl;
			joint -n ($modCore + "_KneeJnt");
			delete `parentConstraint ($modCore + "_KneeFKCtrl") ($modCore + "_KneeJnt")`;
		
			select -cl;
			joint -n ($modCore + "_AnkleJnt");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJnt")`;
			select -cl;
			joint -n ($modCore + "_AnkleJntDummy");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_HipJnt")
			($modCore + "_KneeJnt") ($modCore + "_AnkleJnt") ($modCore + "_AnkleJntDummy");
			
			parent ($modCore + "_KneeJnt")  ($modCore + "_HipJnt");
			parent ($modCore + "_AnkleJnt") ($modCore + "_KneeJnt");
			parent ($modCore + "_AnkleJntDummy") ($modCore + "_KneeJnt");
		}
		else
		{
			select -cl;
			joint -n ($modCore + "_Knee1Jnt");
			delete `parentConstraint ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee1Jnt")`;
		
			select -cl;
			joint -n ($modCore + "_Knee2Jnt");
			delete `parentConstraint ($modCore + "_Knee2FKCtrl") ($modCore + "_Knee2Jnt")`;
	
			select -cl;
			joint -n ($modCore + "_AnkleJnt");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJnt")`;
			select -cl;
			joint -n ($modCore + "_AnkleJntDummy");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntDummy")`;
			
			makeIdentity -apply true -r 1  ($modCore + "_HipJnt")
			($modCore + "_Knee1Jnt") ($modCore + "_Knee2Jnt") ($modCore + "_AnkleJnt") ($modCore + "_AnkleJntDummy");
	
			parent ($modCore + "_Knee1Jnt")  ($modCore + "_HipJnt");
			parent ($modCore + "_Knee2Jnt") ($modCore + "_Knee1Jnt"); 
			parent ($modCore + "_AnkleJnt") ($modCore + "_Knee2Jnt");
			parent ($modCore + "_AnkleJntDummy") ($modCore + "_Knee2Jnt");
		}
		//HIDE WRIST DUMMY 
		setAttr ($modCore + "_AnkleJntDummy.v") 0;
		
		select -cl;
		joint -n ($modCore + "_BallJnt");
		delete `parentConstraint ($modCore + "_BallFKCtrl") ($modCore + "_BallJnt")`;	
		
		select -cl;
		joint -n ($modCore + "_ToeJnt");
		delete `parentConstraint ($modCore + "_ToeFKCtrl") ($modCore + "_ToeJnt")`;
		
		makeIdentity -apply true -r 1 ($modCore + "_BallJnt") ($modCore + "_ToeJnt");
		
		parent ($modCore + "_BallJnt") ($modCore + "_AnkleJnt");
		parent ($modCore + "_ToeJnt") ($modCore + "_BallJnt");
	
		//KNEE ORIENTATION
		if (`objExists ($modCore + "_KneeJnt")`)
		{
			if ($kneeLocCheck < -0.0001)
			{
				setAttr ($modCore + "_KneeJnt.preferredAngleY") -60;
			}
			else
			{
				setAttr ($modCore + "_KneeJnt.preferredAngleY") 60;
			}
		}
		else
		{
			if ($kneeLocCheck < -0.0001)
			{
				setAttr ($modCore + "_Knee1Jnt.preferredAngleY") -30;
			}
			else
			{
				setAttr ($modCore + "_Knee1Jnt.preferredAngleY") 30;
			}			
		}
		
		////////////////////IK/FK JOINTS////////////////////////////////////	
		//LEG FK
		duplicate -n ($modCore + "_HipJntFK") ($modCore + "_HipJnt");
		select ($modCore + "_HipJntFK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			rename ($modCore + "_KneeJntFK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntFK");
			pickWalk -d right;
			delete;       
		}
		else
		{
			rename ($modCore + "_Knee1JntFK");
			pickWalk -d down;
			rename ($modCore + "_Knee2JntFK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntFK");
			pickWalk -d right;
			delete;
		}
		select ($modCore + "_AnkleJntFK");
		pickWalk -d down;
		rename ($modCore + "_BallJntFK");
		pickWalk -d down;
		rename ($modCore + "_ToeJntFK");
		
		//LEG IK
		duplicate -n ($modCore + "_HipJntIK") ($modCore + "_HipJnt");
		select ($modCore + "_HipJntIK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			rename ($modCore + "_KneeJntIK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntIK");
			pickWalk -d right;
			delete;
		}
		else
		{
			rename ($modCore + "_Knee1JntIK");
			pickWalk -d down;
			rename ($modCore + "_Knee2JntIK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntIK");
			pickWalk -d right;
			delete;
		}
		
		select ($modCore + "_AnkleJntIK");
		pickWalk -d down;
		rename ($modCore + "_BallJntIK");
		pickWalk -d down;
		rename ($modCore + "_ToeJntIK");
		
		//DETACH FK LEG JOINTS FOR SCALE COMPENSATION
	
		parent -w ($modCore + "_AnkleJntFK");
		group -n ($modCore + "_AnkleJntFKGrp1") ($modCore + "_AnkleJntFK");
		group -n ($modCore + "_AnkleJntFKGrp2") ($modCore + "_AnkleJntFKGrp1");
		$lAnkleLocation = `xform -q -ws -t ($modCore + "_AnkleJnt")`;
		move $lAnkleLocation[0] $lAnkleLocation[1] $lAnkleLocation[2] ($modCore + "_AnkleJntFKGrp1.scalePivot") ($modCore + "_AnkleJntFKGrp1.rotatePivot") ;
	
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			parentConstraint -mo ($modCore + "_KneeJntFK") ($modCore + "_AnkleJntFKGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Knee2JntFK") ($modCore + "_AnkleJntFKGrp2");
		}
			
		$lKneeLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			$lKneeLocation = `xform -q -ws -t ($modCore + "_KneeJnt")`;
			move $lKneeLocation[0] $lKneeLocation[1] $lKneeLocation[2] ($modCore + "_AnkleJntFKGrp2.scalePivot") ($modCore + "_AnkleJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntFKGrp1");
			parentConstraint -mo ($modCore + "_KneeJntFK") ($modCore + "_AnkleJntFKGrp2");
		
			parent -w ($modCore + "_KneeJntFK");
			group -n ($modCore + "_KneeJntFKGrp1") ($modCore + "_KneeJntFK");
			group -n ($modCore + "_KneeJntFKGrp2") ($modCore + "_KneeJntFKGrp1");
			$lHipLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
			move $lKneeLocation[0] $lKneeLocation[1] $lKneeLocation[2] ($modCore + "_KneeJntFKGrp1.scalePivot") ($modCore + "_KneeJntFKGrp1.rotatePivot") ;
			move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_KneeJntFKGrp2.scalePivot") ($modCore + "_KneeJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_KneeFKCtrl") ($modCore + "_KneeJntFKGrp1");
			parentConstraint -mo ($modCore + "_HipJntFK") ($modCore + "_KneeJntFKGrp2");
		}
		else
		{
			$lKnee2Location = `xform -q -ws -t ($modCore + "_Knee2Jnt")`;
			move $lKnee2Location[0] $lKnee2Location[1] $lKnee2Location[2] ($modCore + "_AnkleJntFKGrp2.scalePivot") ($modCore + "_AnkleJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntFKGrp1");
			parentConstraint -mo ($modCore + "_Knee2JntFK") ($modCore + "_AnkleJntFKGrp2");
	
			parent -w ($modCore + "_Knee1JntFK") ($modCore + "_Knee2JntFK");
			
			group -n ($modCore + "_Knee1JntFKGrp1") ($modCore + "_Knee1JntFK");
			group -n ($modCore + "_Knee1JntFKGrp2") ($modCore + "_Knee1JntFKGrp1");
			$lHipLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
			$lKnee1Location = `xform -q -ws -t ($modCore + "_Knee1Jnt")`;
			$lKnee2Location = `xform -q -ws -t ($modCore + "_Knee2Jnt")`;
			move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_Knee1JntFKGrp1.scalePivot") ($modCore + "_Knee1JntFKGrp1.rotatePivot") ;
			move $lKnee1Location[0] $lKnee1Location[1] $lKnee1Location[2] ($modCore + "_Knee1JntFKGrp2.scalePivot") ($modCore + "_Knee1JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee1JntFKGrp1");
			parentConstraint -mo ($modCore + "_HipJntFK") ($modCore + "_Knee1JntFKGrp2");
	
			group -n ($modCore + "_Knee2JntFKGrp1") ($modCore + "_Knee2JntFK");
			group -n ($modCore + "_Knee2JntFKGrp2") ($modCore + "_Knee2JntFKGrp1");
			move $lKnee1Location[0] $lKnee1Location[1] $lKnee1Location[2] ($modCore + "_Knee2JntFKGrp1.scalePivot") ($modCore + "_Knee2JntFKGrp1.rotatePivot") ;
			move $lKnee2Location[0] $lKnee2Location[1] $lKnee2Location[2] ($modCore + "_Knee2JntFKGrp2.scalePivot") ($modCore + "_Knee2JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Knee2FKCtrl") ($modCore + "_Knee2JntFKGrp1");
			parentConstraint -mo ($modCore + "_Knee1JntFK") ($modCore + "_Knee2JntFKGrp2");
		}
		
		//CONSTRAIN HIP JOINTS TO ATTACH NODE
		pointConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJnt");
		delete `pointConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJntFK")`;
		pointConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJntIK");
	
		//FOOT IK CONTROL
		circle -n ($modCore + "_FootIKCtrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 2.5 -d 3 -ut 0 -tol 0.01 -s 16 -ch 1;
	
		scale -r 0.4 1 1 ($modCore + "_FootIKCtrl.cv[13]") ($modCore + "_FootIKCtrl.cv[5]");
		scale -r 0.6 1 1 ($modCore + "_FootIKCtrl.cv[14]") ($modCore + "_FootIKCtrl.cv[4]");
		scale -r 0.78 1 1 ($modCore + "_FootIKCtrl.cv[3]") ($modCore + "_FootIKCtrl.cv[15]"); 
		scale -r 0.78 1 1 ($modCore + "_FootIKCtrl.cv[12]") ($modCore + "_FootIKCtrl.cv[6]");
		scale -r 0.89 1 1 ($modCore + "_FootIKCtrl.cv[7]") ($modCore + "_FootIKCtrl.cv[11]");
		move -r -os -wd 0 0.565 0 ($modCore + "_FootIKCtrl.cv[5]") ($modCore + "_FootIKCtrl.cv[13]");
		move -r -os -wd 0 0.1 0 ($modCore + "_FootIKCtrl.cv[4]") ($modCore + "_FootIKCtrl.cv[14]") ($modCore + "_FootIKCtrl.cv[6]") ($modCore + "_FootIKCtrl.cv[12]");
		move -r 0 0 1.5 ($modCore + "_FootIKCtrl.cv[0:15]");
		scale -r ($lFootLength[0]/4.2) ($lFootLength[0]/4.2) ($lFootLength[0]/3.4) ($modCore + "_FootIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_FootIKCtrl");
		delete -ch ($modCore + "_FootIKCtrl");
		group -n ($modCore + "_FootIKCtrlGrp") ($modCore + "_FootIKCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_FootIKCtrl.rotateOrder") 1;
		
		//TOE IK CONTROL
		circle -n ($modCore + "_ToeIKCtrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
		makeIdentity -apply true -t 1 -r 1 -s 1;
		delete -ch;
		move -r ($multiplier * -0.251) 1.330 2.207($modCore + "_ToeIKCtrl.cv[1]") ;
		move -r 0.254 1.085 1.162($modCore + "_ToeIKCtrl.cv[0]") ;
		move -r 0.051 0.451 -0.205 ($modCore + "_ToeIKCtrl.cv[7]") ;
		move -r 0.188 0.259 -0.109 ($modCore + "_ToeIKCtrl.cv[6]") ;
		move -r -0.277 0.154 0.308 ($modCore + "_ToeIKCtrl.cv[5]") ;
		move -r -0.395 0.259 -0.033 ($modCore + "_ToeIKCtrl.cv[4]") ;
		move -r 0.003 0.474 -0.205 ($modCore + "_ToeIKCtrl.cv[3]") ;
		move -r -0.369 1.190 1.331 ($modCore + "_ToeIKCtrl.cv[2]") ;
		move -r -os -wd 0 0 0.9 ($modCore + "_ToeIKCtrl.cv[0:7]") ;
		scale -r -p 0cm 0cm 0cm $multiplier 1 1 ($modCore + "_ToeIKCtrl.cv[0:7]");
		
		move -r -.001 0 1.85 ($modCore + "_ToeIKCtrl");
		scale -r ($lFootLength[0]/4) ($lFootLength[0]/4) ($lFootLength[0]/4.4) ($modCore + "_ToeIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ToeIKCtrl");
		group -n ($modCore + "_ToeIKCtrlGrp") ($modCore + "_ToeIKCtrl");
		parent ($modCore + "_ToeIKCtrlGrp") ($modCore + "_FootIKCtrlGrp");
		
		//HEEL IK CONTROL
		circle -n ($modCore + "_HeelIKCtrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
		makeIdentity -apply true -t 1 -r 1 -s 1;
		delete -ch;
		move -r -0.25107 1.330277 2.206782 ($modCore + "_HeelIKCtrl.cv[1]") ;
		move -r 0.254402 1.084741 1.162191 ($modCore + "_HeelIKCtrl.cv[0]") ;
		move -r 0.0513063 0.450871 -0.204969 ($modCore + "_HeelIKCtrl.cv[7]") ;
		move -r 0.187803 0.259426 -0.108661 ($modCore + "_HeelIKCtrl.cv[6]") ;
		move -r -0.276837 0.154413 0.307813 ($modCore + "_HeelIKCtrl.cv[5]") ;
		move -r -0.395115 0.259426 -0.0326967 ($modCore + "_HeelIKCtrl.cv[4]") ;
		move -r 0.00260226 0.47359 -0.204969 ($modCore + "_HeelIKCtrl.cv[3]") ;
		move -r -0.369241 1.189888 1.331089 ($modCore + "_HeelIKCtrl.cv[2]") ;
		move -r -os -wd 0 0 0.8 ($modCore + "_HeelIKCtrl.cv[0:7]") ;
		scale -r -p 0cm 0cm 0cm $multiplier 1 -1 ($modCore + "_HeelIKCtrl.cv[0:7]");
		scale -r ($lFootLength[0]/3.7) ($lFootLength[0]/3.7) ($lFootLength[0]/5.5) ($modCore + "_HeelIKCtrl");
		move -r -.001 0 1.85 ($modCore + "_HeelIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_HeelIKCtrl");
		group -n ($modCore + "_HeelIKCtrlGrp") ($modCore + "_HeelIKCtrl");
		parent ($modCore + "_HeelIKCtrlGrp") ($modCore + "_FootIKCtrlGrp");
		
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Ground") ($modCore + "_FootIKCtrlGrp")`;
		$lAnklePosition = `xform -ws -q -rp ($modCore + "_AnkleJnt")`;
		$lBallLocation = `xform  -q -t ($modCore + "_BallJnt")`;
		$lToeLocation = `xform -q -t ($modCore + "_ToeJnt")`;
		makeIdentity -apply true -t 0 -s 1 ($modCore + "_FootIKCtrlGrp");
		
		
		//MOVE TOE CTRL PIVOT
		$limbJointLoc = `xform -ws -q -t ($modCore + "_ToeJnt")`;
		$heelLoc = `xform -ws -q -rp ("RRM_" + $prfx + $core + "_HeelPivot")`;
		delete `pointConstraint ($modCore + "_ToeJnt") ($modCore + "_ToeIKCtrl")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_HeelIKCtrl")`;
		move $heelLoc[0]  $heelLoc[1] $heelLoc[2] ($modCore + "_HeelIKCtrlGrp.scalePivot") ($modCore + "_HeelIKCtrlGrp.rotatePivot") ;
		move $limbJointLoc[0]  $limbJointLoc[1] $limbJointLoc[2] ($modCore + "_ToeIKCtrlGrp.scalePivot") ($modCore + "_ToeIKCtrlGrp.rotatePivot") ;
		move $lAnklePosition[0] $lAnklePosition[1] $lAnklePosition[2] ($modCore + "_FootIKCtrl.scalePivot") ($modCore + "_FootIKCtrl.rotatePivot") ;
	
		
		//FOOT IK LOCATORS
		spaceLocator -n ($modCore + "_FootBallPivotLctr");
		delete `pointConstraint ($modCore + "_BallJnt") ($modCore + "_FootBallPivotLctr")`;
		delete `aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + "_FootIKCtrl")
		($modCore + "_ToeJnt") ($modCore + "_FootBallPivotLctr")`;
		
		duplicate -rr -n ($modCore + "_FootToePivotLctr") ($modCore + "_FootBallPivotLctr");
		
		duplicate -n ($modCore + "_FootBallPivotLctr2") ($modCore + "_FootBallPivotLctr");
		parent ($modCore + "_FootBallPivotLctr2") ($modCore + "_FootBallPivotLctr");
	
		select ($modCore + "_AnkleJntIK.rotatePivot") ($modCore + "_BallJntIK.rotatePivot") ; 
		ikHandle -n ($modCore + "_BallIKHandle") -sol ikSCsolver;
		parent ($modCore + "_BallIKHandle") ($modCore + "_FootBallPivotLctr2");
		select ($modCore + "_BallJntIK.rotatePivot") ($modCore + "_ToeJntIK.rotatePivot") ; 
		ikHandle -n ($modCore + "_ToeIKHandle") -sol ikSCsolver;
		parent ($modCore + "_ToeIKHandle") ($modCore + "_FootToePivotLctr");
	
		spaceLocator -n ($modCore + "_BallSwivelLctr");
		delete `pointConstraint ($modCore + "_BallJnt") ($modCore + "_BallSwivelLctr")`;
		parent ($modCore + "_BallSwivelLctr") ($modCore + "_ToeIKCtrl");
		makeIdentity -apply false -r 1 ($modCore + "_BallSwivelLctr");
		
		spaceLocator -n ($modCore + "_FootRightTiltLctr");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_FootRightTilt") ($modCore + "_FootRightTiltLctr")`;
		spaceLocator -n ($modCore + "_FootLeftTiltLctr");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_FootLeftTilt") ($modCore + "_FootLeftTiltLctr")`;
		
		spaceLocator -n ($modCore + "_HeelLctr");
		delete `parentConstraint ($modCore + "_HeelIKCtrl") ($modCore + "_HeelLctr")`;
		parent ($modCore + "_HeelLctr") ($modCore + "_HeelIKCtrl");
		setAttr ($modCore + "_HeelLctr.v") 0;
		
		delete `parentConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_HeelIKCtrlGrp")`;
	
		parent ($modCore + "_HeelIKCtrlGrp") ($modCore + "_ToeIKCtrl");
		parent ($modCore + "_BallSwivelLctr") ($modCore + "_HeelLctr");
		parent ($modCore + "_FootRightTiltLctr") ($modCore + "_BallSwivelLctr");
		parent ($modCore + "_FootLeftTiltLctr")  ($modCore + "_FootRightTiltLctr");
		parent ($modCore + "_FootBallPivotLctr") ($modCore + "_FootToePivotLctr") ($modCore + "_FootLeftTiltLctr");
		
		makeIdentity -apply true -t 1 -r 0 -s 1 ($modCore + "_ToeIKCtrlGrp");
		parentConstraint -mo ($modCore + "_FootIKCtrl") ($modCore + "_ToeIKCtrlGrp");
		
		setAttr -l 0 -k 1 ($modCore + "_HipJntIK.rx");
		setAttr -l 0 -k 1 ($modCore + "_HipJntIK.ry");
		setAttr -l 0 -k 1 ($modCore + "_HipJntIK.rz");
		if (`objExists ($modCore + "_KneeJntIK")`)
		{
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIK.rx");
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIK.ry");
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIK.rz");
		}
		else
		{
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIK.rx");
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIK.ry");
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIK.rz");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIK.rx");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIK.ry");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIK.rz");
		}
	
		//KNEE IK CONTROL
		curve -n ($modCore + "_KneeIKCtrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
		-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
		-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
		-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
		-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
		-k 23 -k 24 ;
		pickWalk -d down;
		rename ($modCore + "_KneeIKCtrlShape");
		
		move -r 0 0 0.95 ($modCore + "_KneeIKCtrl.cv[12]")  ($modCore + "_KneeIKCtrl.cv[0]") ($modCore + "_KneeIKCtrl.cv[24]") ($modCore + "_KneeIKCtrl.cv[18]") ($modCore + "_KneeIKCtrl.cv[6]") ;
		move -r 0 0 -0.65 ($modCore + "_KneeIKCtrl.cv[3]") ($modCore + "_KneeIKCtrl.cv[9]") ($modCore + "_KneeIKCtrl.cv[15]") ($modCore + "_KneeIKCtrl.cv[21]") ;
		group -n ($modCore + "_KneeIKCtrlGrp") ($modCore + "_KneeIKCtrl");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_KneeIKCtrlGrp")`;
			setAttr (($modCore + "_KneeIKCtrl.scale"), ($lLegLength / 16), ($lLegLength / 16), ($lLegLength / 16));
			setAttr ($modCore + "_KneeIKCtrl.tz") ($lLegLength * 1.8);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKCtrl");
		}
		else
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_KneeIKCtrlGrp")`;
			setAttr (($modCore + "_KneeIKCtrl.scale"), ($lLegLength / 16), ($lLegLength / 16), ($lLegLength / 16));
			setAttr ($modCore + "_KneeIKCtrl.tz") ($lLegLength * 1.8);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKCtrl");
		}
		
		//LOWER LEG CONTROL
		if (`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			curve -n ($modCore + "_LowerLegIKCtrl") -d 1 -p -1 0 4 -p -4 0 4 -p -3 0 5 -p -2 0 6 -p -1 0 7 -p 0 0 8 -p 1 0 7 -p 2 0 6 -p 3 0 5 -p 4 0 4 -p 1 0 4 -p 1 0 3 -p 1 0 2 -p 1 0 1 -p 1 0 0 -p 1 0 -1 -p 1 0 -2 -p 1 0 -3 -p 1 0 -4 -p 4 0 -4 -p 3 0 -5 -p 2 0 -6 -p 1 0 -7 -p 0 0 -8 -p -1 0 -7 -p -2 0 -6 -p -3 0 -5 -p -4 0 -4 -p -1 0 -4 -p -1 0 -3 -p -1 0 -2 -p -1 0 -1 -p -1 0 0 -p -1 0 1 -p -1 0 2 -p -1 0 3 -p -1 0 4 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 ;
			pickWalk -d down;
			rename ($modCore + "_LowerLegIKCtrlShape");
			nonLinear -type bend -lowBound -1 -highBound 1 -curvature 0.6;
			$bend = `ls -sl`;
			rename $bend ($modCore + "_LowerLegIKCBend");
			rotate -a -os -90 0 -90 ($modCore + "_LowerLegIKCBend");
	
			delete -ch ($modCore + "_LowerLegIKCtrl");
			setAttr (($modCore + "_LowerLegIKCtrl.scale"), ($lLegLength/14), ($lLegLength/14), ($lLegLength/14));
			makeIdentity -apply true -r 1 -s 1 ($modCore + "_LowerLegIKCtrl");
			
			group -n ($modCore + "_LowerLegIKCtrlGrp") ($modCore + "_LowerLegIKCtrl");
			group -n ($modCore + "_LowerLegIKCtrlGrp2") ($modCore + "_LowerLegIKCtrlGrp");
			group -n ($modCore + "_LowerLegIKCtrlGrp3") ($modCore + "_LowerLegIKCtrlGrp2");			
			parent ($modCore + "_LowerLegIKCtrlGrp3") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerLegIKCtrlGrp.rotateOrder") 1;
			setAttr ($modCore + "_LowerLegIKCtrlGrp2.rotateOrder") 1;
			setAttr ($modCore + "_LowerLegIKCtrlGrp3.rotateOrder") 1;
	
			spaceLocator -n ($modCore + "_lowerLegIKLctr");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_lowerLegIKLctr")`;
			parent ($modCore + "_lowerLegIKLctr") ($modCore + "_HipFKCtrl");
			setAttr ($modCore + "_lowerLegIKLctr.v") 0;

			
			//MOVE GROUP 3 TO BALL LOCATION AND ORIENT IT SO IT IS AIMING AT LOWER IK CONTROL
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrlGrp3")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Knee2")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIKCtrlGrp3")`;
	
			parentConstraint -mo ($modCore + "_FootBallPivotLctr2") ($modCore + "_LowerLegIKCtrlGrp3");
			
			//LOCATOR FOR UP AXIS ON LOWER FOOT CONTROL USING ROTATE Y ONLY FORM FOOTIKC
			spaceLocator -n ($modCore + "_LowerLegIKCtrl_UpLctr");
			setAttr ($modCore + "_LowerLegIKCtrl_UpLctr.rotateOrder") 1;
			group -n ($modCore + "_LowerLegIKCtrl_UpLctrGrp") ($modCore + "_LowerLegIKCtrl_UpLctr");
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIKCtrl_UpLctrGrp")`;
			pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrl_UpLctrGrp");
			parent ($modCore + "_LowerLegIKCtrl_UpLctrGrp") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerLegIKCtrl_UpLctrGrp.v") 0;
			orientConstraint -mo -skip x -skip z ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrl_UpLctr");
			setAttr ($modCore + "_LowerLegIKCtrl_UpLctr_orientConstraint1.interpType") 2;
			
			aimConstraint -mo -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_LowerLegIKCtrl_UpLctr")
			($modCore + "_lowerLegIKLctr") ($modCore + "_LowerLegIKCtrlGrp2");
			spaceLocator -n ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset");
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset")`;
			parent ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset") ($modCore + "_FootBallPivotLctr");
			delete `orientConstraint ($modCore + "_LowerLegIKCtrlGrp2") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset")`;
			parentConstraint -mo ($modCore + "_FootBallPivotLctr") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset");

			orientConstraint -mo ($modCore + "_LowerLegIKCtrlGrp2") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset") ($modCore + "_LowerLegIKCtrlGrp");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIKCtrl")`;
			$AnklePos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Ankle")`;
			move -a $AnklePos[0] $AnklePos[1] $AnklePos[2] ($modCore + "_LowerLegIKCtrl.scalePivot") ($modCore + "_LowerLegIKCtrl.rotatePivot") ;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_LowerLegIKCtrl");
			
			//ADD ORIENTATION ATTRIBUTE FOR LOWER LEG IKCtrl ORIENTATION
			addAttr -ln "autoOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_LowerLegIKCtrl");
			setAttr -e-keyable true ($modCore + "_LowerLegIKCtrl.autoOrient");
			connectAttr -f ($modCore + "_LowerLegIKCtrl.autoOrient") ($modCore + "_LowerLegIKCtrlGrp_orientConstraint1." + $modCore + "_LowerLegIKCtrlGrp2W0");
			
			shadingNode -asUtility reverse -n ($modCore + "_LowerLegIKCtrl_Reverse");
			connectAttr -f ($modCore + "_LowerLegIKCtrl.autoOrient") ($modCore + "_LowerLegIKCtrl_Reverse.inputX");
			connectAttr -f ($modCore + "_LowerLegIKCtrl_Reverse.outputX") ($modCore + "_LowerLegIKCtrlGrp_orientConstraint1." + $modCore + "_LowerLegIKCtrlGrp2_LctrOffsetW1");
			setAttr ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset.v") 0;

			spaceLocator -n ($modCore + "_LowerKneeIKOffsetLctr");
			delete `pointConstraint ($modCore + "_Knee2Jnt") ($modCore + "_LowerKneeIKOffsetLctr")`;
		}

		//KNEE AIM LOCATORS
		spaceLocator -n ($modCore + "_KneeIKCtrl_TargetLctr");
		spaceLocator -n ($modCore + "_KneeIKCtrl_HipLctr");
		spaceLocator -n ($modCore + "_KneeIKCtrl_AnkleLctr");
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_KneeIKCtrl_HipLctr")`;
		parentConstraint -mo ($modCore + "_ScaleGrp") ($modCore + "_KneeIKCtrl_HipLctr");
		
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_KneeIKCtrl_AnkleLctr")`;
		parentConstraint -mo ($modCore + "_FootBallPivotLctr2")  ($modCore + "_KneeIKCtrl_AnkleLctr");
		
		parent ($modCore + "_KneeIKCtrl_HipLctr") ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_ScaleGrp");
		setAttr ($modCore + "_KneeIKCtrl_HipLctr.v") 0;
		setAttr ($modCore + "_KneeIKCtrl_AnkleLctr.v") 0;
			
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{	
			delete `pointConstraint ($modCore + "_KneeJnt") ($modCore + "_KneeIKCtrl_TargetLctr")`;
			pointConstraint -mo ($modCore + "_KneeIKCtrl_HipLctr") ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_KneeIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_KneeIKCtrl_TargetLctr") ($modCore + "_KneeIKCtrl");
		}
		else
		{
			pointConstraint ($modCore + "_KneeIKCtrl_HipLctr") ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_KneeIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_KneeIKCtrl_TargetLctr") ($modCore + "_KneeIKCtrl");
		}
			

		//IK SCALE
		
		//NODES
		spaceLocator -n ($modCore + "_LegLengthOriginLctr");
		pointConstraint ($modCore + "_HipJntIK") ($modCore + "_LegLengthOriginLctr");
		
		spaceLocator -n ($modCore + "_LegLengthEndLctr");
		parent ($modCore + "_LegLengthEndLctr") ($modCore + "_LegLengthOriginLctr");
		

		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LegLengthEndLctr")`;
			parentConstraint ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_LegLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_LegLengthOriginLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_LowerLegIKCLctr");
			setAttr ($modCore + "_LowerLegIKCLctr.v") 0;
			delete `parentConstraint ($modCore + "_Knee2Jnt") ($modCore + "_LowerLegIKCLctr")`;
			parent  ($modCore + "_LowerLegIKCLctr") ($modCore + "_LowerLegIKCtrl");
			pointConstraint ($modCore + "_LowerLegIKCLctr") ($modCore + "_LegLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_LegLengthOriginLctr");
		}


		shadingNode -asUtility multiplyDivide -n ($modCore + "_LegLength_MD");
		setAttr ($modCore + "_LegLength_MD.operation") 2;
		connectAttr -f ($modCore + "_LegLengthEndLctr.translateX") ($modCore + "_LegLength_MD.input1X");
		setAttr ($modCore + "_LegLength_MD.input2X") ($lLegLength*2);
		
		shadingNode -asUtility condition -n ($modCore + "_LegLength_Condition");
		connectAttr -f ($modCore + "_LegLength_MD.outputX") ($modCore + "_LegLength_Condition.firstTerm");
		setAttr ($modCore + "_LegLength_Condition.secondTerm") 1;
		setAttr ($modCore + "_LegLength_Condition.operation") 2;
		connectAttr -f ($modCore + "_LegLength_MD.outputX") ($modCore + "_LegLength_Condition.colorIfTrueR");
		
		shadingNode -asUtility blendColors -n ($modCore + "_LegLength_Blnd");
		connectAttr -f ($modCore + "_LegLength_Condition.outColorR") ($modCore + "_LegLength_Blnd.color1R");
		setAttr ($modCore + "_LegLength_Blnd.color2") -type double3 1 0 1 ;
		
		//ADD STRETCH TO IK ANKLE CONTROL
		addAttr -ln "stretch"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");

		//LEG IK LOCK
		
		//LEG IK LOCK LOCATORS
		spaceLocator -n ($modCore + "_HipIKLockLctr");
		spaceLocator -n ($modCore + "_KneeIKLockLctr");
		spaceLocator -n ($modCore + "_AnkleIKLockLctr");
		parent ($modCore + "_KneeIKLockLctr") ($modCore + "_HipIKLockLctr");
		parent ($modCore + "_AnkleIKLockLctr") ($modCore + "_KneeIKLockLctr");
		pointConstraint ($modCore + "_HipJntIK") ($modCore + "_HipIKLockLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_KneeIKCtrl") ($modCore + "_HipIKLockLctr");
		pointConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKLockLctr");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_FootIKCtrl") ($modCore + "_KneeIKLockLctr");
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_AnkleIKLockLctr")`;
			parentConstraint -mo ($modCore + "_FootBallPivotLctr2") ($modCore + "_AnkleIKLockLctr");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_HipLockLength_MD");
			setAttr ($modCore + "_HipLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_KneeIKLockLctr.translateX") ($modCore + "_HipLockLength_MD.input1X");
			setAttr ($modCore + "_HipLockLength_MD.input2X") $lKneeLength[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_kneeLockLength_MD");
			setAttr ($modCore + "_kneeLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_AnkleIKLockLctr.translateX") ($modCore + "_kneeLockLength_MD.input1X");
			setAttr ($modCore + "_kneeLockLength_MD.input2X") $lAnkleLength[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_HipLock_Blnd");
			connectAttr -f ($modCore + "_HipLockLength_MD.outputX") ($modCore + "_HipLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_HipLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_kneeLock_Blnd");
			connectAttr -f ($modCore + "_kneeLockLength_MD.outputX") ($modCore + "_kneeLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_kneeLock_Blnd.color2R");
		}
		else
		{
			parent ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_HipIKLockLctr");
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_LowerLegIKCtrl") ($modCore + "_LowerKneeIKOffsetLctr");
			
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_KneeIKLockLctr");
			pointConstraint ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_AnkleIKLockLctr");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_HipLockLength_MD");
			setAttr ($modCore + "_HipLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_KneeIKLockLctr.translateX") ($modCore + "_HipLockLength_MD.input1X");
			setAttr ($modCore + "_HipLockLength_MD.input2X") $lKnee1Length[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_kneeLockLength_MD");
			setAttr ($modCore + "_kneeLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_AnkleIKLockLctr.translateX") ($modCore + "_kneeLockLength_MD.input1X");
			setAttr ($modCore + "_kneeLockLength_MD.input2X") $lKnee2Length[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_HipLock_Blnd");
			connectAttr -f ($modCore + "_HipLockLength_MD.outputX") ($modCore + "_HipLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_HipLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_kneeLock_Blnd");
			connectAttr -f ($modCore + "_kneeLockLength_MD.outputX") ($modCore + "_kneeLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_kneeLock_Blnd.color2R");

			//AUTO STRETCH ON LOWER LEG IK CONTROL
			addAttr -ln "lowerScale" -at double -min 0.01 -dv 1 ($modCore + "_LowerLegIKCtrl");
			setAttr -e-keyable true ($modCore + "_LowerLegIKCtrl.lowerScale");
			
			//GET LEG LENGTH
			
			$Knee1Length2 = `getAttr ($modCore + "_Knee1Jnt.tx")`;
			$Knee2Length2 = `getAttr ($modCore + "_Knee2Jnt.tx")`;
			$AnkleLength2 = `getAttr ($modCore + "_AnkleJnt.tx")`;
			$FullLegLength = ($Knee1Length2 + $Knee2Length2 + $AnkleLength2);
			
			//LEG LENGTH LOCATORS
			spaceLocator -n ($modCore + "_FullLegLengthAimLctr");
			spaceLocator -n ($modCore + "_FullLegLengthEndLctr");
			parent ($modCore + "_FullLegLengthEndLctr") ($modCore + "_FullLegLengthAimLctr");
			parent ($modCore + "_FullLegLengthAimLctr") ($modCore + "_ScaleGrp");
			pointConstraint ($modCore + "_HipJntIK") ($modCore + "_FullLegLengthAimLctr");
			pointConstraint ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset") ($modCore + "_FullLegLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_FootIKCtrl") ($modCore + "_FullLegLengthAimLctr");

			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLegLength_MD");
			setAttr ($modCore + "_FullLegLength_MD.operation") 2;
			connectAttr -force ($modCore + "_FullLegLengthEndLctr.translateX") ($modCore + "_FullLegLength_MD.input1X");
			setAttr ($modCore + "_FullLegLength_MD.input2X") $FullLegLength;
			
			shadingNode -asUtility condition -n ($modCore + "_FullLegLength_Condition");
			connectAttr -force ($modCore + "_FullLegLength_MD.outputX") ($modCore + "_FullLegLength_Condition.firstTerm");
			setAttr ($modCore + "_FullLegLength_Condition.secondTerm") 1;
			setAttr ($modCore + "_FullLegLength_Condition.operation") 2;
			connectAttr -force ($modCore + "_FullLegLength_MD.outputX") ($modCore + "_FullLegLength_Condition.colorIfTrueR");
			
			shadingNode -asUtility blendColors -n ($modCore + "_FullLegLength_Blnd");
			connectAttr -force ($modCore + "_FootIKCtrl.stretch") ($modCore + "_FullLegLength_Blnd.blender");
			connectAttr -force ($modCore + "_FullLegLength_Condition.outColorR") ($modCore + "_FullLegLength_Blnd.color1R");
			setAttr ($modCore + "_FullLegLength_Blnd.color2R") 1;
			
			setAttr ($modCore + "_FullLegLengthAimLctr.v") 0;
			
			//MULTIPLY STRETCH WITH LOWER SCALE
			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLegLength2_MD");
			connectAttr -force ($modCore + "_LowerLegIKCtrl.lowerScale") ($modCore + "_FullLegLength2_MD.input1X");
			connectAttr -force ($modCore + "_FullLegLength_Blnd.outputR") ($modCore + "_FullLegLength2_MD.input2X");
			connectAttr -force ($modCore + "_FullLegLength2_MD.outputX") ($modCore + "_LowerLegIKCtrl.scaleY");
			
			//CREATE MULTIPLY/DIVIDE TO CONNECT TO THE KNEE2JntIK
			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLegLength2_Inv_MD");
			setAttr ($modCore + "_FullLegLength2_Inv_MD.operation") 2;
			setAttr ($modCore + "_FullLegLength2_Inv_MD.input1X")  1;
			connectAttr ($modCore + "_FullLegLength2_MD.outputX") ($modCore + "_Knee2JntIK.scaleX");
			connectAttr ($modCore + "_FullLegLength2_MD.outputX") ($modCore + "_FullLegLength2_Inv_MD.input2X");
		}
		
			
		//ADD STRETCH TO IK ANKLE CONTROL
		setAttr -e-k true ($modCore + "_FootIKCtrl.stretch");
		connectAttr -f ($modCore + "_FootIKCtrl.stretch") ($modCore + "_LegLength_Blnd.blender");
		
		//ADD KNEE LOCK TO IK ANKLE CONTROL
		addAttr -ln "kneeLock"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");
		setAttr -e-k true ($modCore + "_FootIKCtrl.kneeLock");
		connectAttr -f ($modCore + "_FootIKCtrl.kneeLock") ($modCore + "_HipLock_Blnd.blender");
		connectAttr -f ($modCore + "_FootIKCtrl.kneeLock") ($modCore + "_kneeLock_Blnd.blender");
		
		//ADD LEG SCALE
		addAttr -ln "legScale"  -at double  -min 0.01 -dv 1 ($modCore + "_FootIKCtrl");
		setAttr -e-k true ($modCore + "_FootIKCtrl.legScale");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HipScale_MD");
		connectAttr -force ($modCore + "_HipLock_Blnd.outputR") ($modCore + "_HipScale_MD.input1X");
		connectAttr -force ($modCore + "_FootIKCtrl.legScale") ($modCore + "_HipScale_MD.input2X");
		connectAttr -force ($modCore + "_HipScale_MD.outputX") ($modCore + "_HipJntIK.scaleX");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_KneeScale_MD");
		connectAttr -force ($modCore + "_kneeLock_Blnd.outputR") ($modCore + "_KneeScale_MD.input1X");
		connectAttr -force ($modCore + "_FootIKCtrl.legScale") ($modCore + "_KneeScale_MD.input2X");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -force ($modCore + "_KneeScale_MD.outputX") ($modCore + "_KneeJntIK.scaleX");
		}
		else
		{
			connectAttr -force ($modCore + "_KneeScale_MD.outputX") ($modCore + "_Knee1JntIK.scaleX");
		}
	
		
	
		//////////////////////////////////FOOT IKFK SWITCH CONTROL///////////////////////////////////////////
		curve -n ($modCore + "_SwitchCtrl") -d 1 -p 0 0 0 -p -2 0 -2 -p -1 0 -2 -p -1 0 -5 -p 1 0 -5 -p 1 0 -2
		-p 2 0 -2 -p 0 0 0 -p 0 2 -2 -p 0 1 -2 -p 0 1 -5 -p 0 -1 -5 -p 0 -1 -2
		-p 0 -2 -2 -p 0 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10
		-k 11 -k 12 -k 13 -k 14 ;
		pickWalk -d down;
		rename ($modCore + "_SwitchCtrlShape");
		//pickWalk -d up;
		
		move -r -os -wd 0 0 -8 ($modCore + "_SwitchCtrl");
		group -n ($modCore + "_SwitchCtrlGrp") ($modCore + "_SwitchCtrl"); xform -os -piv 0 0 0;
		scale -r 0.2 0.2 0.2 ($modCore + "_SwitchCtrlGrp");
		makeIdentity -apply true -t 0 -r 1 -s 1 ($modCore + "_SwitchCtrlGrp");
		delete `pointConstraint ($modCore + "_AnkleJnt") ($modCore + "_SwitchCtrlGrp")`;
		parent ($modCore + "_SwitchCtrlGrp") ($modCore + "_FootIKCtrlGrp");
		makeIdentity -apply false -r 1 ($modCore + "_SwitchCtrlGrp");
		parent -w ($modCore + "_SwitchCtrlGrp");
		
		setAttr (($modCore + "_SwitchCtrlGrp.scale"), ($lLegLength / 3.5), ($lLegLength / 3.5), ($lLegLength / 3.5));
		
		addAttr -ln "switchIkFk"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.switchIkFk");
		addAttr -ln "autoVolume"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.autoVolume");
		setAttr ($modCore + "_SwitchCtrl.autoVolume") 1;
		
		xform -cp ($modCore + "_SwitchCtrl");
		
		parentConstraint -mo ($modCore + "_AnkleJnt") ($modCore + "_SwitchCtrlGrp");
	
		
		//PARENT ORIENT
		$parentOrient = ($modCore + "_SwitchCtrl");
		RRM_ParentOrient($modCore, $modName, $modAttachNode, $parentOrient); 
	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		//LEG
		
		//FK
		$lHipLocation = `xform -q -ws -t ($modCore + "_HipFKCtrlGrp")`;
		move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_HipFKCtrlGrp.scalePivot") ($modCore + "_HipFKCtrlGrp.rotatePivot") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
		($modName + "_" + $modAttachNode + "Jnt") ($modName + "_MAINCtrl") ($modCore + "_HipFKCtrlGrp");
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1.interpType") 2;
		
		//HIP ORIENT
		addAttr -ln "hipOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_HipFKCtrl");
		setAttr -e-k true ($modCore + "_HipFKCtrl.hipOrient");
	
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1");
		setAttr ($modCore + "_HipFKCtrl.hipOrient") 0;
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0") 0;
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1");
		setAttr ($modCore + "_HipFKCtrl.hipOrient") 1;

		parentConstraint -mo ($modCore + "_HipFKCtrl") ($modCore + "_HipJntFK");
	
		connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_HipJntFK.scaleX");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			parentConstraint -mo ($modCore + "_HipFKCtrl") ($modCore + "_KneeFKCtrlGrp");
		
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_KneeJntFK");
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_AnkleFKCtrlGrp");
	
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_KneeFKCtrl.scaleX");
		}
		else
		{
			parentConstraint -mo ($modCore + "_HipFKCtrl") ($modCore + "_Knee1FKCtrlGrp");
		
			parentConstraint -mo ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee1JntFK");
			parentConstraint -mo ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee2FKCtrlGrp");
	
			parentConstraint -mo ($modCore + "_Knee2FKCtrl") ($modCore + "_Knee2JntFK");
			parentConstraint -mo ($modCore + "_Knee2FKCtrl") ($modCore + "_AnkleFKCtrlGrp");
	
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee1FKCtrl.scaleX");
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee2FKCtrl.scaleX");
		}
			
		parentConstraint -mo ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntFK");
		setAttr ($modCore + "_AnkleJntFK_parentConstraint1.interpType") 2;
		
		parentConstraint -mo ($modCore + "_AnkleFKCtrl") ($modCore + "_BallFKCtrlGrp");
		parentConstraint -mo ($modCore + "_BallFKCtrl") ($modCore + "_BallJntFK");
		setAttr ($modCore + "_BallFKCtrlGrp_parentConstraint1.interpType") 2;
		setAttr ($modCore + "_BallJntFK_parentConstraint1.interpType") 2;
		
		parentConstraint -mo ($modCore + "_BallFKCtrl") ($modCore + "_ToeFKCtrlGrp");
		parentConstraint -mo ($modCore + "_ToeFKCtrl")  ($modCore + "_ToeJntFK");
		setAttr ($modCore + "_ToeFKCtrlGrp_parentConstraint1.interpType") 2;
		setAttr ($modCore + "_ToeJntFK_parentConstraint1.interpType") 2;
		
		//CONNECT SCALE TO FK CONTROLS
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_KneeJntFK.scaleX");
		}
		else
		{
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee1JntFK.scaleX");
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee2JntFK.scaleX");
		}
	
		//IK
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select ($modCore + "_HipJntIK.rotatePivot") ($modCore + "_AnkleJntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_LegIKHandle") -sol ikRPsolver;
			parent ($modCore + "_LegIKHandle") ($modCore + "_FootBallPivotLctr2");
		}
		else
		{
			select ($modCore + "_Knee2JntIK.rotatePivot") ($modCore + "_AnkleJntIK.rotatePivot");
			ikHandle -n ($modCore + "_LowerLegIKHandle") -sol ikSCsolver;
			parent ($modCore + "_LowerLegIKHandle") ($modCore + "_FootBallPivotLctr2");
			parentConstraint -mo ($modCore + "_FootBallPivotLctr2") ($modCore + "_LowerLegIKHandle");
	
			select ($modCore + "_HipJntIK.rotatePivot") ($modCore + "_Knee2JntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_LegIKHandle") -sol ikRPsolver;
			parent ($modCore + "_LegIKHandle") ($modCore + "_LowerLegIKCtrl");
			
		}
		poleVectorConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_LegIKHandle") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z -weight 1 ($modCore + "_FootIKCtrl") ($modCore + "_AnkleJntIK");
		setAttr ($modCore + "_AnkleJntIK_parentConstraint1.interpType") 2;	
		
		//CONNECT IK AND FK JOINTS TO ORIGINALS
		//HIP
		shadingNode -asUtility blendColors -n ($modCore + "_HipJntIKFK_BlndScale");
		connectAttr -f ($modCore + "_HipJntFK.scale") ($modCore + "_HipJntIKFK_BlndScale.color1");
		connectAttr -f ($modCore + "_HipJntIK.scale") ($modCore + "_HipJntIKFK_BlndScale.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_HipJntIKFK_BlndScale.blender");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HipVolume_MD");
		setAttr ($modCore + "_HipVolume_MD.input1X") 1;
		setAttr ($modCore + "_HipVolume_MD.operation") 2;
		connectAttr -f ($modCore + "_HipJntIKFK_BlndScale.outputR") ($modCore + "_HipVolume_MD.input2X");
		
		shadingNode -asUtility blendColors -n ($modCore + "_HipJntIKFK_AutoBlnd");
		setAttr ($modCore + "_HipJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_HipVolume_MD.outputX") ($modCore + "_HipJntIKFK_AutoBlnd.color1R");
		connectAttr -f ($modCore + "_HipJntIKFK_AutoBlnd.outputR") ($modCore + "_HipJnt.scaleY");
		connectAttr -f ($modCore + "_HipJntIKFK_AutoBlnd.outputR") ($modCore + "_HipJnt.scaleZ");
		connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_HipJntIKFK_AutoBlnd.blender");
		
		shadingNode -asUtility blendColors -n  ($modCore + "_HipJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_HipJntFK.rotate") ($modCore + "_HipJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_HipJntIK.rotate") ($modCore + "_HipJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_HipJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_HipJntIKFK_BlndScale.outputR") ($modCore + "_HipJnt.scaleX");
		connectAttr -f ($modCore + "_HipJntIKFK_BlndRotate.output") ($modCore + "_HipJnt.rotate");
		
		//KNEE
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIKFK_BlndScale");
			connectAttr -f ($modCore + "_KneeJntFK.scale") ($modCore + "_KneeJntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_KneeJntIK.scale") ($modCore + "_KneeJntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_KneeJntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_KneeVolume_MD");
			setAttr ($modCore + "_KneeVolume_MD.input1X") 1;
			setAttr ($modCore + "_KneeVolume_MD.operation") 2;
			connectAttr -f ($modCore + "_KneeJntIKFK_BlndScale.outputR") ($modCore + "_KneeVolume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIKFK_AutoBlnd");
			setAttr ($modCore + "_KneeJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_KneeVolume_MD.outputX") ($modCore + "_KneeJntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_KneeJntIKFK_AutoBlnd.outputR") ($modCore + "_KneeJnt.scaleY");
			connectAttr -f ($modCore + "_KneeJntIKFK_AutoBlnd.outputR") ($modCore + "_KneeJnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_KneeJntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_KneeJntFK.rotate") ($modCore + "_KneeJntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_KneeJntIK.rotate") ($modCore + "_KneeJntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_KneeJntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_KneeJntIKFK_BlndScale.outputR") ($modCore + "_KneeJnt.scaleX");
			connectAttr -f ($modCore + "_KneeJntIKFK_BlndRotate.output") ($modCore + "_KneeJnt.rotate");
		}
		else
		{
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Knee1JntFK.scale") ($modCore + "_Knee1JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Knee1JntIK.scale") ($modCore + "_Knee1JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee1JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Knee1Volume_MD");
			setAttr ($modCore + "_Knee1Volume_MD.input1X") 1;
			setAttr ($modCore + "_Knee1Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Knee1JntIKFK_BlndScale.outputR") ($modCore + "_Knee1Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Knee1JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Knee1Volume_MD.outputX") ($modCore + "_Knee1JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Knee1JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee1Jnt.scaleY");
			connectAttr -f ($modCore + "_Knee1JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee1Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Knee1JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Knee1JntFK.rotate") ($modCore + "_Knee1JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Knee1JntIK.rotate") ($modCore + "_Knee1JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee1JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Knee1JntIKFK_BlndScale.outputR") ($modCore + "_Knee1Jnt.scaleX");
			connectAttr -f ($modCore + "_Knee1JntIKFK_BlndRotate.output") ($modCore + "_Knee1Jnt.rotate");
	
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Knee2JntFK.scale") ($modCore + "_Knee2JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Knee2JntIK.scale") ($modCore + "_Knee2JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee2JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Knee2Volume_MD");
			setAttr ($modCore + "_Knee2Volume_MD.input1X") 1;
			setAttr ($modCore + "_Knee2Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Knee2JntIKFK_BlndScale.outputR") ($modCore + "_Knee2Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Knee2JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Knee2Volume_MD.outputX") ($modCore + "_Knee2JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Knee2JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee2Jnt.scaleY");
			connectAttr -f ($modCore + "_Knee2JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee2Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Knee2JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Knee2JntFK.rotate") ($modCore + "_Knee2JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Knee2JntIK.rotate") ($modCore + "_Knee2JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee2JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Knee2JntIKFK_BlndScale.outputR") ($modCore + "_Knee2Jnt.scaleX");
			connectAttr -f ($modCore + "_Knee2JntIKFK_BlndRotate.output") ($modCore + "_Knee2Jnt.rotate");
		}		
	
		//ANKLE
		shadingNode -asUtility blendColors -n ($modCore + "_AnkleJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_AnkleJntFK.rotate") ($modCore + "_AnkleJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_AnkleJntIK.rotate") ($modCore + "_AnkleJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_AnkleJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_AnkleJntIKFK_BlndRotate.output") ($modCore + "_AnkleJnt.rotate");
		
		//BALL
		shadingNode -asUtility blendColors -n ($modCore + "_BallJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_BallJntFK.rotate") ($modCore + "_BallJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_BallJntIK.rotate") ($modCore + "_BallJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_BallJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_BallJntIKFK_BlndRotate.output") ($modCore + "_BallJnt.rotate");
		
		//TOE
		shadingNode -asUtility blendColors -n ($modCore + "_ToeJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_ToeJntFK.rotate") ($modCore + "_ToeJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_ToeJntIK.rotate") ($modCore + "_ToeJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ToeJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_ToeJntIKFK_BlndRotate.output") ($modCore + "_ToeJnt.rotate");
		
		//KNEE IKCtrl FOLLOW
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_FootBallPivotLctr2") ($modCore + "_HipFKCtrl") ($modCore + "_KneeIKCtrlGrp");
		addAttr -ln "follow"  -at "enum" -en "Main:Ankle:Hip:Ankle and Hip:" ($modCore + "_KneeIKCtrl");
		setAttr -e-keyable true ($modCore + "_KneeIKCtrl.follow");
		setAttr ($modCore + "_KneeIKCtrl.follow") 0;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2") 0;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 1;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0") 0;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 2;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2") 1;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 3;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 1;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 0;
		
		//FOOT
		addAttr -ln "footTilt"  -at double  -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.footTilt");
		addAttr -ln "ballUpDn"  -at double  -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.ballUpDn");
		addAttr -ln "toeUpDn"  -at double  -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.toeUpDn");
		addAttr -ln "ballSwivel"  -at double -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.ballSwivel");
		addAttr -ln "heelBall"  -at double -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.heelBall");
		//SDK TILT
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootRightTiltLctr.rotateZ");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootLeftTiltLctr.rotateZ");
		setAttr ($modCore + "_FootIKCtrl.footTilt") -10;
		rotate -r 0 0 90 ($modCore + "_FootRightTiltLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootRightTiltLctr.rotateZ");
		setAttr ($modCore + "_FootIKCtrl.footTilt") 10;
		rotate -r 0 0 -90 ($modCore + "_FootLeftTiltLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootLeftTiltLctr.rotateZ");
		setAttr ($modCore + "_FootIKCtrl.footTilt") 0;
		//SDK HEEL UP DN
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballUpDn") ($modCore + "_FootBallPivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.ballUpDn") -10;
		rotate -r -90 0 0 ($modCore + "_FootBallPivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballUpDn") ($modCore + "_FootBallPivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.ballUpDn") 10;
		rotate -r 90 0 0 ($modCore + "_FootBallPivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballUpDn") ($modCore + "_FootBallPivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.ballUpDn") 0;
		//SDK TOE UP DN
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.toeUpDn") ($modCore + "_FootToePivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.toeUpDn") -10;
		rotate -r 90 0 0 ($modCore + "_FootToePivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.toeUpDn") ($modCore + "_FootToePivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.toeUpDn") 10;
		rotate -r -90 0 0 ($modCore + "_FootToePivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.toeUpDn") ($modCore + "_FootToePivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.toeUpDn") 0;
		//SDK BALL SWIVEL		
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballSwivel") ($modCore + "_BallSwivelLctr.rotateY");
		setAttr ($modCore + "_FootIKCtrl.ballSwivel") -10;
		rotate -r 0 90 0 ($modCore + "_BallSwivelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballSwivel") ($modCore + "_BallSwivelLctr.rotateY");
		setAttr ($modCore + "_FootIKCtrl.ballSwivel") 10;
		rotate -r 0 -90 0 ($modCore + "_BallSwivelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballSwivel") ($modCore + "_BallSwivelLctr.rotateY");
		setAttr ($modCore + "_FootIKCtrl.ballSwivel") 0;
		//SDK HEEL BALL (LEGACY)
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_HeelLctr.rotateX");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_FootBallPivotLctr2.rotateX");
		setAttr ($modCore + "_FootIKCtrl.heelBall") -10;
		rotate -r -90 0 0 ($modCore + "_HeelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_HeelLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.heelBall") 10;
		rotate -r 90 0 0 ($modCore + "_FootBallPivotLctr2");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_FootBallPivotLctr2.rotateX");
		setAttr ($modCore + "_FootIKCtrl.heelBall") 0;
		
		selectKey -add -k ($modCore + "_FootRightTiltLctr_rotateZ") ;
		selectKey -add -k ($modCore + "_FootLeftTiltLctr_rotateZ") ;
		selectKey -add -k ($modCore + "_FootToePivotLctr_rotateX") ;
		selectKey -add -k ($modCore + "_FootBallPivotLctr_rotateX") ;
		selectKey -add -k ($modCore + "_FootBallPivotLctr2_rotateX") ;
		selectKey -add -k ($modCore + "_BallSwivelLctr.rotateY");
		keyTangent -itt spline -ott spline ;
	
		setInfinity -pri linear ($modCore + "_BallSwivelLctr.ry");
		setInfinity -poi linear ($modCore + "_BallSwivelLctr.ry");
		
	
		//CONNECTOR LINE
		curve -n ($modCore + "_KneeIKConnectorCtrl") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		pickWalk -d down;
		rename ($modCore + "_KneeIKConnectorCtrlShape");
		delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKConnectorCtrl") `;
		parent ($modCore + "_KneeIKConnectorCtrl") ($modCore + "_KneeIKCtrl");
		spaceLocator -n ($modCore + "_KneeIKAimConnectorLctr");
		spaceLocator -n ($modCore + "_KneeIKTargetConnectorLctr");
		parent ($modCore + "_KneeIKTargetConnectorLctr") ($modCore + "_KneeIKAimConnectorLctr");
		delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKAimConnectorLctr")`;
		parent ($modCore + "_KneeIKAimConnectorLctr") ($modCore + "_KneeIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKAimConnectorLctr");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			pointConstraint ($modCore + "_KneeJnt") ($modCore + "_KneeIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_KneeJnt") ($modCore + "_KneeIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_KneeJnt") ($modCore + "_KneeIKConnectorCtrl");
		}
		else
		{
			pointConstraint  ($modCore + "_Knee1Jnt") ($modCore + "_KneeIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Knee1Jnt") ($modCore + "_KneeIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Knee1Jnt") ($modCore + "_KneeIKConnectorCtrl");
		}
		connectAttr -f ($modCore + "_KneeIKTargetConnectorLctr.tz") ($modCore + "_KneeIKConnectorCtrl.sz");
		setAttr ($modCore + "_KneeIKAimConnectorLctr.v") 0;

		addAttr -ln "nonControl"  -dt "string" ($modCore + "_KneeIKConnectorCtrl");
		setAttr -e-keyable true ($modCore + "_KneeIKConnectorCtrl.nonControl");
		setAttr -lock true ($modCore + "_KneeIKConnectorCtrl.nonControl");


		//VISIBILITY TOGGLES////////////////////////////////////////////////////////////////////
		
	
		//LEG
		shadingNode -asUtility condition -n ($modCore + "_LegIKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_LegIKViz.firstTerm");
		setAttr ($modCore + "_LegIKViz.secondTerm") 0.7;
		setAttr ($modCore + "_LegIKViz.operation") 3;
			
		connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_KneeIKCtrl.v");
		connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_FootIKCtrl.v");
		connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_ToeIKCtrl.v");
		if (`objExists ($modCore + "_LowerLegIKCtrl")`)
		{
			connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_LowerLegIKCtrl.v");
			setAttr -lock true -keyable false -channelBox false ($modCore + "_LowerLegIKCtrl.v");
		}
		shadingNode -asUtility condition -n ($modCore + "_LegFKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_LegFKViz.firstTerm");
		setAttr ($modCore + "_LegFKViz.secondTerm") 0.3;
		setAttr ($modCore + "_LegFKViz.operation") 5;
		setAttr ($modCore + "_SwitchCtrl.switchIkFk") 0;	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_KneeFKCtrl.v");
		}
		else
		{
			connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_Knee1FKCtrl.v");
			connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_Knee2FKCtrl.v");
		}
		connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_AnkleFKCtrl.v");
		connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_BallFKCtrl.v");
		connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_ToeFKCtrl.v");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
		//MAKE FEET JOINTS VISIBLE
		setAttr ($modCore + "_AnkleJnt.overrideEnabled") 1;
	
		
		//JOINTS
		setAttr ($modCore + "_HipJntIK.v") 0;
		setAttr ($modCore + "_HipJntFK.v") 0;
		setAttr ($modCore + "_AnkleJntFK.v") 0;
	
	
		setAttr ($modCore + "_LegLengthOriginLctr.v") 0;
		setAttr ($modCore + "_AnkleJntFKGrp2.v") 0;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr ($modCore + "_KneeJntFKGrp2.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Knee1JntFKGrp2.v") 0;
			setAttr ($modCore + "_Knee2JntFKGrp2.v") 0;
		}
		
		
		setAttr ($modCore + "_KneeIKCtrl_TargetLctr.v") 0;
		
		//CONTROLS
		setAttr -l 1 -k 0 ($modCore + "_HipFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_HipFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_HipFKCtrl.v");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.v");
		}
		else
		{
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.v");
			
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.v");

			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.v");
			transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_LowerLegIKCtrl");
		}
		
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_FootIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_FootIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_FootIKCtrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.v");

		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.v");
		setAttr ($modCore + "_KneeIKConnectorCtrl.template") 1;

		setAttr ($modCore + "_LegIKHandle.v") 0;
		
		setAttr ($modCore + "_BallSwivelLctr.v") 0;	
		
		
		//LOCK GROUPS
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		select -cl;
		//ANKLE FK LOCATOR
		spaceLocator -n ($modCore + "_AnkleFKLctr");
		delete `parentConstraint ($modCore + "_FootIKCtrlGrp") ($modCore + "_AnkleFKLctr")`;
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_AnkleFKLctr");
		parent ($modCore + "_AnkleFKLctr") ($modCore + "_FootIKCtrlGrp");
		parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleFKLctr");
		
		//ANKLE IK LOCATOR
		spaceLocator -n ($modCore + "_AnkleIKLctr");
		delete `parentConstraint ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_AnkleIKLctr")`;
		parent ($modCore + "_AnkleIKLctr") ($modCore + "_AnkleFKCtrlGrp");
		orientConstraint -mo ($modCore + "_FootIKCtrl") ($modCore + "_AnkleIKLctr");
		setAttr ($modCore + "_AnkleIKLctr_orientConstraint1.interpType") 2;
		
		//KNEE FK LOCATOR
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			spaceLocator -n ($modCore + "_Knee_FKAimLctr");
			delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_Knee_FKAimLctr")`;
			parent ($modCore + "_Knee_FKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_Knee_FKAimLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_Knee1_FKAimLctr");
			parent ($modCore + "_Knee1_FKAimLctr") ($modCore + "_Knee1FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Knee1_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_KneeIKCtrl") ($modCore + "_Knee1_FKAimLctr")`;
	
			parent ($modCore + "_Knee1_FKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee1_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Knee1FKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_Knee1_FKAimLctr");
			
			spaceLocator -n ($modCore + "_Knee2_FKAimLctr");
			parent ($modCore + "_Knee2_FKAimLctr") ($modCore + "_Knee2FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Knee2_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_KneeIKCtrl") ($modCore + "_Knee2_FKAimLctr")`;
	
			parent ($modCore + "_Knee2_FKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee2_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Knee2FKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_Knee2_FKAimLctr");
		}		
		
		//HIP FK LOCATOR
		spaceLocator -n ($modCore + "_HipFKOrientLctr");
		delete `parentConstraint ($modCore + "_HipJnt") ($modCore + "_HipFKOrientLctr")`;
		parent ($modCore + "_HipFKOrientLctr") ($modCore + "_HipFKCtrlGrp");
		orientConstraint ($modCore + "_HipJntIK") ($modCore + "_HipFKOrientLctr");
		
		//HIDE SNAP LOCATORS
		setAttr ($modCore + "_HipFKOrientLctr.v") 0;
		if (`objExists ($modCore + "_Knee_FKAimLctr.v")`)
		{
			setAttr ($modCore + "_Knee_FKAimLctr.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Knee1_FKAimLctr.v") 0;
			setAttr ($modCore + "_Knee2_FKAimLctr.v") 0;
		}		
		setAttr ($modCore + "_AnkleIKLctr.v") 0;
		setAttr ($modCore + "_AnkleFKLctr.v") 0;
		
		setAttr ($modCore + "_HipIKLockLctr.v") 0;
		
		
		//PARENT TO MAIN CONTROL
		
		//SET ALL CONSTRAINTS TO SHORTEST INTERPOLATION
		string $selectedParentConstraints[] = `ls ($modCore + "*_parentConstraint1")`;
		for ($crntParentConstraint in $selectedParentConstraints)
		{setAttr ($crntParentConstraint + ".interpType") 2;}
		
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1.interpType") 2;
		
		if (`objExists ($modCore + "_HipCurveJnt")`)
		{
			setAttr ($modCore + "_LowerTwist75Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwist25Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwistHalfLctr_parentConstraint1.interpType") 2;
		}
		
		//HIERARCHY CLEAN-UP
		parent 
		($modCore + "_AnkleJntFKGrp2") 
		($modCore + "_FootIKCtrlGrp") ($modCore + "_KneeIKCtrlGrp") ($modCore + "_KneeIKCtrl_TargetLctr")
		($modCore + "_LegLengthOriginLctr") ($modCore + "_HipIKLockLctr")
		($modCore + "_SwitchCtrlGrp") ($modCore + "_HipFKCtrlGrp")
		
		($modCore + "_AnkleFKCtrlGrp") ($modCore + "_BallFKCtrlGrp") ($modCore + "_ToeFKCtrlGrp")
		($modCore + "_HipJnt") ($modCore + "_HipJntFK") ($modCore + "_HipJntIK")
		($modCore + "_ScaleGrp");
		
		//CREATE CONSTRAINT FOR WRIST IKCtrlGrp
		//CHECK IF ATTACHED TO ROOT
		if ($modAttachNode == "ROOT")
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modCore + "_FootIKCtrlGrp");
		}
		else
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_FootIKCtrlGrp");
		}

		//ADD DYNAMIC PARENTING CHANNELS
		addAttr -ln "follow" -at double  -min 1 -max 1 -dv 1 ($modCore + "_FootIKCtrl");
		setAttr -e -keyable true ($modCore + "_FootIKCtrl.follow");
		setAttr -lock true ($modCore + "_FootIKCtrl.follow");
		if ($modAttachNode != "ROOT")
		{
			addAttr -ln "parent" -at double -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");
			setAttr -e-keyable true ($modCore + "_FootIKCtrl.parent");
		}
		addAttr -ln "ROOT"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");
		setAttr -e-keyable true ($modCore + "_FootIKCtrl.ROOT");

		addAttr -ln "ROOTType" -at "enum" -en "ROOTC:ROOTsecondaryC:" ($modCore + "_FootIKCtrl");
		setAttr -e-keyable true ($modCore + "_FootIKCtrl.ROOTType");


		//IK WRIST DYNAMIC CONSTRAINTS
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_FootIKCtrl.parent") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW3");
		}
		
		//ROOT CONNECTIONS
		shadingNode -asUtility multiplyDivide -n ($modCore + "_FootIKROOTInf_MD");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOT") ($modCore + "_FootIKROOTInf_MD.input1X");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOT") ($modCore + "_FootIKROOTInf_MD.input1Y");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOTType") ($modCore + "_FootIKROOTInf_MD.input2Y");
		
		shadingNode -asUtility reverse -n ($modCore + "_FootIKROOTInf_Reverse");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOTType") ($modCore + "_FootIKROOTInf_Reverse.inputX");
		connectAttr -f ($modCore + "_FootIKROOTInf_Reverse.outputX") ($modCore + "_FootIKROOTInf_MD.input2X");

		connectAttr -f ($modCore + "_FootIKROOTInf_MD.outputX") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -f ($modCore + "_FootIKROOTInf_MD.outputY") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_ROOTSecondaryCtrlW2");
		
		shadingNode -asUtility plusMinusAverage -n ($modCore + "_FootIKParent_PMA");
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_FootIKCtrl.parent") ($modCore + "_FootIKParent_PMA.input1D[0]");
		}
		connectAttr -f ($modCore + "_FootIKCtrl.ROOT") ($modCore + "_FootIKParent_PMA.input1D[1]");
		
		shadingNode -asUtility condition -n ($modCore + "_FootIKParent_Condition");
		setAttr ($modCore + "_FootIKParent_Condition.operation") 4;
		setAttr ($modCore + "_FootIKParent_Condition.secondTerm") 1;
		connectAttr -f ($modCore + "_FootIKParent_PMA.output1D") ($modCore + "_FootIKParent_Condition.firstTerm");
		connectAttr -force ($modCore + "_FootIKParent_PMA.output1D") ($modCore + "_FootIKParent_Condition.colorIfTrueR");
		
		shadingNode -asUtility reverse -n ($modCore + "_FootIKParent_Reverse");
		connectAttr -f ($modCore + "_FootIKParent_Condition.outColorR") ($modCore + "_FootIKParent_Reverse.inputX");
		connectAttr -f ($modCore + "_FootIKParent_Reverse.outputX") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");


		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		
		//SINGLE KNEE
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			//ANKLE IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_AnkleIKtoFKLctr");
			setAttr ($modCore + "_AnkleIKtoFKLctr.rotateOrder") 1;
			group -n ($modCore + "_AnkleIKtoFKLctrGrp") ($modCore + "_AnkleIKtoFKLctr");
			delete `parentConstraint ($modCore + "_FootIKCtrl") ($modCore + "_AnkleIKtoFKLctrGrp")`;
			parentConstraint -mo ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleIKtoFKLctr");
			parent ($modCore + "_AnkleIKtoFKLctrGrp") ($modCore + "Grp");
			
			//ANKLE FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_AnkleFKtoIKLctr");
			group -n ($modCore + "_AnkleFKtoIKLctrGrp2") ($modCore + "_AnkleFKtoIKLctr");
			group -n ($modCore + "_AnkleFKtoIKLctrGrp") ($modCore + "_AnkleFKtoIKLctrGrp2");
			rotate 0 0 -90 ($modCore + "_AnkleFKtoIKLctrGrp2");
			delete `pointConstraint ($modCore + "_AnkleJnt") ($modCore + "_AnkleFKtoIKLctrGrp")`;
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "scene" -skip x -skip z ($modCore + "_BallJnt") ($modCore + "_ToeJnt") ($modCore + "_AnkleFKtoIKLctrGrp");
			delete ($modCore + "_AnkleFKtoIKLctrGrp_aimConstraint1");
			parentConstraint -mo ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_AnkleFKtoIKLctrGrp");
			orientConstraint -mo ($modCore + "_FootIKCtrl") ($modCore + "_AnkleFKtoIKLctr");
			setAttr ($modCore + "_AnkleFKtoIKLctr_orientConstraint1.interpType") 2;
			parent ($modCore + "_AnkleFKtoIKLctrGrp") ($modCore + "_ScaleGrp");
			
			//KNEE IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_KneeIKtoFKAimLctr");
			delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKtoFKAimLctr")`;
			parent ($modCore + "_KneeIKtoFKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKtoFKAimLctr");
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_KneeIKtoFKAimLctr");
			
			//HIP FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_HipFKtoIKOrientLctr");
			delete `parentConstraint ($modCore + "_HipFKCtrlGrp") ($modCore + "_HipFKtoIKOrientLctr")`;
			parent ($modCore + "_HipFKtoIKOrientLctr") ($modCore + "_HipFKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_HipFKtoIKOrientLctr");
			orientConstraint -mo ($modCore + "_HipJntIK") ($modCore + "_HipFKtoIKOrientLctr");
			
				
			//HIDE SNAP LOCATORS
			setAttr ($modCore + "_KneeIKtoFKAimLctr.v") 0;
			setAttr ($modCore + "_AnkleFKtoIKLctr.v") 0;
			setAttr ($modCore + "_AnkleIKtoFKLctr.v") 0;
			
			setAttr ($modCore + "_HipIKLockLctr.v") 0;
			setAttr ($modCore + "_HipFKtoIKOrientLctr.v") 0;
		}
		//KNEE HIERARCHY CLEANUP		
		if (`objExists ($modCore + "_KneeJntFKGrp2")`)
		{
			parent ($modCore + "_KneeJntFKGrp2")  ($modCore + "_KneeFKCtrlGrp")
			($modCore + "_ScaleGrp");
		}
		else
		{
			parent ($modCore + "_Knee1FKCtrlGrp") ($modCore + "_Knee2FKCtrlGrp")
			($modCore + "_Knee1JntFKGrp2") ($modCore + "_Knee2JntFKGrp2")
			($modCore + "_ScaleGrp");
		}
	
		//CHECK POLE VECTOR
		if (`objExists ($modCore + "_Knee1Jnt")`)
		{
			$lhipOrient = `getAttr ($modCore + "_HipJnt.rotate")`;
			if ($lhipOrient[0] > 90 || $lhipOrient[0] < -90 || $lhipOrient[2] > 90 || $lhipOrient[2] < -90)
			{
				setAttr ($modCore + "_LegIKHandle.twist") 180;
			}
				
		}

		select $topNode;
		
		if (`objExists ("RRM_" + $prfx + $core + "_Lower1")` || `objExists ("RRM_" + $prfx + $core + "_Middle1")` || `objExists ("RRM_" + $prfx + $core + "_Upper1")`)
		{
			RRM_ToonLimbs($modName, "leg", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, ($modName + "_" + $modAttachNode + "Jnt"), $topNode);
		}
	
		//ADD JOINT ANGLE ATTRIBUTES
		addAttr -ln "hipAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "hipAngleX");
		addAttr -ln "hipAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "hipAngleY");
		addAttr -ln "hipAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "hipAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			addAttr -ln "kneeAngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable true ($modCore + "_SwitchCtrl.kneeAngleY");
		}
		else
		{
			addAttr -ln "knee1AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable true ($modCore + "_SwitchCtrl.knee1AngleY");
			addAttr -ln "knee2AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable true ($modCore + "_SwitchCtrl.knee2AngleY");
		}
		
		addAttr -ln "ankleAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "ankleAngleX");
		addAttr -ln "ankleAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "ankleAngleY");
		addAttr -ln "ankleAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable true ($modCore + "_SwitchCtrl." + "ankleAngleZ");
		
		//CONNECT JOINT ANGLE ATTRIBUTES
		connectAttr -force ($modCore + "_HipJnt.rotateX") ($modCore + "_SwitchCtrl.hipAngleX");
		connectAttr -force ($modCore + "_HipJnt.rotateY") ($modCore + "_SwitchCtrl.hipAngleY");
		connectAttr -force ($modCore + "_HipJnt.rotateZ") ($modCore + "_SwitchCtrl.hipAngleZ"); 
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			connectAttr -force ($modCore + "_KneeJnt.rotateY") ($modCore + "_SwitchCtrl.kneeAngleY");
		}
		else
		{
			connectAttr -force ($modCore + "_Knee1Jnt.rotateY") ($modCore + "_SwitchCtrl.knee1AngleY");
			connectAttr -force ($modCore + "_Knee2Jnt.rotateY") ($modCore + "_SwitchCtrl.knee2AngleY");
		}
			
	
		connectAttr -force ($modCore + "_AnkleJnt.rotateX") ($modCore + "_SwitchCtrl.ankleAngleX");
		connectAttr -force ($modCore + "_AnkleJnt.rotateY") ($modCore + "_SwitchCtrl.ankleAngleY");
		connectAttr -force ($modCore + "_AnkleJnt.rotateZ") ($modCore + "_SwitchCtrl.ankleAngleZ");
		
		setAttr -lock true ($modCore + "_SwitchCtrl.hipAngleX");  
		setAttr -lock true ($modCore + "_SwitchCtrl.hipAngleY");  
		setAttr -lock true ($modCore + "_SwitchCtrl.hipAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			setAttr -lock true ($modCore + "_SwitchCtrl.kneeAngleY");
		}
		else
		{
			setAttr -lock true ($modCore + "_SwitchCtrl.knee1AngleY");
			setAttr -lock true ($modCore + "_SwitchCtrl.knee2AngleY");
		}
		
		setAttr -lock true ($modCore + "_SwitchCtrl.ankleAngleX");  
		setAttr -lock true ($modCore + "_SwitchCtrl.ankleAngleY");  
		setAttr -lock true ($modCore + "_SwitchCtrl.ankleAngleZ");


		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			if (!`objExists ($crntModControl + ".modCoreName")`)
			{
				addAttr -ln "modCoreName"  -dt "string" $crntModControl;
				setAttr -e-keyable true ($crntModControl + ".modCoreName");
				setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
				setAttr -e-lock true ($crntModControl + ".modCoreName");

				//ADD MODULE TYPE
				addAttr -ln "moduleType"  -dt "string" ($crntModControl);
				setAttr -e -keyable true ($crntModControl + ".moduleType");
				setAttr -type "string" ($crntModControl + ".moduleType") "leg";
				setAttr -l true ($crntModControl + ".moduleType");
			}
		}
	
		//SET UP FOR RIGHT SIDE
		$mirrorInt++;
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$inverseFront = 1;
	
		if (!`objExists ($topNode + ".pair")`)
		{
			$i = 2;
		}
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE FK CHAIN MODULE/////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigFkChain(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     

	//INTEGER FOR LOOP
	$mirrorInt = 1;
	$multiplier = 1;
	float $rotOffset = 0;

	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	string $oppPrfx = "";

	$crntSide = "";
	$oppSide = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 0;
		$crntSide = "left";
		$oppSide = "right";
	}
	
	while ($mirrorInt <= 1)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
						
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "fkChain";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$fkChains = `ls ("RRM_" + $prfx + $core + "_??_01")`;
		$fkChainsNum = `size $fkChains`;
	
		addAttr -ln "fkChains"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.fkChains") ;
		setAttr -type "string" ($modCore + "Grp.fkChains") $fkChainsNum;
		setAttr -l true ($modCore + "Grp.fkChains");
		
		select ;
		$fkjointsPerChain = `ls ("RRM_" + $prfx + $core + "_01_??")`;
		$fkjointsPerChainNum = `size $fkjointsPerChain`;
	
		addAttr -ln "jointsPerChain"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.jointsPerChain") ;
		setAttr -type "string" ($modCore + "Grp.jointsPerChain") $fkjointsPerChainNum;
		setAttr -l true ($modCore + "Grp.jointsPerChain");
		
		//SCALE GROUP
		spaceLocator -n ($modCore + "_AveragePosition_Lctr");
		parentConstraint $fkChains ($modCore + "_AveragePosition_Lctr");
		group -em -n ($modCore + "_ScaleGrp");

		//GROUP FOR NODES
		group -em -n ($modCore + "_curveNodesGrp");
		parent ($modCore + "_curveNodesGrp") ($modCore + "_ScaleGrp");
		group -em -n ($modCore + "_extraCurveNodesGrp");
		setAttr ($modCore + "_extraCurveNodesGrp.inheritsTransform") 0; 
		parent ($modCore + "_extraCurveNodesGrp") ($modName + "_MAINCtrl");

		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modCore + "_AveragePosition_Lctr") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modCore + "_AveragePosition_Lctr") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		delete ($modCore + "_AveragePosition_Lctr");
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
							
		$allJoints = `ls ("RRM_" + $prfx + $core + "_??_??")`;
		$sizeAllJoints = `size $allJoints`;
		$fKChain = `ls ("RRM_" + $prfx + $core + "_??_01")`;
		$fKChainSize = `size $fKChain`;
		$crntCh = 1;
		$crntJnt = 1;
		
		//MASTER CONTROLLER
		circle -n ($modCore + "_MasterCtrl") -c 0 0 0 -nr 5 0 0 -sw 360 -r 1 -d 1 -ut 0 -tol 0 -s 4 -ch 0;
		rotate -r 45 0 0 ($modCore + "_MasterCtrl");
		makeIdentity -apply true -r 1 ($modCore + "_MasterCtrl");
		group -n ($modCore + "_MasterCtrlGrp") ($modCore + "_MasterCtrl");
		spaceLocator -n ($modCore + "_MasterCtrl_StartAttachLctr");
		spaceLocator -n ($modCore + "_MasterCtrl_EndAttachLctr");
		pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_MasterCtrl_StartAttachLctr");
		aimConstraint -offset 0 0 0 -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "objectRotation" -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
		$fKChain ($modCore + "_MasterCtrl_StartAttachLctr");
		pointConstraint $fKChain ($modCore + "_MasterCtrl_EndAttachLctr");
		delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_MasterCtrl_EndAttachLctr") ($modCore + "_MasterCtrlGrp")`;
		delete `orientConstraint ($modCore + "_MasterCtrl_StartAttachLctr") ($modCore + "_MasterCtrlGrp")`;
		parent ($modCore + "_MasterCtrlGrp") ($modCore + "_ScaleGrp");
		delete ($modCore + "_MasterCtrl_StartAttachLctr") ($modCore + "_MasterCtrl_EndAttachLctr");
		
		if ($fKChainSize > 1)
		{
			spaceLocator -n ($modCore + "_MasterCtrl_SizeStartLctr");
			spaceLocator -n ($modCore + "_MasterCtrl_SizeEndLctr");
			parent ($modCore + "_MasterCtrl_SizeEndLctr") ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint $fKChain[0] ($modCore + "_MasterCtrl_SizeStartLctr");
			aimConstraint -offset 0 0 0 -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "none" $fKChain[($fKChainSize - 1)] ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint $fKChain[($fKChainSize - 1)] ($modCore + "_MasterCtrl_SizeEndLctr");
			float $chains = `getAttr ($modCore + "_MasterCtrl_SizeEndLctr.tx")`;
			scale -r 1 ($chains * .8) ($chains * .3) ($modCore + "_MasterCtrl");
			makeIdentity -apply true -s 1 ($modCore + "_MasterCtrl");
			delete ($modCore + "_MasterCtrl_SizeStartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_MasterCtrl_SizeStartLctr");
			spaceLocator -n ($modCore + "_MasterCtrl_SizeEndLctr");
			parent ($modCore + "_MasterCtrl_SizeEndLctr") ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_MasterCtrl_SizeStartLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $fKChain[0] ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint $fKChain[0] ($modCore + "_MasterCtrl_SizeEndLctr");
			float $chains = `getAttr ($modCore + "_MasterCtrl_SizeEndLctr.tx")`;
			scale -r 1 ($chains * .8) ($chains * .3) ($modCore + "_MasterCtrl");
			makeIdentity -apply true -s 1 ($modCore + "_MasterCtrl");
			delete ($modCore + "_MasterCtrl_SizeStartLctr");
		}
			
		//PARENT ORIENT
		$parentOrient = ($modCore + "_MasterCtrl");
		RRM_ParentOrient($modCore, $modName, $modAttachNode, $parentOrient); 
		
		//CONTROLLER SIZE
		float $controllerSize = 1;
		float $fKChainDistance = 1;
		spaceLocator -n ($modCore + "_StartLctr");
		spaceLocator -n ($modCore + "_EndLctr");
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");					
	
		if ($sizeAllJoints >1)
		{
			pointConstraint $allJoints[0] ($modCore + "_StartLctr");
			aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $allJoints[($sizeAllJoints - 1)] ($modCore + "_StartLctr");
			pointConstraint $allJoints[($sizeAllJoints - 1)] ($modCore + "_EndLctr");
			$fKChainDistance = `getAttr ($modCore + "_EndLctr.tx")`;
			$controllerSize = ($fKChainDistance/$sizeAllJoints * 2);
		}
		else 
		{				
			pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_StartLctr");
			aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $allJoints[0] ($modCore + "_StartLctr");
			pointConstraint $allJoints[0] ($modCore + "_EndLctr");
			$fKChainDistance = `getAttr ($modCore + "_EndLctr.tx")`;
			$controllerSize = ($fKChainDistance/$sizeAllJoints * 0.5);
		}
		delete ($modCore + "_StartLctr");
		
		//MAIN GROUP TO ATTACH CHAINS TO PARENT CONTROL
		group -em -n ($modCore + "_MainChainCtrlGrp");
		parent ($modCore + "_MainChainCtrlGrp") ($modCore + "_ScaleGrp");
		
		if ($fKChainSize > 2)
		{
				addAttr -ln "FkAutoSpreadPos"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
				setAttr -e-keyable true ($modCore + "_MasterCtrl.FkAutoSpreadPos");
				addAttr -ln "FkAutoSpreadRot"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
				setAttr -e-keyable true ($modCore + "_MasterCtrl.FkAutoSpreadRot");
		}
		
		//ADD SPLINE ATTRIBUTES
		addAttr -ln "splineEffect"  -at "enum" -en "Settings:"  ($modCore + "_MasterCtrl");
		setAttr -e-keyable true -l true ($modCore + "_MasterCtrl.splineEffect");

		addAttr -ln "blendedAdditive"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_MasterCtrl");
		setAttr -e-keyable true ($modCore + "_MasterCtrl.blendedAdditive");

		if ($fKChainSize > 2)
		{
			addAttr -ln "splineAutoSpreadPos"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
			setAttr -e-keyable true ($modCore + "_MasterCtrl.splineAutoSpreadPos");

			addAttr -ln "splineAutoSpreadRot"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
			setAttr -e-keyable true ($modCore + "_MasterCtrl.splineAutoSpreadRot");
		}
		$doubleLoop = 0;
		$type = "";
		while ($doubleLoop < 2)
		{
			if ($doubleLoop == 0)
			{
			}
			if ($fKChainSize > 2)
			{
				spaceLocator -n ($modCore + "_SpreadTranslate_" + $type + "StartLctr");
				spaceLocator -n ($modCore + "_SpreadTranslate_" + $type + "EndLctr");
				spaceLocator -n ($modCore + "_SpreadRotate_" + $type + "StartLctr");
				spaceLocator -n ($modCore + "_SpreadRotate_" + $type + "EndLctr");
			
				string $nPdCh = "_";
				if ($fKChainSize < 10)
				{
					$nPdCh = "_0";
				}
				
				delete `parentConstraint ("RRM_" + $prfx + $core + "_01_01") ($modCore + "_SpreadTranslate_" + $type + "StartLctr")`;
				delete `parentConstraint ("RRM_" + $prfx + $core + "_01_01") ($modCore + "_SpreadRotate_" + $type + "StartLctr")`;
				delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $fKChainSize + "_01")($modCore + "_SpreadTranslate_" + $type + "EndLctr")`;
				delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $fKChainSize + "_01")($modCore + "_SpreadRotate_" + $type + "EndLctr")`;
	
				if ($doubleLoop == 0)
				{
					//CREATE REVERSE NODE TO TURN OFF INFLUENCE OF MASTER CONTROL
					shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SpreadPos_Reverse");
					connectAttr -force ($modCore + "_MasterCtrl.FkAutoSpreadPos") ($modCore + "_MasterCtrl_SpreadPos_Reverse.inputX");

					shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SpreadRot_Reverse");
					connectAttr -force ($modCore + "_MasterCtrl.FkAutoSpreadRot") ($modCore + "_MasterCtrl_SpreadRot_Reverse.inputX");

					shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SplineSpreadPos_Reverse");
					connectAttr -force ($modCore + "_MasterCtrl.splineAutoSpreadPos") ($modCore + "_MasterCtrl_SplineSpreadPos_Reverse.inputX");

					shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SplineSpreadRot_Reverse");
					connectAttr -force ($modCore + "_MasterCtrl.splineAutoSpreadRot") ($modCore + "_MasterCtrl_SplineSpreadRot_Reverse.inputX");
				}
				
				parent  ($modCore + "_SpreadTranslate_" + $type + "StartLctr") ($modCore + "_ScaleGrp");
				parent  ($modCore + "_SpreadTranslate_" + $type + "EndLctr") ($modCore + "_ScaleGrp");
				parent  ($modCore + "_SpreadRotate_" + $type + "StartLctr") ($modCore + "_ScaleGrp");
				parent  ($modCore + "_SpreadRotate_" + $type + "EndLctr") ($modCore + "_ScaleGrp");
				
				setAttr ($modCore + "_SpreadTranslate_" + $type + "StartLctr.v") 0;
				setAttr ($modCore + "_SpreadTranslate_" + $type + "EndLctr.v") 0;
				setAttr ($modCore + "_SpreadRotate_" + $type + "StartLctr.v") 0;
				setAttr ($modCore + "_SpreadRotate_" + $type + "EndLctr.v") 0;
			}
			$type = "Spline";
			$doubleLoop++;
		}
		
	
		for ($crntFKChain in $fKChain)                                    
		{
			string $nPdCh = "_";
			if ($crntCh < 10)
			{
				$nPdCh = "_0";
			}
	
			$fKJoints = `ls ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + "??")`;
			$fKJointSize = `size $fKJoints`;
			string $crntFKJoint;
			int $crntJnt = 1;
			for ($crntFKJoint in $fKJoints)
			{
				string $nPd = "";
				if ($crntJnt < 10)
				{
					$nPd = "0";
				}
				$nextJnt = ($crntJnt + 1);
				$nPdNext = "";
				if ($nextJnt <10)
				{
					$nPdNext = "0";
				}
				$previousJnt = ($crntJnt - 1);
				$nPdPrev = "";
				if ($previousJnt <10)
				{
					$nPdPrev = "0";
				}
				select -cl;
				joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
				select -cl;
				joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.v") 0;
				select -cl;
				joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.v") 0;
				
				if ($crntJnt == 1)
				{
					//GET JOINT DIRECTION
					$upPos = `xform -q -ws -t  ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "DShape.cv[1]")`;
					$aimPos = `xform -q -ws -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[1]")`;
					spaceLocator -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr");
					spaceLocator -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr");
					setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr.translate"), $upPos[0], $upPos[1], $upPos[2]);
					setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr.translate"), $aimPos[0], $aimPos[1], $aimPos[2]);


					group -n ($modCore + $nPdCh + $crntCh + "JntGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
					group -n ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntGrp");
					group -n ($modCore + $nPdCh + $crntCh + "JntFKGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
					group -n ($modCore + $nPdCh + $crntCh + "JntFKGrp2") ($modCore + $nPdCh + $crntCh + "JntFKGrp");
					group -n ($modCore + $nPdCh + $crntCh + "JntIKGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
					group -n ($modCore + $nPdCh + $crntCh + "JntIKGrp2") ($modCore + $nPdCh + $crntCh + "JntIKGrp");
					parent ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntFKGrp2")
					($modCore + $nPdCh + $crntCh + "JntIKGrp2") ($modCore + "_ScaleGrp");

					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntFKGrp2")`;
					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntGrp2")`;
					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntIKGrp2")`;

					delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntGrp2")`;
					delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntFKGrp2")`;
					delete `aimConstraint -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntIKGrp2")`;
					makeIdentity -apply true -t 1 ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntFKGrp2")
					($modCore + $nPdCh + $crntCh + "JntIKGrp2");
					
					delete ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr");
				
					//CREATE BLEND
					addAttr -ln ("splineIK" + $nPdCh + $crntCh + "Inf") -at double  -min 0 -max 1 -dv 0 ($modCore + "_MasterCtrl");
					setAttr -e-keyable true ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf");
				}
				else
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK") ($modCore + "_ScaleGrp");
				}					
				
				
				if ($crntSide == "right" && $fKJointSize > 1)
				{
					select -cl;
					joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide");
					setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide.v") 0;
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + "_ScaleGrp");
				}

				//MAIN CONTROL
				circle -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0 -s 8 -ch 1;
				scale -r 1 1 0.667 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.cv[3]") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.cv[7]") ;
	
				scale -r 1 ($controllerSize * 2) ($controllerSize * 1) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
				makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
				delete -ch ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
					
				group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp2") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
				group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp2");
				delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;
				
				if ($fKJointSize > 1)
				{
					if ($crntFKJoint == 1)
					{
						if ($crntSide == "left" || $crntSide == "")
						{
							parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK") ($modCore + "_extraCurveNodesGrp");
						}
						else
						{
							parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + "_extraCurveNodesGrp");
						}
					}
	
					//SPLINE CONTROL
					circle -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") -c 0 0 0 -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0 -s 8 -ch 1;
					scale -r 0.5 0.9 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.cv[3]") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.cv[7]") ;
		
					scale -r ($controllerSize * $multiplier * 1) ($controllerSize * $multiplier * 0.5) 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
					makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
					delete -ch ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
					
					move -r -os -wd 0 ($controllerSize * $multiplier *2) 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.cv[0:7]");
						
					group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp2") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl"); xform -os -piv 0 0 0;
					group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp2"); xform -os -piv 0 0 0;
					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp")`;
				}
				
				//PARENT CONSTRAIN GROUPS FOR SPREADING
				if ($fKChainSize > 2 && $crntJnt == 1 && $crntCh != 1 && $crntCh != $fKChainSize)
				{
					//ONCE FOR FK AND ONCE FOR SPLINE
					$type = "";
					$spreadPos = ".FkAutoSpreadPos";
					$spreadRot = ".FkAutoSpreadRot";
					int $doubleLoop = 0;
					while ($doubleLoop < 2)
					{
						//print ("$crntJnt is " + $crntJnt + "\n");
						//print ("$type is " + $type + "\n");
						//CREATE GROUP AND CONSTRAINT
						group -em -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp") ($modCore + "_MainChainCtrlGrp");
						delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp")`;
						parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_MainChainCtrlGrp") ($modCore + "_SpreadTranslate_" + $type + "StartLctr") ($modCore + "_SpreadTranslate_" + $type + "EndLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + "_MainChainCtrlGrp") ($modCore + "_SpreadRotate_" + $type + "StartLctr") ($modCore + "_SpreadRotate_" + $type + "EndLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						
						//ADD ATTRIBUTES AND SET WEIGHTS
						float $crntChFloat = ($crntCh - 1);
						float $fKChainSizeFloat = ($fKChainSize - 1);
						float $spreadVal = ($crntChFloat/$fKChainSizeFloat);
	
						addAttr -ln "translateSpreadVal" -at double -min 0 -max 1 -dv $spreadVal ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl");
						setAttr -e -keyable true ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal");
						addAttr -ln "rotateSpreadVal" -at double -min 0 -max 1 -dv $spreadVal ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl");
						setAttr -e -keyable true ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.rotateSpreadVal");
						
						//CREATE MD NODE FOR TRANSLATE START AND END LOCATOR WEIGHTS
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadPos) ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input1X");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadPos) ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input1Y");
	
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadRot) ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input1X");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadRot) ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input1Y");

						//CONNECT REVERSE NODE TO TURN OFF INFLUENCE OF MASTER CONTROL
						connectAttr -force ($modCore + "_MasterCtrl_" + $type + "SpreadPos_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint1." + $modCore + "_MainChainCtrlGrpW0");
						connectAttr -force ($modCore + "_MasterCtrl_" + $type + "SpreadRot_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint2." + $modCore + "_MainChainCtrlGrpW0");
						
						//CONNECT CONSTRAINT WEIGHTS TO MD NODE
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal") ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input2X");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.rotateSpreadVal") ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input2X");
						//REVERSE NODE FOR INVERTED VALUE
						shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Translate" + $type + "Spread_Reverse");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Translate" + $type + "Spread_Reverse.inputX");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Translate" + $type + "Spread_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input2Y");
						
						shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Rotate" + $type + "Spread_Reverse");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Rotate" + $type + "Spread_Reverse.inputX");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Rotate" + $type + "Spread_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input2Y");
	
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.outputY") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint1." + $modCore + "_SpreadTranslate_" + $type + "StartLctrW1");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.outputY") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint2." + $modCore + "_SpreadRotate_" + $type + "StartLctrW1");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint1." + $modCore + "_SpreadTranslate_" + $type + "EndLctrW2");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint2." + $modCore + "_SpreadRotate_" + $type + "EndLctrW2");
						
						if ($fKJointSize == 1)
						{//DON'T LOOP IF THERE IS ONLY ONE JOINT PER CHAIN
							$doubleLoop = 2;
						}
						$type = "Spline";
						$spreadPos = ".splineAutoSpreadPos";
						$spreadRot = ".splineAutoSpreadRot";
						$doubleLoop++;
					}
				}
				else if ($fKJointSize > 1)
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp") ($modCore + "_MainChainCtrlGrp");
				}
				else
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + "_MainChainCtrlGrp");
				}
					
				//ORIENT JOINT
				if (`objExists ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPdNext + $nextJnt)`)
				{
					//GET LOCATION OF TOP CV
					$proxyAim = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[1]")`;
					$proxyUp = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "DShape.cv[1]")`;
					//CREATE LOCATOR
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					move -r $proxyAim[0] $proxyAim[1] $proxyAim[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					move -r $proxyUp[0] $proxyUp[1] $proxyUp[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					
					delete `aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
					("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;

					scale -r 1 0.667 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
					makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");

					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
				}
				else
				{
					delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;
					//GET ORIENTATION USING THE END POINT OF THE END CONTROL
					$proxyAim = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "DShape.cv[1]")`;
					$ProxyUp = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[5]")`;
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					move -r $proxyAim[0] $proxyAim[1] $proxyAim[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					move -r $ProxyUp[0] $ProxyUp[1] $ProxyUp[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					
					delete `aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
					("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;

					scale -r 1 0.667 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
					makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");

					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
				}
				
				if ($fKJointSize > 1)
				{
					//ORIENT SPLINE CONTROLS
					if ($crntJnt == 1)
					{
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "JntFKGrp");
	
						//CONNECT BLEND
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.color2");
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.color2");
						
						//CREATE ADD
						
						//CREATE BLENDS TO DISABLE ADD
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.color1");
						$JntIK_Pos = `getAttr ($modCore + $nPdCh + $crntCh + "JntIKGrp.translate")`;
						setAttr (($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.color2"), $JntIK_Pos[0], $JntIK_Pos[1], $JntIK_Pos[2]);
	
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd");
						connectAttr -f ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.color1");
						$JntIK_Rot = `getAttr ($modCore + $nPdCh + $crntCh + "JntIKGrp.rotate")`;
						setAttr (($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.color2"), $JntIK_Rot[0], $JntIK_Rot[1], $JntIK_Rot[2]);
						
						shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.input3D[0]");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.input3D[1]");
	
						shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.input3D[0]");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.input3D[1]");
						
						//CREATE MASTER BLEND FOR BLEND AND ADD
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd");
						connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.output3D") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.color2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp.translate");
	
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd");
						connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.output3D") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.color2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp.rotate");
					}
					else
					{
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK")`;
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt")`;
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK")`;
						makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt")
						($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
					}
						
					parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
					
					if ($crntSide == "right" && $fKJointSize > 1)
					{
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide")`;
						rotate -r -os 0 180 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide");
						makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide");
					}
					
					
					//SCALE CONSTRAINT FK JOINTS TO CONTROLS
					if ($crntJnt == 1)
					{
						//scaleConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.scale");
					}
					else
					{
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD.input1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD.input2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.scale");
					}
						
					if ($crntJnt != 1)
					{
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp");
						//scaleConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp.scale");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Jnt");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntIK");
						if ($crntSide == "right")
						{
							parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntIKGuide");
						}
	
						if ($fKJointSize > 1)
						{
							//ORIENT SPLINE CONTROLS
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp")`;
							parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_ScaleGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp");
	
							if ($crntJnt != 1)
							{
								//ADD ATTRIBUTES TO THE CONTROLS
								addAttr -ln "followAmount" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
								setAttr -e-keyable true ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount");
		
								addAttr -ln "parentInfluence" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
								setAttr -e-keyable true ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.parentInfluence");
								
								//ATTRIBUTE CONNECTIONS
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
								shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_MD");
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_ParentInf_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_MD.input1X");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_MD.input1Y");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.parentInfluence") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_MD.input2X");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.parentInfluence") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_ParentInf_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_ParentInf_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_MD.input2Y");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "SplineCtrlW2");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_MD.outputY") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modCore + "_ScaleGrpW1");
							}
						}
					}
					else if ($crntJnt == 1 && $fKJointSize > 1)
					{
						//ORIENT SPLINE CONTROLS
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp")`;
						if ($crntCh == 1 || $crntCh == $fKChainSize)
						{
							parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_ScaleGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp");
						}
						//parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "JntIKGrp");
						parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "JntIKGrp");
	
						//ADD ATTRIBUTES TO THE FIRST CONTROL
						addAttr -ln "followAmount" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
						setAttr -e-keyable true ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount");
						
						addAttr -ln "stretch" -at double -min 0 -max 1 -dv 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
						setAttr -e-keyable true ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.stretch");
						
						addAttr -ln "autoVolume" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
						setAttr -e-keyable true ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.autoVolume");
	
						//ATTRIBUTE CONNECTIONS
						if ($crntCh == 1 || $crntCh == $fKChainSize)
						{
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modCore + "_ScaleGrpW1");
							shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_Rev");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_Rev.inputX");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_Follow_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
						}
	
						//CONNECT SPLINE ATTRIBUTE TO CONDITIONALS FOR THE VISIBILITY OF THE CONTROLS
						shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition");
						connectAttr -f ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.firstTerm");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.secondTerm") 0;
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.operation") 0;
						
						shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition");
						connectAttr -f ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.firstTerm");
						setAttr ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.secondTerm") 1;
						setAttr ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.operation") 0;
						
						//CREATE CONDITIONAL TO OVERRIDE VISIBILITY IF ADDITIVE IS ON.
						shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition");
						connectAttr -f ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.firstTerm");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.colorIfTrueR");
					}
					
					if ($fKJointSize > 1)
					{
						//CREATE BLEND FOR THE STARTING GROUP IF IT DOESN'T ALREADY EXIST
						//CONNECT SPLINE ATTRIBUTE TO BLEND THE SKINNING JOINTS
						//BLENDS
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.color2");
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.color2");
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.color2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.scale");
						
						//ADDS
						//CREATE BLENDS TO DISABLE ADD
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.color1");
						$JntFK_Pos = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.translate")`;
						setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.color2"), $JntFK_Pos[0], $JntFK_Pos[1], $JntFK_Pos[2]);
	
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd");
						connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.color1");
						$JntFK_Rot = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.rotate")`;
						setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.color2"), $JntFK_Rot[0], $JntFK_Rot[1], $JntFK_Rot[2]);
	
						shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma.input3D[0]");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma.input3D[1]");
	
						shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma.input3D[0]");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma.input3D[1]");
						
						//CREATE SUBTRACT TO ZERO OUT JOINTS
						$jointTranslate = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.translate")`;
						shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma");
						setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.operation") 2;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.input3D[0]");
						setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.input3D[1]"), ($jointTranslate[0]*1), ($jointTranslate[1]*1), ($jointTranslate[2]*1));
						
						//CREATE MASTER BLEND FOR BLEND AND ADD
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd");
						connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.output")  ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.color2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.translate");
	
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd");
						connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.blender");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.color1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.output")  ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.color2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.rotate");
				
						//CONNECT SPLINE ATTRIBUTE TO THE VISIBILITY OF THE CONTROLS
						connectAttr -f  ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.v");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.v");
						setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.v");
						setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.v");
	
					}
					//ORIENT CONSTRAINT RIGHT IK JOINTS TO GUIDE JOINTS
					if ($crntSide == "right" && $fKJointSize > 1)
					{
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
						connectAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.scale");
					}
						
					//CREATE SPLINE IK
					if (($crntJnt == $fKJointSize) && ($fKJointSize > 2))
					{
						$JntIK = "JntIK";
						if ($crntSide == "right")
						{
							$JntIK = "JntIKGuide";
						}
						
						select ($modCore + $nPdCh + $crntCh + "_01" + $JntIK) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK);
						ikHandle -n ($modCore + $nPdCh + $crntCh + "_IKHandle") -sol ikSplineSolver -scv false;
						$SplineCurve = `listConnections -type "nurbsCurve" ($modCore + $nPdCh + $crntCh + "_IKHandle")`;
						rename $SplineCurve ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						arclen -ch 1 ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						$curveInfoNode = `listConnections -t curveInfo -d 1 -s 0 ($modCore + $nPdCh + $crntCh + "_SplineCurveShape")`;
						rename $curveInfoNode[0] ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_SplineCurve.v");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurve.template") 1;

						addAttr -ln "nonControl"  -dt "string" ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						setAttr -e-keyable true ($modCore + $nPdCh + $crntCh + "_SplineCurve.nonControl");
						setAttr -lock true ($modCore + $nPdCh + $crntCh + "_SplineCurve.nonControl");

						parent ($modCore + $nPdCh + $crntCh + "_SplineCurve") ($modCore + "_extraCurveNodesGrp");
						
						parent ($modCore + $nPdCh + $crntCh + "_IKHandle") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $nPdCh + $crntCh + "_IKHandle.v") 0;
						
						//CONNECT SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.operation") 2;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo.arcLength") ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.input1X");
						connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.input2X");
						
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input1X");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.operation") 2;
						
						float $splineLengthValue = `getAttr ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo.arcLength")`;
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input2X") $splineLengthValue;
						
						//BLEND SCALE
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.stretch") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.outputX") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleX");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK + ".scaleX");
						
						//INVERSE SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input1X") 1;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input2X");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.operation") 2;
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.autoVolume") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleZ");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK + ".scaleZ");
	
						//ADVANCED TWIST
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr");
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr");
						parentConstraint ($modCore + $nPdCh + $crntCh + "_01SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr");
						parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr");
	
						parent ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr") ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr") ($modCore + "Grp");
						setAttr ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr.v") 0;
						setAttr ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr.v") 0;
						
						setAttr ($modCore + $nPdCh + $crntCh + "_IKHandle.dTwistControlEnable") 1;
						setAttr ($modCore + $nPdCh + $crntCh + "_IKHandle.dWorldUpType")  4;
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr.xformMatrix") ($modCore + $nPdCh + $crntCh + "_IKHandle.dWorldUpMatrix");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr.xformMatrix")   ($modCore + $nPdCh + $crntCh + "_IKHandle.dWorldUpMatrixEnd");
	
						
						////////////CREATE CLUSTERS////////////
						//START CLUSTER
						select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[0:1]");
						newCluster " -envelope 1";
						rename ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr");
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_01SplineCtrl") ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr") ($modCore + "_curveNodesGrp");
						
						//MIDDLE CLUSTERS
						int $midClstrInt = 2;
						int $prevMidClstrInt = 1;
						string $prevMidControlnPd;
						while ($midClstrInt < $crntJnt)
						{
							$midControlnPd = "0";
							if ($midClstrInt > 9)
							{
								$midControlnPd = "";
							}
							$prevMidControlnPd = "0";
							if ($midClstrInt > 9)
							{
								$prevMidControlnPd = "";
							}
	
							select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[" + $midClstrInt + "]");
							newCluster " -envelope 1";
							rename ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr");
							parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr");
							setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr.v") 0;
							parent ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr") ($modCore + "_curveNodesGrp");
							
							//CONNECT STRETCH TO MIDDLE JOINTS
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIK + ".scaleX");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIK + ".scaleY");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIK + ".scaleZ");
							$midClstrInt++;
							$prevMidClstrInt++;
						}
						//END CLUSTER
						select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[" + $crntJnt + ":" + ($crntJnt + 1) + "]");
						newCluster " -envelope 1";
						rename ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr");
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr") ($modCore + "_curveNodesGrp");
					}
					else if (($crntJnt == $fKJointSize) && ($fKJointSize == 2))
					{
						$JntIK = "JntIK";
						if ($crntSide == "right")
						{
							$JntIK = "JntIKGuide";
						}
						//USE AIM CONSTRAINTS IF ONLY TWO JOINTS PER CHAIN
						aimConstraint -mo -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + $nPdCh + $crntCh + "_01" + "SplineCtrl")
						($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK);
						parentConstraint ($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK);
						
						//STRETCH
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr");
						parent ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr") ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						setAttr ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp");
						pointConstraint ($modCore + $nPdCh + $crntCh + "_01" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none"
						($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						pointConstraint ($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr");
						$targetLctrPos = `getAttr ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr.tx")`;
						
						//SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.operation") 2;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr.tx") ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input1X");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input2X") $targetLctrPos;
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.stretch") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.outputX") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleX");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK + ".scaleX");
						
						//INVERSE SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.operation") 2;
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input1X") 1;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input2X");
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.autoVolume") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color1R");
						                                                                                                                                         
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleZ");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK + ".scaleZ");
					}
				}
				else
				{
					parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "JntGrp");
				}
				$crntJnt++;
			}
			$crntCh++;
		}
		//ATTACH LOCATORS TO FIRST JOINT OF START AND END JOINT
		if ($fKChainSize > 2)
		{
			string $nPdCh = "_";
			if ($fKChainSize < 10)
			{
				$nPdCh = "_0";
			}
			$doubleLoop = 0;
			$type = "";
			$jointType = "FK";
			while ($doubleLoop < 2)
			{
				pointConstraint -mo  ($modCore + "_01_01Jnt" + $jointType) ($modCore + "_SpreadTranslate_" + $type + "StartLctr");
				pointConstraint -mo  ($modCore + $nPdCh + $fKChainSize + "_01Jnt" + $jointType) ($modCore + "_SpreadTranslate_" + $type + "EndLctr");
				parentConstraint -mo ($modCore + "_01_01Jnt" + $jointType) ($modCore + "_SpreadRotate_" + $type + "StartLctr");
				parentConstraint -mo ($modCore + $nPdCh + $fKChainSize + "_01Jnt" + $jointType)($modCore + "_SpreadRotate_" + $type + "EndLctr");
				$jointType = "IK";
				$type = "Spline";
				$doubleLoop++;
			}
		}
		
		
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable true ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock true ($crntModControl + ".modCoreName");
			
			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable true ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "fkChain";
			setAttr -l true ($crntModControl + ".moduleType");
			
			//ADD DIRECTION
			$direction = `getAttr ($topNode + ".direction")`;
			addAttr -ln "direction"  -at long ($crntModControl);
			setAttr -e-keyable true ($crntModControl + ".direction");
			setAttr ($crntModControl + ".direction") $direction;
			setAttr -l true ($crntModControl + ".direction");
		}
		
		//LOCK MAIN CONTROL ATTRIBUTES
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.tx");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.ty");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.tz");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.rx");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.ry");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.rz");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.sx");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.sy");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.sz");
		setAttr -lock true -keyable false -channelBox false ($modCore + "_MasterCtrl.v");

		select -cl;
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE HEAD MODULE////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigHead(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     

	//INTEGER FOR LOOP
	$mirrorInt = 2;
	$multiplier = 1;
	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 1;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 2)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "head";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFICtrl ATTRIBUTES
		//JAW
		if (`objExists ("RRM_" + $prfx + $core + "_Jaw")`)
		{
			addAttr -ln "jaw"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.jaw");
			setAttr -l true ($modCore + "Grp.jaw");
		}
	
	
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		delete `aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
		("RRM_" + $prfx + $core + "_Top") ($modCore + "_ScaleGrp")`;
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
		
		//MASTER SCALE GROUP
		group -em -n ($modCore + "_MasterCtrlScaleGrp");
	
		//HEAD CONTROL
		curve -n ($modCore + "_MasterCtrl") -d 1 -p -1 0 -1 -p 1 0 -1 -p 1 0 1 -p -1 0 1 -p -1 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		pickWalk -d down;
		rename ($modCore + "_MasterCtrlShape");
		
		//GET SIZE
		spaceLocator -n ($modCore + "_HeadStartLctr");
		spaceLocator -n ($modCore + "_HeadEndLctr");
		parent ($modCore + "_HeadEndLctr") ($modCore + "_HeadStartLctr");
		pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_HeadStartLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $core + "_Top") ($modCore + "_HeadStartLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_HeadEndLctr");
		$scale = `getAttr ($modCore + "_HeadEndLctr.tx")`;
		scale -r ($scale /5) ($scale /5) ($scale /5) ($modCore + "_MasterCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MasterCtrl");
	
		group -n ($modCore + "_MasterCtrlGrp") ($modCore + "_MasterCtrl");
		parent ($modCore + "_MasterCtrlGrp") ($modCore + "_ScaleGrp");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_MasterCtrlGrp")`;
		//makeIdentity -apply false -t 1 -r 1 ($modCore + "_MasterCtrlGrp");
		move -r -os -wd 0 ($scale * 1.3) 0 ($modCore + "_MasterCtrl.cv[0:24]");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MasterCtrl");
		parentConstraint -mo ($modCore) ($modCore + "_MasterCtrlGrp");
		 
		//PARENT ORIENT
		$parentOrient = ($modCore + "_MasterCtrl");
		RRM_ParentOrient($modCore, $modName, $modAttachNode, $parentOrient);
		
	
		if (`objExists ("RRM_" + $prfx + $core + "_Jaw")`)
		{
		//JAW CONTROL
			circle -n ($modCore + "_JawCtrl");
			scale -r 1 0.5 1 ($modCore + "_JawCtrl");
			move -r -os -wd 0 0 1.2 ($modCore + "_JawCtrl.cv[1]") ($modCore + "_JawCtrl.cv[5]");
			move -r -os -wd 0 0 0.58 ($modCore + "_JawCtrl.cv[0]") ($modCore + "_JawCtrl.cv[2]") ($modCore + "_JawCtrl.cv[4]") ($modCore + "_JawCtrl.cv[6]");
			select ($modCore + "_JawCtrl") ;
			rotate -r -os 35 0 0 ($modCore + "_JawCtrl");
			scale -r ($scale /3) ($scale /3) ($scale /3);
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_JawCtrl");
			delete -ch ($modCore + "_JawCtrl");
			group -n ($modCore + "_JawCtrlGrp");
			parent ($modCore + "_JawCtrlGrp") ($modCore + "_MasterCtrlScaleGrp");
			
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Jaw") ($modCore + "_JawCtrlGrp")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_JawEnd") ($modCore + "_JawCtrl")`;
			$jawCOffset = `getAttr ($modCore + "_JawCtrl.translate")`;
			move -r ($jawCOffset[0] * 1.2) ($jawCOffset[1] * 1.2) ($jawCOffset[2] * 1.2) ($modCore + "_JawCtrl.translate");
			makeIdentity -apply true ($modCore + "_JawCtrl");
			$jawPivot = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Jaw")`;
			move -a $jawPivot[0] $jawPivot[1] $jawPivot[2] ($modCore + "_JawCtrl.scalePivot") ($modCore + "_JawCtrl.rotatePivot") ;
			
		
			//JOINTS
			select -cl;
			joint -n ($modCore + "_JawJnt");
			joint -n ($modCore + "_JawEndJnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Jaw") ($modCore + "_JawJnt")`;
			parentConstraint -mo ($modCore + "_JawCtrl") ($modCore + "_JawJnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_JawEnd") ($modCore + "_JawEndJnt")`;
			//parentConstraint -mo ($modCore + "_MasterCtrl") ($modCore + "_JawCtrlGrp");
			
			parent ($modCore + "_JawJnt") ($modCore + "_MasterCtrlScaleGrp");
		}
		
		parent ($modCore + "_MasterCtrlScaleGrp") ($modCore + "_ScaleGrp");
			
		
		select -cl;
		joint -n ($modCore + "_TopJnt");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_TopJnt")`;
		//parentConstraint -mo ($modCore + "_MasterCtrl") ($modCore + "_TopJnt");
		
		parent ($modCore + "_TopJnt") ($modCore + "_MasterCtrlScaleGrp");
		
		//SET JAW AND END NODES TO SCALE WITH MASTER CTRL
		scaleConstraint ($modCore + "_MasterCtrl") ($modCore + "_MasterCtrlScaleGrp");
		parentConstraint -mo ($modCore + "_MasterCtrl") ($modCore + "_MasterCtrlScaleGrp");
		
		delete ($modCore + "_HeadStartLctr") ($modCore + "_HeadEndLctr");
	
		//ADD CORE NAME
		select ($modCore + "_MasterCtrl");
		if (`objExists ($modCore + "_JawCtrl")`)
		{
			select -add ($modCore + "_JawCtrl");
		}
		$modControls = `ls -sl`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable true ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock true ($crntModControl + ".modCoreName");

			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable true ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "head";
			setAttr -l true ($crntModControl + ".moduleType");
		}
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE LOOK AT MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EyeControl()
{
	circle -n "RRM_EyeControl" -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0 -s 8 -ch 1; objectMoveCommand;
	curve -n "RRM_EyeControl1" -d 1 -p 0 0 -1 -p 0 0 1 -k 0 -k 1 ;
	pickWalk -d down;
	rename "RRM_EyeControl1Shape";
	curve -n "RRM_EyeControl2" -d 1 -p -1 0 0 -p 1 0 0 -k 0 -k 1 ;
	pickWalk -d down;
	rename "RRM_EyeControl2Shape";
		
	parent -r -s "RRM_EyeControl1Shape" "RRM_EyeControl2Shape" "RRM_EyeControl";
	delete "RRM_EyeControl1" "RRM_EyeControl2";
	delete -ch "RRM_EyeControl";
}

global proc RRM_GenerateRigLookAt(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	$mirrorInt = 1;
	float $rotOffset = 0;
	float $lookAtSize;
	string $modAttachNode;
	string $modCore;
	
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 0;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 1)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "lookAt";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		$lookAtNum = `size $lookAts`;
	
		addAttr -ln "lookAts"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.lookAts") ;
		setAttr -type "string" ($modCore + "Grp.lookAts") $lookAtNum;
		setAttr -l true ($modCore + "Grp.lookAts");
	
		//SCALE GROUP
		spaceLocator -n ($modCore + "_AveragePosition_Lctr");
		parentConstraint $lookAts ($modCore + "_AveragePosition_Lctr");

		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		delete ($modCore + "_AveragePosition_Lctr");
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
	
	
		//MASTER CONTROLLER
		circle -n ($modCore + "_MasterCtrl") -c 0 0 0 -nr 1 0 0 -sw 360 -r 1 -d 1 -ut 0 -tol 0 -s 4 -ch 1;
		rotate -r 45 90 0 ($modCore + "_MasterCtrl");
		makeIdentity -apply true -r 1 ($modCore + "_MasterCtrl");
		delete -ch ($modCore + "_MasterCtrl");
		group -n ($modCore + "_MasterCtrlGrp") ($modCore + "_MasterCtrl");
		parent ($modCore + "_MasterCtrlGrp") ($modCore + "_ScaleGrp");
	
		//SCALE MASTER CONTROLLER
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		$lookAtNum = `size $lookAts`;	
		
		if ($lookAtNum == 1)
		{
			$lookAtSize = `getAttr "RRM_MAIN.scaleY"`;
			scale -a ($lookAtSize * 1) ($lookAtSize * 1) $lookAtSize ($modCore + "_MasterCtrlGrp");
			delete `parentConstraint $lookAts ($modCore + "_MasterCtrlGrp")`;
		}
		else
		{
			spaceLocator -n ($modCore + "_MasterCtrl_StartAttachLctr");
			spaceLocator -n ($modCore + "_MasterCtrl_EndAttachLctr");
			parent ($modCore + "_MasterCtrl_EndAttachLctr") ($modCore + "_MasterCtrl_StartAttachLctr");
			pointConstraint $lookAts[0] ($modCore + "_MasterCtrl_StartAttachLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "Grp")
			$lookAts ($modCore + "_MasterCtrl_StartAttachLctr");
			pointConstraint $lookAts ($modCore + "_MasterCtrl_EndAttachLctr");
			$lookAtSize = `getAttr ($modCore + "_MasterCtrl_EndAttachLctr.tx")`;
			scale -a ($lookAtSize * 2.5) ($lookAtSize * 1.25) $lookAtSize ($modCore + "_MasterCtrlGrp");
			
			//POSITION
			delete `parentConstraint $lookAts ($modCore + "_MasterCtrlGrp")`;
			delete ($modCore + "_MasterCtrl_StartAttachLctr") ($modCore + "_MasterCtrl_EndAttachLctr");
		}
	
		parentConstraint -mo ($modCore) ($modCore + "_MasterCtrlGrp");
		
		//PARENT ORIENT
		$parentOrient = ($modCore + "_MasterCtrl");
		RRM_ParentOrient($modCore, $modName, $modAttachNode, $parentOrient); 
		
		
		//EYE CONTROLS
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		$lookAtNum = `size $lookAts`;
		string $crntLookAt;
		$crntNum = 1;
		for ($crntLookAt in $lookAts)
		{
			string $nPd = "";
			if ($crntNum < 10)
			{
				$nPd = "0";
			}
			RRM_EyeControl;
			rename "RRM_EyeControl" ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			rotate -r 90 90 0 ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			group -n ($modCore + "_" + $nPd + $crntNum + "Grp1") ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			group -n ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "Grp1");
			parent ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_ScaleGrp");
			delete `pointConstraint $crntLookAt ($modCore + "_" + $nPd + $crntNum + "Grp2")`;
			
			//GET END LOCATION OF EYE CONTROL
			$lookAtUpLoc = `xform -q -ws -t ($crntLookAt + "EShape.cv[0]")`;
			$lookAtAimLoc = `xform -q -ws -t ($crntLookAt + "DShape.cv[1]")`;
			spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "AimLctr");
			spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			move -a $lookAtAimLoc[0] $lookAtAimLoc[1] $lookAtAimLoc[2] ($modCore + "_" + $nPd + $crntNum + "AimLctr");
			move -a $lookAtUpLoc[0] $lookAtUpLoc[1] $lookAtUpLoc[2] ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "UpLctr")
			($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "Grp2")`;
			
			delete `pointConstraint ($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "Grp1")`;
			
			select -cl;
			joint -n ($modCore + "_" + $nPd + $crntNum + "Jnt");
			parent ($modCore + "_" + $nPd + $crntNum + "Jnt") ($modCore + "_ScaleGrp");		
			pointConstraint ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "Jnt");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "Grp2")
			($modCore + "_" + $nPd + $crntNum + "Ctrl") ($modCore + "_" + $nPd + $crntNum + "Jnt");
	
			//AIM EYE CONTROL AT JOINT
			aimConstraint -offset 0 0 0 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "Grp2")
			($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			
			//SCALE EACH CONTROLLER
			if ($lookAtNum == 1)
			{
				$lookAtSize = `getAttr "RRM_MAIN.scaleY"`;
				scale -a ($lookAtSize * .75) ($lookAtSize * .75) ($lookAtSize * .75) ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			}
			else
			{
				spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "EndLctr");
				parent ($modCore + "_" + $nPd + $crntNum + "EndLctr") ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				pointConstraint $lookAts[0] ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "UpLctr")
				$lookAts ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				pointConstraint $lookAts ($modCore + "_" + $nPd + $crntNum + "EndLctr");
				$lookAtSize = `getAttr ($modCore + "_" + $nPd + $crntNum + "EndLctr.tx")`;
				scale -a ($lookAtSize * .75) ($lookAtSize * .75) ($lookAtSize * .75) ($modCore + "_" + $nPd + $crntNum + "Ctrl");
				delete ($modCore + "_" + $nPd + $crntNum + "StartLctr") ($modCore + "_" + $nPd + $crntNum + "EndLctr");
			}
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			
			
			//CREATE CONNECTOR
			curve -n ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl") -d 1 -p 0 0 0 -p 0 0 -1 -k 0 -k 1 ;
			pickWalk -d down;
			rename ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrlShape");
			parent ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl") ($modCore + "Grp");
		
			select ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrlShape.cv[0]");
			newCluster " -envelope 1";
			rename ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1");
			pointConstraint ($modCore + "_" + $nPd + $crntNum + "Ctrl") ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1");
			
			select ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrlShape.cv[1]");
			newCluster " -envelope 1";
			rename ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2");
			pointConstraint ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2");
	
			parent ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1")	($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2") ($modCore + "Grp");
			setAttr ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1.visibility") 0;
			setAttr ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2.visibility") 0;
			
			toggle -state on -template ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl");
			
			delete ($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			
			addAttr -ln "nonControl"  -dt "string" ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl");
			setAttr -e-keyable true ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl.nonControl");
			setAttr -lock true ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl.nonControl");

			$crntNum++;
		}
	
		//ADD CORE NAME AND LOCK CHANNELS
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable true ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock true ($crntModControl + ".modCoreName");
			
			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable true ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "lookAt";
			setAttr -l true ($crntModControl + ".moduleType");

			setAttr -lock true -keyable false -channelBox false ($crntModControl + ".rx");
			setAttr -lock true -keyable false -channelBox false ($crntModControl + ".ry");
			setAttr -lock true -keyable false -channelBox false ($crntModControl + ".rz");
		}
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	//ADD MASTER CONTROL FOR ALL EYES
	
	//CONTROL
	circle -n ($modName + "_" + $core + "_LookAtCtrl1") -c 0 0 0 -nr 0 1 0 -sw 75 -r 1 -d 3 -ut 0 -tol 0 -s 3 -ch 0; objectMoveCommand;
	rotate -r -os 0 7.5 0 ($modName + "_" + $core + "_LookAtCtrl1");
	makeIdentity -apply  true -r 1 ($modName + "_" + $core + "_LookAtCtrl1");
	
	curve -n ($modName + "_" + $core + "_LookAtCtrl") -d 1 -p -0.130526 0 -0.991445 -p -0.130526 0 -0.130526 -p -0.991445 0 -0.130526 -k 0 -k 1 -k 2 ;
	pickWalk -d down;
	rename ($modName + "_" + $core + "_LookAtCtrlShape");
	parent -r -s ($modName + "_" + $core + "_LookAtCtrl1Shape") ($modName + "_" + $core + "_LookAtCtrl");
	delete ($modName + "_" + $core + "_LookAtCtrl1");
	select ($modName + "_" + $core + "_LookAtCtrl");
	duplicate -rr; rotate -r 0 90 0; for ($i=1; $i<3; ++$i) duplicate -rr -st; select ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	makeIdentity -apply true -r 1 ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	select -hi ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	select -d ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	select -add ($modName + "_" + $core + "_LookAtCtrl");
	parent -r -s;
	delete ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	group -n ($modName + "_" + $core + "_LookAtCtrlGrp") ($modName + "_" + $core + "_LookAtCtrl");
	parent ($modName + "_" + $core + "_LookAtCtrlGrp") ($modName + "_MAINCtrl");
	rotate -r 90 0 0 ($modName + "_" + $core + "_LookAtCtrlGrp") ;
	scale -r ($lookAtSize/.75) ($lookAtSize/.75) ($lookAtSize/.75) ($modName + "_" + $core + "_LookAtCtrlGrp");
	makeIdentity -apply true -r 1 -s 1 ($modName + "_" + $core + "_LookAtCtrlGrp") ;
	
	//MOVE INTO POSITION
	select ($modName + "*" + $core + "_??Ctrl");
	select -d ($modName + "_" + $core + "_LookAtCtrl");
	$eyeControls = `ls -sl`;
	$eyeControlsGrp = `listRelatives -p $eyeControls`;
	
	delete `pointConstraint $eyeControls ($modName + "_" + $core + "_LookAtCtrlGrp")`;
	makeIdentity -apply true -t 1 ($modName + "_" + $core + "_LookAtCtrlGrp");
	
	//AIM CONSTRAINT
	$eyeControlsGrp2 = `ls ($modName + "*" + $core + "_??Grp2")`;
	
	aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
	$eyeControlsGrp2 ($modName + "_" + $core + "_LookAtCtrl");
	
	setAttr -lock true -keyable false -channelBox false ($modName + "_" + $core + "_LookAtCtrl.rx");
	setAttr -lock true -keyable false -channelBox false ($modName + "_" + $core + "_LookAtCtrl.ry");
	setAttr -lock true -keyable false -channelBox false ($modName + "_" + $core + "_LookAtCtrl.rz");	
	setAttr -lock true -keyable false -channelBox false ($modName + "_" + $core + "_LookAtCtrl.v");	
	
	string $each;
	for ($each in $eyeControlsGrp)
	{
		parentConstraint -mo ($modName + "_" + $core + "_LookAtCtrl") $each;
	}
	
	//ADD ATTRIBUTE FOR PARENT ORIENT
	addAttr -ln "localSpace"  -at double  -min 0 -max 1 -dv 1 ($modName + "_" + $core + "_LookAtCtrl");
	setAttr -e-keyable true ($modName + "_" + $core + "_LookAtCtrl.localSpace");
	
	parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_MAINCtrl") ($modName + "_" + $core + "_LookAtCtrlGrp");
	connectAttr -f ($modName + "_" + $core + "_LookAtCtrl.localSpace") ($modName + "_" + $core + "_LookAtCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
	
	shadingNode -asUtility reverse -n ($modName + "_" + $core + "_LookAtCtrlGrp_Rev");
	connectAttr -f ($modName + "_" + $core + "_LookAtCtrl.localSpace") ($modName + "_" + $core + "_LookAtCtrlGrp_Rev.inputX");
	connectAttr -f ($modName + "_" + $core + "_LookAtCtrlGrp_Rev.outputX") ($modName + "_" + $core + "_LookAtCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1");

	
	addAttr -ln "modCoreName"  -dt "string" ($modName + "_" + $core + "_LookAtCtrl");
	setAttr -e-keyable true ($modName + "_" + $core + "_LookAtCtrl.modCoreName");
	setAttr -type "string" ($modName + "_" + $core + "_LookAtCtrl.modCoreName") $modCore;
	setAttr -e-lock true ($modName + "_" + $core + "_LookAtCtrl.modCoreName");
	
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE AUXILIARY MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRigAuxiliary(string $modName, string $moduleName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;
	$mirrorInt = 1;
	string $modAttachNode;
	string $modCore;
	
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 0;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 1)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Aux.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core + "_Aux");
		$modOppCore = ($modName + "_" + $oppPrfx + $core + "_Aux");
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
		
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "auxiliary";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable true ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable true ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}

		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");

		//CONTROL
		//GET SCALE OF THE PROXY
		
		//LOCATOR FOR CONSTRAINTS
		spaceLocator -n ($modCore + "CtrlGrp2Lctr");
		parent ($modCore + "CtrlGrp2Lctr") ($modCore + "Grp");
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr")`;
		delete `scaleConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr")`;
		$auxScale = `getAttr ("RRM_" + $prfx + $core + ".scale")`;
		$auxRadius = (($auxScale[0] + $auxScale[1] + $auxScale[2])/3)*.375 + 0.25;

		circle -n ($modCore + "Ctrl")  -nr 0 1 0 -sw 360 -r $auxRadius -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
		circle -n ($modCore + "Ctrl2") -nr 1 0 0 -sw 360 -r $auxRadius -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
		circle -n ($modCore + "Ctrl3") -nr 0 0 1 -sw 360 -r $auxRadius -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
		parent -r -s ($modCore + "Ctrl2Shape") ($modCore + "Ctrl3Shape") ($modCore + "Ctrl");
		delete ($modCore + "Ctrl2") ($modCore + "Ctrl3");
		group -n ($modCore + "CtrlGrp") ($modCore + "Ctrl");
		group -n ($modCore + "CtrlGrp2") ($modCore + "CtrlGrp");
		parent ($modCore + "CtrlGrp2") ($modCore);
		
		setAttr ($modCore + "CtrlGrp2Lctr.v") 0;
		setAttr -lock true -keyable false -channelBox false ($modCore + "CtrlGrp2Lctr.v");
		setAttr -lock true -keyable false -channelBox false ($modCore + "Ctrl.v");

		
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2")`;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Aux") ($modCore + "CtrlGrp")`;
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr") ($modCore + "CtrlGrp2");
		orientConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr") ($modCore + "CtrlGrp");
		
		addAttr -ln "followParentOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "Ctrl");
		setAttr -e-keyable true ($modCore + "Ctrl.followParentOrient");
		addAttr -ln "followParentPosition"  -at double  -min 0 -max 1 -dv 1 ($modCore + "Ctrl");
		setAttr -e-keyable true ($modCore + "Ctrl.followParentPosition");
		connectAttr -f ($modCore + "Ctrl.followParentOrient") ($modCore + "CtrlGrp_orientConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setAttr ($modCore + "Ctrl.followParentOrient") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentOrient") ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1");
		setAttr ($modCore + "Ctrl.followParentOrient") 0;
		setAttr ($modCore + "Ctrl.followParentOrient") 1;
		setAttr ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentOrient") ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1");

		connectAttr -f ($modCore + "Ctrl.followParentPosition") ($modCore + "CtrlGrp2_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setAttr ($modCore + "Ctrl.followParentPosition") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentPosition") ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1");
		setAttr ($modCore + "Ctrl.followParentPosition") 0;
		setAttr ($modCore + "Ctrl.followParentPosition") 1;
		setAttr ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentPosition") ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1");

		selectKey -k ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1") ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1");
		keyTangent -itt spline -ott spline ;
		

		//ADD MODULE CORE NAME
		addAttr -ln "modCoreName"  -dt "string" ($modCore + "Ctrl");
		setAttr -e-keyable true ($modCore + "Ctrl.modCoreName");
		setAttr -type "string" ($modCore + "Ctrl.modCoreName") ("_" + $prfx + $core);
		setAttr -e-lock true ($modCore + "Ctrl.modCoreName");
		
		//ADD MODULE TYPE
		addAttr -ln "moduleType"  -dt "string" (($modCore + "Ctrl"));
		setAttr -e -keyable true ($modCore + "Ctrl.moduleType");
		setAttr -type "string" ($modCore + "Ctrl.moduleType") "auxiliary";
		setAttr -l true ($modCore + "Ctrl.moduleType");
				
		//JOINT
		joint -n ($modCore + "Jnt");
		parent ($modCore + "Jnt") ($modCore + "_ScaleGrp");
		parentConstraint ($modCore + "Ctrl") ($modCore + "Jnt");
		//scaleConstraint ($modCore + "Ctrl")  ($modCore + "Jnt");
		connectAttr ($modCore + "Ctrl.scale")  ($modCore + "Jnt.scale");
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	if (`objExists ("RRM_l_" + $modName + "_Aux")`)
		{select ("RRM_l_" + $modName + "_Aux");}
	if (`objExists ("RRM_r_" + $modName + "_Aux")`)
		{select -add ("RRM_r_" + $modName + "_Aux");}
	else if (`objExists ("RRM_" + $modName + "_Aux")`)
		{select ("RRM_" + $modName + "_Aux");}
}
	

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////TAB 2 FUNCTIONALITY///////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLoadParent(string $parent)
{
	$crnt = `ls -sl`;
	$crntSize = `size $crnt`;
	if ($crntSize == 1)
	{
		$each = $crnt[0];
		if (`objExists ($each + ".modName")`)
		{
			string $modName = `getAttr ($each + ".modName")`;
			string $modType = `getAttr ("RRM_" + $modName + ".top")`;
			if ($modType == $parent)
			{
				textFieldButtonGrp -e -text $modName ("RRM_EditLoad" + $parent + "TextField");
				select $crnt[0];
			}
			else
			{
				warning ("SELECTED PROXY NODE IS NOT A \"" + $parent + "\"");
			}
		}
		else
		{
			warning "PLEASE SELECT A VALID PROXY NODE TO LOAD";
		}
	}
	else if ($crntSize == 0)
	{
		warning "PLEASE SELECT A PROXY NODE TO LOAD";
	}
	else
	{
		warning "PLEASE SELECT ONLY ONE NODE. MIRRORED PARENTS WILL AUTOMATICALLY BE CONNECTED PROPERLY";
	}
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY SPLINE MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditSpline()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	$modName = `textFieldButtonGrp -q -text RRM_EditLoadsplineTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}
		
	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;
	$crntSize = `size $crntSelection`;


	int $splineNum = `intSliderGrp -q -v RRM_SplineEditNum`;
	$mirrorMod = 0;
	$prfx = "";
	$oppPrfx = "";
	$i = 0;
	
	
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 1;
		$prfx = "l_";
		$oppPrfx = "r_";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;
		
		select $connectors ("RRM_?_" + $modName + "_??Grp");
	}
	else
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;
		
		select $connectors ("RRM_" + $modName + "_??Grp");
	}

	//DELETE OLD SPLINE NODES
	$splineJntGrp = `ls -sl`;
	select -hi $splineJntGrp;
	$allSplineJntGrp = `ls -sl`;
	lockNode -lock off $allSplineJntGrp;
	delete $splineJntGrp;
	
	//REBUILD SPLINE NODES
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxySpline2($modName, $mirrorMod, $prfx, $oppPrfx, $splineNum, $crntUnit);
		
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;

	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if ($crntSize > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY ARM MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditArm()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadarmTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;
	$crntSize = `size $crntSelection`;

	int $upperArmNum = `intSliderGrp -q -v upperArmModEditNum`;
	int $lowerArmNum = `intSliderGrp -q -v forearmModEditNum`;
	int $elbowNum = `intSliderGrp -q -v RRM_ElbowEditNum`;
	int $elbowJoints = `radioButtonGrp -q -select RRM_ElbowEditJoints`;
	int $mirrorMod = 1;
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	//CHANGE ATTRIBUTES
	lockNode -lock 0 ("RRM_" + $modName);
	setAttr -l 0 ("RRM_" + $modName + ".upperArmNum");
	setAttr ("RRM_" + $modName + ".upperArmNum") $upperArmNum;
	setAttr -l 1 ("RRM_" + $modName + ".upperArmNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".lowerArmNum");
	setAttr ("RRM_" + $modName + ".lowerArmNum") $lowerArmNum;
	setAttr -l 1 ("RRM_" + $modName + ".lowerArmNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".elbowNum");
	setAttr ("RRM_" + $modName + ".elbowNum") $elbowNum;
	setAttr -l 1 ("RRM_" + $modName + ".elbowNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".elbowJoints");
	setAttr ("RRM_" + $modName + ".elbowJoints") $elbowJoints;
	setAttr -l 1 ("RRM_" + $modName + ".elbowJoints");
	lockNode -lock 1 ("RRM_" + $modName);

	$i = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	$attachModNum = `size $attachMod`;

	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_l_" + $modName + "_ElbowGrp")`)
		{
			select ("RRM_l_" + $modName + "_ElbowGrp") ("RRM_r_" + $modName + "_ElbowGrp")
			("RRM_l_" + $modName + "_AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_l_" + $modName + "_Elbow1Grp") ("RRM_l_" + $modName + "_Elbow2Grp")
			("RRM_l_" + $modName + "_Elbow2AimLctr") ("RRM_l_" + $modName + "_AimLctr")
			("RRM_r_" + $modName + "_Elbow1Grp") ("RRM_r_" + $modName + "_Elbow2Grp")
			("RRM_r_" + $modName + "_Elbow2AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_l_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_l_" + $modName + "_Upper*") ("RRM_r_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_l_" + $modName + "_Middle*") ("RRM_r_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_l_" + $modName + "_Lower*") ("RRM_r_" + $modName + "_Lower*");
		}
		select -add $connectors;		
		$mirrorMod = 2;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $modName + "_ElbowGrp")`)
		{
			select ("RRM_" + $modName + "_ElbowGrp") ("RRM_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $modName + "_Elbow1Grp") ("RRM_" + $modName + "_Elbow2Grp")
			("RRM_" + $modName + "_Elbow2AimLctr") ("RRM_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $modName + "_Lower*");
		}
		select -add $connectors;
	}

	//DELETE OLD ARM NODES
	$elbowNodes = `ls -sl`;
	select -hi $elbowNodes;
	$allElbowNodes = `ls -sl`;
	lockNode -lock off $allElbowNodes;
	delete $allElbowNodes;
	
	//REBUILD ARM NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyArm2($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);
		
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if ($crntSize > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY LEG MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLeg()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadlegTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;
	$crntSize = `size $crntSelection`;



	int $upperLegNum = `intSliderGrp -q -v upperLegModEditNum`;
	int $lowerLegNum = `intSliderGrp -q -v lowerLegModEditNum`;
	int $kneeNum = `intSliderGrp -q -v RRM_KneeEditNum`;
	int $kneeJoints = `radioButtonGrp -q -select RRM_KneeEditJoints`;
	int $mirrorMod = 1;
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$posOffset = 2;
	
	$i = 1;
	
	//CHANGE ATTRIBUTES
	lockNode -lock 0 ("RRM_" + $modName);
	setAttr -l 0 ("RRM_" + $modName + ".upperLegNum");
	setAttr ("RRM_" + $modName + ".upperLegNum") $upperLegNum;
	setAttr -l 1 ("RRM_" + $modName + ".upperLegNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".lowerLegNum");
	setAttr ("RRM_" + $modName + ".lowerLegNum") $lowerLegNum;
	setAttr -l 1 ("RRM_" + $modName + ".lowerLegNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".kneeNum");
	setAttr ("RRM_" + $modName + ".kneeNum") $kneeNum;
	setAttr -l 1 ("RRM_" + $modName + ".kneeNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".kneeJoints");
	setAttr ("RRM_" + $modName + ".kneeJoints") $kneeJoints;
	setAttr -l 1 ("RRM_" + $modName + ".kneeJoints");
	lockNode -lock 1 ("RRM_" + $modName);
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_l_" + $modName + "_KneeGrp")`)
		{
			select ("RRM_l_" + $modName + "_KneeGrp") ("RRM_r_" + $modName + "_KneeGrp")
			("RRM_l_" + $modName + "_AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_l_" + $modName + "_Knee1Grp") ("RRM_l_" + $modName + "_Knee2Grp")
			("RRM_l_" + $modName + "_Knee2AimLctr") ("RRM_l_" + $modName + "_AimLctr")
			("RRM_r_" + $modName + "_Knee1Grp") ("RRM_r_" + $modName + "_Knee2Grp")
			("RRM_r_" + $modName + "_Knee2AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_l_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_l_" + $modName + "_Upper*") ("RRM_r_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_l_" + $modName + "_Middle*") ("RRM_r_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_l_" + $modName + "_Lower*") ("RRM_r_" + $modName + "_Lower*");
		}
		select -add $connectors;
		$mirrorMod = 2;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $modName + "_KneeGrp")`)
		{
			select ("RRM_" + $modName + "_KneeGrp") ("RRM_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $modName + "_Knee1Grp") ("RRM_" + $modName + "_Knee2Grp")
			("RRM_" + $modName + "_Knee2AimLctr") ("RRM_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $modName + "_Lower*");
		}
		select -add $connectors;
	}
	//DELETE OLD LEG NODES
	$kneeNodes = `ls -sl`;
	select -hi $kneeNodes;
	$allKneeNodes = `ls -sl`;
	lockNode -lock off $allKneeNodes;
	delete $kneeNodes;
		
	//REBUILD LEG NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyLeg2($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $posOffset, $crntUnit);
		
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$posOffset = -2;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if ($crntSize > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				select $finalSelect $each;
				$finalSelect = `ls -sl`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY FK CHAIN MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditFkChain()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadfkChainTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;
	$crntSize = `size $crntSelection`;



	int $chainsNum = `intSliderGrp -q -v fkChainModEditChains`;
	int $jointsNum = `intSliderGrp -q -v fkChainModEditJointsPerChain`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $mirrorMod = 0;

	
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$rotOffset = 0;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	$i=0;
	int $create = 0;

	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select ("RRM_l_" + $modName + "_Grp") ("RRM_r_" + $modName + "_Grp")$connectors;
		$mirrorMod = 1;
	}
	else
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		$prfx = "";
		$oppPrfx = "";
		select ("RRM_" + $modName + "_Grp") $connectors;
	}

	//DELETE OLD FK NODES
	$fkNodes = `ls -sl`;
	select -hi $fkNodes;
	$allFkNodes = `ls -sl`;
	lockNode -lock off $allFkNodes;
	delete $allFkNodes;
	
	//UNLOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock off $lockNodes;

	//REBUILD FK NODES
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyFKChain2($modName, $chainsNum, $jointsNum, $direction, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit, $create);
		
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if ($crntSize > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY HEAD MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditHead()
{
	string $crntUnit = `currentUnit -query -linear`;

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadheadTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;
	$crntSize = `size $crntSelection`;

	int $mirrorMod = 1;
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	int $i;
	
	//CHECK FOR PAIRING
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$prfx = "";
		$oppPrfx = "";
		$mirrorMod = 0;
	}
	while ($i <= $mirrorMod)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Jaw")`)
		{
			//SET JAW ON IN PARENT NODE
			lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");
		
			setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jaw");
			setAttr ("RRM_" + $prfx + $modName + "_Parent.jaw") 0;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
			lockNode -lock on ("RRM_" + $prfx + $modName + "_Parent");
		
			lockNode -lock off ("RRM_" + $modName);
			setAttr -l false ("RRM_" + $modName + ".jaw");
			setAttr ("RRM_" + $modName + ".jaw") 0;
			setAttr -l true ("RRM_" + $modName + ".jaw");
			lockNode -lock on ("RRM_" + $modName);
		

			select -hi ("RRM_*_RRM_" + $prfx + $modName + "_JawCtrl")  ("RRM_*_RRM_" + $prfx + $modName + "_Jaw_AimLctr")
			("RRM_*_RRM_" + $prfx + $modName + "_JawEndCtrl")  ("RRM_*_RRM_" + $prfx + $modName + "_JawEnd_AimLctr");
			$connectors = `ls -sl`;
			
			select -hi ("RRM_" + $prfx + $modName + "_Jaw");
			select -add $connectors;
			$jawHierarchy = `ls -sl`;
			lockNode -lock off $jawHierarchy;
			delete $jawHierarchy;
		}
		else
		{
			//SET JAW ON IN PARENT NODE
			lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");
		
			setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jaw");
			setAttr ("RRM_" + $prfx + $modName + "_Parent.jaw") 1;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
			lockNode -lock on ("RRM_" + $prfx + $modName + "_Parent");

			lockNode -lock off ("RRM_" + $modName);
			setAttr -l false ("RRM_" + $modName + ".jaw");
			setAttr ("RRM_" + $modName + ".jaw") 1;
			setAttr -l true ("RRM_" + $modName + ".jaw");
			lockNode -lock on ("RRM_" + $modName);

			RRM_CreateProxyModuleProxy($crntUnit);
			rename RRM_Base	 ("RRM_" + $prfx + $modName + "_Jaw");
			delete `parentConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Jaw")`;
			parent ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_Parent");
			makeIdentity -apply false -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			delete `pointConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Jaw")`;
			$jawLoc = `getAttr  ("RRM_" + $prfx + $modName + "_Jaw.ty")`;
			move -r -ls 0 0 ($jawLoc/6) ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.core") ($prfx + $modName + "_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.core");
		
			RRM_CreateProxyEndProxy($crntUnit);
			rename RRM_End ("RRM_" + $prfx + $modName + "_JawEnd");
			rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			delete `parentConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_JawEnd")`;
			parent  ("RRM_" + $prfx + $modName + "_JawEnd")  ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply false -s 1  ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			move -r -ls 0 (($jawLoc/3)*2) $jawLoc ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.core") ($prfx + $modName + "_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.core");
        
			lockNode -lock on ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_JawEnd");
			
			//CONNECTORS
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Jaw"));
			RRM_ProxyConnectors($modName, $prfx, ("RRM_" + $prfx + $modName + "_Jaw"), ("RRM_" + $prfx + $modName + "_JawEnd"));
		}
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if ($crntSize > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY LOOK AT MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLookAt()
{
	string $crntUnit = `currentUnit -query -linear`;

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadlookAtTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;
	$crntSize = `size $crntSelection`;



	int $jointsNum = `intSliderGrp -q -v lookAtModEditJoints`;
	int $mirrorMod = 0;

	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select ("RRM_l_" + $modName + "_Grp") ("RRM_r_" + $modName + "_Grp") $connectors;
		$mirrorMod = 1;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select ("RRM_" + $modName + "_Grp") $connectors;
	}

	//DELETE OLD LOOK AT NODES
	$fkNodes = `ls -sl`;
	select -hi $fkNodes;
	$allFkNodes = `ls -sl`;
	lockNode -lock off $allFkNodes;
	delete $allFkNodes;
	
	//UNLOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock off $lockNodes;
	
	//REBUILD LOOK AT NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyLookAt2($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);
		
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if ($crntSize > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
				$modNameCheck = `getAttr ($each + ".modName")`;
				if ($modNameCheck == "")
				{
					lockNode -lock off $each;
					setAttr -l false ($each + ".modName");
					setAttr -type "string" ($each + ".modName") $modName;
					setAttr -l true ($each + ".modName");
				}
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

//////////////////////////////////////SINGLE HIERARCHY////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE ROOT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigRootSH(string $modName)
{
	//CREATE LAYERS
	//LAYER
	createDisplayLayer -n ($modName + "_SHJointsLayer") -number 1 -empty;
	select -cl;	
	joint -n ($modName + "_ROOTSHJnt");
	parentConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTSHJnt");
	group -n ($modName + "_SHJntGrp") ($modName + "_ROOTSHJnt"); xform -os -piv 0 0 0;
	parent ($modName + "_SHJntGrp") $modName;
	$JointOrient = `getAttr  ($modName + "_ROOTJnt.jointOrient")`;
	setAttr (($modName + "_ROOTSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	editDisplayLayerMembers -noRecurse ($modName + "_SHJointsLayer") `ls ($modName + "_SHJntGrp")`;
}


////////////////////////////////////////////////////////////////////////////////
///////////////////////GENERATE ROOT AND MAIN SH MODULE/////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigRootMainSH(string $modName)
{
	//CREATE LAYERS
	//LAYER
	createDisplayLayer -n ($modName + "_SHJointsLayer") -number 1 -empty;

	select -cl;	
	joint -n ($modName + "_MAINSHJnt");
	parentConstraint ($modName + "_MAINCtrl") ($modName + "_MAINSHJnt");
	group -n ($modName + "_SHJntGrp") ($modName + "_MAINSHJnt"); xform -os -piv 0 0 0;
	parent ($modName + "_SHJntGrp") $modName;
	select -cl;	
	joint -n ($modName + "_ROOTSHJnt");
	addAttr -ln "hips"  -at bool ($modName + "_ROOTSHJnt");
	setAttr -e-keyable true ($modName + "_ROOTSHJnt.hips");

	parentConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTSHJnt");
	parent ($modName + "_ROOTSHJnt") ($modName + "_MAINSHJnt");
	$JointOrient = `getAttr  ($modName + "_ROOTJnt.jointOrient")`;
	setAttr (($modName + "_ROOTSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	editDisplayLayerMembers -noRecurse ($modName + "_SHJointsLayer") `ls ($modName + "_SHJntGrp")`;
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////GENERATE SPLINE SH MODULE/////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigSplineSH(string $modName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);

	//GENERATE JOINTS
	$splineProxies = `ls ("RRM_" + $lPrfx + $core + "_??")`;
	int $crntNum = 0;
	$numPadding = "_0";
	$prevPadding = "_0";
	float $splineLoc[];
	for ($crntProxy in $splineProxies)
	{
		$crntNum++;
		if ($crntNum >= 10)
		{$numPadding = "_";}
			
		select -cl;
		joint -n ($mod_lCore + $numPadding + $crntNum + "SHJnt");
		parentConstraint ($mod_lCore + $numPadding + $crntNum + "Jnt") ($mod_lCore + $numPadding + $crntNum + "SHJnt");

		if ($crntNum == 1)
		{
			parent ($mod_lCore + $numPadding + $crntNum + "SHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
			addAttr -ln "splineStart"  -at bool ($mod_lCore + $numPadding + $crntNum + "SHJnt");
			setAttr -e-keyable true ($mod_lCore + $numPadding + $crntNum + "SHJnt.splineStart");
		}
		else
		{
			int $previousNum = ($crntNum - 1);
			parent ($mod_lCore + $numPadding + $crntNum + "SHJnt")  ($mod_lCore + $prevPadding + $previousNum + "SHJnt");
		}
		$JointOrient = `getAttr  ($mod_lCore + $numPadding + $crntNum + "Jnt.jointOrient")`;
		setAttr (($mod_lCore + $numPadding + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
	
	select -cl;
	joint -n ($mod_lCore + "_TopSHJnt");
	addAttr -ln "splineEnd"  -at bool ($mod_lCore + "_TopSHJnt");
	setAttr -e-keyable true ($mod_lCore + "_TopSHJnt.splineEnd");

	parentConstraint ($mod_lCore + "_TopJnt") ($mod_lCore + "_TopSHJnt");
	parent ($mod_lCore + "_TopSHJnt") ($mod_lCore + $numPadding + $crntNum + "SHJnt");
	$JointOrient = `getAttr  ($mod_lCore + "_TopJnt.jointOrient")`;
	setAttr (($mod_lCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	if (`objExists ("RRM_" + $lPrfx + $core + "_Hip")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_HipSHJnt");
		parentConstraint ($mod_lCore + "_HipJnt") ($mod_lCore + "_HipSHJnt");
		parent ($mod_lCore + "_HipSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
		$JointOrient = `getAttr  ($mod_lCore + "_HipJnt.jointOrient")`;
		setAttr (($mod_lCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
	
	//RIGHT SIDE/////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////
	
	
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

	
		//GENERATE JOINTS
		$splineProxies = `ls ("RRM_" + $rPrfx + $core + "_??")`;
		int $crntNum = 0;
		$numPadding = "_0";
		float $splineLoc[];
		for ($crntProxy in $splineProxies)
		{
			$crntNum++;
			if ($crntNum >= 10)
			{$numPadding = "_";}
				
				
			select -cl;
			joint -n ($mod_rCore + $numPadding + $crntNum + "SHJnt");
			parentConstraint ($mod_rCore + $numPadding + $crntNum + "Jnt") ($mod_rCore + $numPadding + $crntNum + "SHJnt");
	
			if ($crntNum == 1)
			{
				parent ($mod_rCore + $numPadding + $crntNum + "SHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
				addAttr -ln "splineStart"  -at bool ($mod_rCore + $numPadding + $crntNum + "SHJnt");
				setAttr -e-keyable true ($mod_rCore + $numPadding + $crntNum + "SHJnt.splineStart");
			}
			else
			{
				int $previousNum = ($crntNum - 1);
				parent ($mod_rCore + $numPadding + $crntNum + "SHJnt")  ($mod_rCore + $prevPadding + $previousNum + "SHJnt");
			}
			$JointOrient = `getAttr  ($mod_rCore + $numPadding + $crntNum + "Jnt.jointOrient")`;
			setAttr (($mod_rCore + $numPadding + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		}
		
		select -cl;
		joint -n ($mod_rCore + "_TopSHJnt");
		addAttr -ln "splineEnd"  -at bool ($mod_rCore + "_TopSHJnt");
		setAttr -e-keyable true ($mod_rCore + "_TopSHJnt.splineEnd");
	
		parentConstraint ($mod_rCore + "_TopJnt") ($mod_rCore + "_TopSHJnt");
		parent ($mod_rCore + "_TopSHJnt") ($mod_rCore + $numPadding + $crntNum + "SHJnt");
		$JointOrient = `getAttr  ($mod_rCore + "_TopJnt.jointOrient")`;
		setAttr (($mod_rCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		if (`objExists ("RRM_" + $lPrfx + $core + "_Hip")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_HipSHJnt");
			parentConstraint ($mod_rCore + "_HipJnt") ($mod_rCore + "_HipSHJnt");
			parent ($mod_rCore + "_HipSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
			$JointOrient = `getAttr  ($mod_rCore + "_HipJnt.jointOrient")`;
			setAttr (($mod_rCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE ARM SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigArmSH(string $modName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	//GENERATE JOINTS
	select -cl;
	joint -n ($mod_lCore + "_ClavicleSHJnt");
	addAttr -ln "shoulder"  -at bool ($mod_lCore + "_ClavicleSHJnt");
	setAttr -e-keyable true ($mod_lCore + "_ClavicleSHJnt.shoulder");

	parentConstraint ($mod_lCore + "_ClavicleJnt") ($mod_lCore + "_ClavicleSHJnt");
	parent  ($mod_lCore + "_ClavicleSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
	$JointOrient = `getAttr  ($mod_lCore + "_ClavicleJnt.jointOrient")`;
	setAttr (($mod_lCore + "_ClavicleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	$parentJnt = ($mod_lCore + "_ClavicleSHJnt");
	
	if (!`objExists ($mod_rCore + "_Shoulder_CurveJnt")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_ShoulderSHJnt");
		addAttr -ln "arm"  -at bool ($mod_lCore + "_ShoulderSHJnt");
		setAttr -e-keyable true ($mod_lCore + "_ShoulderSHJnt.arm");
	
		parentConstraint ($mod_lCore + "_ShoulderJnt") ($mod_lCore + "_ShoulderSHJnt");
		parent ($mod_lCore + "_ShoulderSHJnt") $parentJnt;
		$JointOrient = `getAttr  ($mod_lCore + "_ShoulderJnt.jointOrient")`;
		setAttr (($mod_lCore + "_ShoulderSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_ShoulderSHJnt");
	}
	else
	{
		select -cl;
		joint -n ($mod_lCore + "_Shoulder_CurveSHJnt");
		addAttr -ln "arm"  -at bool ($mod_lCore + "_Shoulder_CurveSHJnt");
		setAttr -e-keyable true ($mod_lCore + "_Shoulder_CurveSHJnt.arm");

		parentConstraint ($mod_lCore + "_Shoulder_CurveJnt") ($mod_lCore + "_Shoulder_CurveSHJnt");
		parent ($mod_lCore + "_Shoulder_CurveSHJnt") $parentJnt;
		$JointOrient = `getAttr  ($mod_lCore + "_Shoulder_CurveJnt.jointOrient")`;
		setAttr (($mod_lCore + "_Shoulder_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_Shoulder_CurveSHJnt");
	}		
	
	//CHECK FOR TOON ARMS
	if (`objExists ($mod_lCore + "_Upper_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Upper_Curve?Jnt")`;
		$sizeUpperJnt = `size $upperJnt`;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	if (`objExists ($mod_lCore + "_ElbowJnt")`)
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Elbow_CurveJnt")`)
		{
			joint -n ($mod_lCore + "_ElbowSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_ElbowSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_ElbowSHJnt.forearm");
	
			parentConstraint  ($mod_lCore + "_ElbowJnt")  ($mod_lCore + "_ElbowSHJnt");
			parent ($mod_lCore + "_ElbowSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_ElbowJnt.jointOrient")`;
			setAttr (($mod_lCore + "_ElbowSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_ElbowSHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Elbow_CurveSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow_CurveSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Elbow_CurveSHJnt.forearm");
	
			parentConstraint ($mod_lCore + "_Elbow_CurveJnt") ($mod_lCore + "_Elbow_CurveSHJnt");
			parent ($mod_lCore + "_Elbow_CurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Elbow_CurveJnt.jointOrient")`;
			setAttr (($mod_lCore + "_Elbow_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Elbow_CurveSHJnt");
		}
	}
	else
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Elbow1_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Elbow1SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow1SHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Elbow1SHJnt.forearm");
	
			parentConstraint  ($mod_lCore + "_Elbow1Jnt")  ($mod_lCore + "_Elbow1SHJnt");
			parent ($mod_lCore + "_Elbow1SHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Elbow1Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Elbow1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Elbow1SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Elbow1_CurveSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow1_CurveSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Elbow1_CurveSHJnt.forearm");
	
			parentConstraint ($mod_lCore + "_Elbow1_CurveJnt") ($mod_lCore + "_Elbow1_CurveSHJnt");
			parent ($mod_lCore + "_Elbow1_CurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Elbow1_CurveJnt.jointOrient")`;
			setAttr (($mod_lCore + "_Elbow1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Elbow1_CurveSHJnt");
		}
		
		if (`objExists ($mod_lCore + "_Middle_Curve1Jnt")`)
		{
			$middleCurveJnt = `ls ($mod_lCore + "_Middle_Curve?Jnt")`;
			$sizeMiddleCurveJnt = `size $middleCurveJnt`;
			int $crntNum = 1;
			for ($crntMiddleCurve in $middleCurveJnt)
			{
				select -cl;
				joint -n ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parent ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
				setAttr (($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		if (!`objExists ($mod_lCore + "_Elbow2_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Elbow2SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow2SHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Elbow2SHJnt.forearm");
	
			parentConstraint  ($mod_lCore + "_Elbow2Jnt")  ($mod_lCore + "_Elbow2SHJnt");
			parent ($mod_lCore + "_Elbow2SHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Elbow2Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Elbow2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Elbow2SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Elbow2_CurveSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow2_CurveSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Elbow2_CurveSHJnt.forearm");
	
			parentConstraint ($mod_lCore + "_Elbow2_CurveJnt") ($mod_lCore + "_Elbow2_CurveSHJnt");
			parent ($mod_lCore + "_Elbow2_CurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Elbow2_CurveJnt.jointOrient")`;
			setAttr (($mod_lCore + "_Elbow2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Elbow2_CurveSHJnt");
		}
	}

	if (`objExists ($mod_lCore + "_Lower_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Lower_Curve?Jnt")`;
		$sizeUpperJnt = `size $upperJnt`;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	
	select -cl;
	joint -n ($mod_lCore + "_WristSHJnt");
	addAttr -ln "hand"  -at bool ($mod_lCore + "_WristSHJnt");
	setAttr -e-keyable true ($mod_lCore + "_WristSHJnt.hand");

	parentConstraint ($mod_lCore + "_WristJnt") ($mod_lCore + "_WristSHJnt");
	parent  ($mod_lCore + "_WristSHJnt") $parentJnt;
	$JointOrient = `getAttr  ($mod_lCore + "_WristJnt.jointOrient")`;
	setAttr (($mod_lCore + "_WristSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	//RIGHT SIDE//////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////

	if (`objExists ($topNode + ".pair")`)
	{
		$rPrfx = "l_";
		$rPrfx = "r_";

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

		//GENERATE JOINTS
		select -cl;
		joint -n ($mod_rCore + "_ClavicleSHJnt");
		addAttr -ln "shoulder"  -at bool ($mod_rCore + "_ClavicleSHJnt");
		setAttr -e-keyable true ($mod_rCore + "_ClavicleSHJnt.shoulder");
	
		parentConstraint ($mod_rCore + "_ClavicleJnt") ($mod_rCore + "_ClavicleSHJnt");
		parent  ($mod_rCore + "_ClavicleSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
		$JointOrient = `getAttr  ($mod_rCore + "_ClavicleJnt.jointOrient")`;
		setAttr (($mod_rCore + "_ClavicleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		$parentJnt = ($mod_rCore + "_ClavicleSHJnt");
		
		if (!`objExists ($mod_rCore + "_Shoulder_CurveJnt")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_ShoulderSHJnt");
			addAttr -ln "arm"  -at bool ($mod_rCore + "_ShoulderSHJnt");
			setAttr -e-keyable true ($mod_rCore + "_ShoulderSHJnt.arm");
	
			parentConstraint ($mod_rCore + "_ShoulderJnt") ($mod_rCore + "_ShoulderSHJnt");
			parent ($mod_rCore + "_ShoulderSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_rCore + "_ShoulderJnt.jointOrient")`;
			setAttr (($mod_rCore + "_ShoulderSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_ShoulderSHJnt");
		}
		else
		{
			select -cl;
			joint -n ($mod_rCore + "_Shoulder_CurveSHJnt");
			parentConstraint ($mod_rCore + "_Shoulder_CurveJnt") ($mod_rCore + "_Shoulder_CurveSHJnt");
			parent ($mod_rCore + "_Shoulder_CurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_rCore + "_Shoulder_CurveJnt.jointOrient")`;
			setAttr (($mod_rCore + "_Shoulder_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_Shoulder_CurveSHJnt");
		}		
		
		//CHECK FOR TOON ARMS
		if (`objExists ($mod_rCore + "_Upper_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Upper_Curve?Jnt")`;
			$sizeUpperJnt = `size $upperJnt`;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		if (`objExists ($mod_rCore + "_ElbowJnt")`)
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Elbow_CurveJnt")`)
			{
				joint -n ($mod_rCore + "_ElbowSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_ElbowSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_ElbowSHJnt.forearm");
		
				parentConstraint  ($mod_rCore + "_ElbowJnt")  ($mod_rCore + "_ElbowSHJnt");
				parent ($mod_rCore + "_ElbowSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_ElbowJnt.jointOrient")`;
				setAttr (($mod_rCore + "_ElbowSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_ElbowSHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Elbow_CurveSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow_CurveSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Elbow_CurveSHJnt.forearm");
		
				parentConstraint ($mod_rCore + "_Elbow_CurveJnt") ($mod_rCore + "_Elbow_CurveSHJnt");
				parent ($mod_rCore + "_Elbow_CurveSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Elbow_CurveJnt.jointOrient")`;
				setAttr (($mod_rCore + "_Elbow_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Elbow_CurveSHJnt");
			}
		}
		else
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Elbow1_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Elbow1SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow1SHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Elbow1SHJnt.forearm");
		
				parentConstraint  ($mod_rCore + "_Elbow1Jnt")  ($mod_rCore + "_Elbow1SHJnt");
				parent ($mod_rCore + "_Elbow1SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Elbow1Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Elbow1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Elbow1SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Elbow1_CurveSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow1_CurveSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Elbow1_CurveSHJnt.forearm");
		
				parentConstraint ($mod_rCore + "_Elbow1_CurveJnt") ($mod_rCore + "_Elbow1_CurveSHJnt");
				parent ($mod_rCore + "_Elbow1_CurveSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Elbow1_CurveJnt.jointOrient")`;
				setAttr (($mod_rCore + "_Elbow1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Elbow1_CurveSHJnt");
			}
				
			if (`objExists ($mod_rCore + "_Middle_Curve1Jnt")`)
			{
				$middleCurveJnt = `ls ($mod_rCore + "_Middle_Curve?Jnt")`;
				$sizeMiddleCurveJnt = `size $middleCurveJnt`;
				int $crntNum = 1;
				for ($crntMiddleCurve in $middleCurveJnt)
				{
					select -cl;
					joint -n ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parentConstraint ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parent ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
					$JointOrient = `getAttr  ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
					setAttr (($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
					
					$crntNum++;
				}
			}

			select -cl;
			if (!`objExists ($mod_rCore + "_Elbow2_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Elbow2SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow2SHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Elbow2SHJnt.forearm");
		
				parentConstraint  ($mod_rCore + "_Elbow2Jnt")  ($mod_rCore + "_Elbow2SHJnt");
				parent ($mod_rCore + "_Elbow2SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Elbow2Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Elbow2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Elbow2SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Elbow2_CurveSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow2_CurveSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Elbow2_CurveSHJnt.forearm");
		
				parentConstraint ($mod_rCore + "_Elbow2_CurveJnt") ($mod_rCore + "_Elbow2_CurveSHJnt");
				parent ($mod_rCore + "_Elbow2_CurveSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Elbow2_CurveJnt.jointOrient")`;
				setAttr (($mod_rCore + "_Elbow2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Elbow2_CurveSHJnt");
			}
		}
    	
		if (`objExists ($mod_rCore + "_Lower_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Lower_Curve?Jnt")`;
			$sizeUpperJnt = `size $upperJnt`;
			string $crntUpper;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		joint -n ($mod_rCore + "_WristSHJnt");
		addAttr -ln "hand"  -at bool ($mod_rCore + "_WristSHJnt");
		setAttr -e-keyable true ($mod_rCore + "_WristSHJnt.hand");

		parentConstraint ($mod_rCore + "_WristJnt") ($mod_rCore + "_WristSHJnt");
		parent  ($mod_rCore + "_WristSHJnt") $parentJnt;	
		$JointOrient = `getAttr  ($mod_rCore + "_WristJnt.jointOrient")`;
		setAttr (($mod_rCore + "_WristSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE LEG SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigLegSH(string $modName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	//GENERATE JOINTS
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	if (!`objExists ($mod_rCore + "_HipCurveJnt")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_HipSHJnt");
		addAttr -ln "upLeg"  -at bool ($mod_lCore + "_HipSHJnt");
		setAttr -e-keyable true ($mod_lCore + "_HipSHJnt.upLeg");
	
		parentConstraint ($mod_lCore + "_HipJnt") ($mod_lCore + "_HipSHJnt");
		parent ($mod_lCore + "_HipSHJnt") $parentJnt;
		$JointOrient = `getAttr  ($mod_lCore + "_HipJnt.jointOrient")`;
		setAttr (($mod_lCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_HipSHJnt");
	}
	else
	{
		select -cl;
		joint -n ($mod_lCore + "_HipCurveSHJnt");
		addAttr -ln "upLeg"  -at bool ($mod_lCore + "_HipCurveSHJnt");
		setAttr -e-keyable true ($mod_lCore + "_HipCurveSHJnt.upLeg");
	
		parentConstraint ($mod_lCore + "_HipCurveJnt") ($mod_lCore + "_HipCurveSHJnt");
		parent ($mod_lCore + "_HipCurveSHJnt") $parentJnt;
		$JointOrient = `getAttr  ($mod_lCore + "_HipCurveJnt.jointOrient")`;
		setAttr (($mod_lCore + "_HipCurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_HipCurveSHJnt");
	}		
	
	//CHECK FOR TOON LEGS
	if (`objExists ($mod_lCore + "_Upper_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Upper_Curve?Jnt")`;
		$sizeUpperJnt = `size $upperJnt`;
		string $crntUpper;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	if (`objExists ($mod_lCore + "_KneeJnt")`)
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Knee_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_KneeSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_KneeSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_KneeSHJnt.forearm");
	
			parentConstraint  ($mod_lCore + "_KneeJnt")  ($mod_lCore + "_KneeSHJnt");
			parent ($mod_lCore + "_KneeSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_KneeJnt.jointOrient")`;
			setAttr (($mod_lCore + "_KneeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_KneeSHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Knee_CurveSHJnt");
			addAttr -ln "leg"  -at bool ($mod_lCore + "_Knee_CurveSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Knee_CurveSHJnt.leg");
	
			parentConstraint ($mod_lCore + "_Knee_CurveJnt") ($mod_lCore + "_Knee_CurveSHJnt");
			parent ($mod_lCore + "_Knee_CurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Knee_CurveJnt.jointOrient")`;
			setAttr (($mod_lCore + "_Knee_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Knee_CurveSHJnt");
		}
	}
	else
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Knee1_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Knee1SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Knee1SHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Knee1SHJnt.forearm");
	
			parentConstraint  ($mod_lCore + "_Knee1Jnt")  ($mod_lCore + "_Knee1SHJnt");
			parent ($mod_lCore + "_Knee1SHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Knee1Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Knee1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Knee1SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Knee1_CurveSHJnt");
			addAttr -ln "leg"  -at bool ($mod_lCore + "_Knee1_CurveSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Knee1_CurveSHJnt.leg");
	
			parentConstraint ($mod_lCore + "_Knee1_CurveJnt") ($mod_lCore + "_Knee1_CurveSHJnt");
			parent ($mod_lCore + "_Knee1_CurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Knee1_CurveJnt.jointOrient")`;
			setAttr (($mod_lCore + "_Knee1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Knee1_CurveSHJnt");
		}
		
		if (`objExists ($mod_lCore + "_Middle_Curve1Jnt")`)
		{
			$middleCurveJnt = `ls ($mod_lCore + "_Middle_Curve?Jnt")`;
			$sizeMiddleCurveJnt = `size $middleCurveJnt`;
			string $crntMiddleCurve;
			int $crntNum = 1;
			for ($crntMiddleCurve in $middleCurveJnt)
			{
				
				select -cl;
				joint -n ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parent ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
				setAttr (($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		if (!`objExists ($mod_lCore + "_Knee2_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Knee2SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Knee2SHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Knee2SHJnt.forearm");
	
			parentConstraint  ($mod_lCore + "_Knee2Jnt")  ($mod_lCore + "_Knee2SHJnt");
			parent ($mod_lCore + "_Knee2SHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Knee2Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Knee2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Knee2SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Knee2_CurveSHJnt");
			addAttr -ln "leg"  -at bool ($mod_lCore + "_Knee2_CurveSHJnt");
			setAttr -e-keyable true ($mod_lCore + "_Knee2_CurveSHJnt.leg");
	
			parentConstraint ($mod_lCore + "_Knee2_CurveJnt") ($mod_lCore + "_Knee2_CurveSHJnt");
			parent ($mod_lCore + "_Knee2_CurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_lCore + "_Knee2_CurveJnt.jointOrient")`;
			setAttr (($mod_lCore + "_Knee2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Knee2_CurveSHJnt");
		}
	}

	if (`objExists ($mod_lCore + "_Lower_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Lower_Curve?Jnt")`;
		$sizeUpperJnt = `size $upperJnt`;
		string $crntUpper;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
			$JointOrient = `getAttr ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	
	select -cl;
	joint -n ($mod_lCore + "_AnkleSHJnt");
	addAttr -ln "foot"  -at bool ($mod_lCore + "_AnkleSHJnt");
	setAttr -e-keyable true ($mod_lCore + "_AnkleSHJnt.foot");

	parentConstraint ($mod_lCore + "_AnkleJnt") ($mod_lCore + "_AnkleSHJnt");
	parent  ($mod_lCore + "_AnkleSHJnt") $parentJnt;
	$JointOrient = `getAttr  ($mod_lCore + "_AnkleJnt.jointOrient")`;
	setAttr (($mod_lCore + "_AnkleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	$parentJnt = ($mod_lCore + "_AnkleSHJnt");
	
	select -cl;
	joint -n ($mod_lCore + "_BallSHJnt");
	addAttr -ln "toeBase"  -at bool ($mod_lCore + "_BallSHJnt");
	setAttr -e-keyable true ($mod_lCore + "_BallSHJnt.toeBase");

	parentConstraint ($mod_lCore + "_BallJnt") ($mod_lCore + "_BallSHJnt");
	parent ($mod_lCore + "_BallSHJnt") $parentJnt;
	$JointOrient = `getAttr  ($mod_lCore + "_BallJnt.jointOrient")`;
	setAttr (($mod_lCore + "_BallSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	$parentJnt = ($mod_lCore + "_BallSHJnt");
	
	select -cl;
	joint -n ($mod_lCore + "_ToeSHJnt");
	parentConstraint ($mod_lCore + "_ToeJnt") ($mod_lCore + "_ToeSHJnt");
	parent  ($mod_lCore + "_ToeSHJnt") $parentJnt;
	$JointOrient = `getAttr  ($mod_lCore + "_ToeJnt.jointOrient")`;
	setAttr (($mod_lCore + "_ToeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	//RIGHT SIDE//////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////

	if (`objExists ($topNode + ".pair")`)
	{
		$rPrfx = "l_";
		$rPrfx = "r_";

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

		//GENERATE JOINTS
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		if (!`objExists ($mod_rCore + "_HipCurveJnt")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_HipSHJnt");
			addAttr -ln "upLeg"  -at bool ($mod_rCore + "_HipSHJnt");
			setAttr -e-keyable true ($mod_rCore + "_HipSHJnt.upLeg");

			parentConstraint ($mod_rCore + "_HipJnt") ($mod_rCore + "_HipSHJnt");
			parent ($mod_rCore + "_HipSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_rCore + "_HipJnt.jointOrient")`;
			setAttr (($mod_rCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_HipSHJnt");
		}
		else
		{
			select -cl;
			joint -n ($mod_rCore + "_HipCurveSHJnt");
			addAttr -ln "upLeg"  -at bool ($mod_rCore + "_HipCurveSHJnt");
			setAttr -e-keyable true ($mod_rCore + "_HipCurveSHJnt.upLeg");

			parentConstraint ($mod_rCore + "_HipCurveJnt") ($mod_rCore + "_HipCurveSHJnt");
			parent ($mod_rCore + "_HipCurveSHJnt") $parentJnt;
			$JointOrient = `getAttr  ($mod_rCore + "_HipCurveJnt.jointOrient")`;
			setAttr (($mod_rCore + "_HipCurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_HipCurveSHJnt");
		}		
		
		//CHECK FOR TOON LEGS
		if (`objExists ($mod_rCore + "_Upper_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Upper_Curve?Jnt")`;
			$sizeUpperJnt = `size $upperJnt`;
			string $crntUpper;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		if (`objExists ($mod_rCore + "_KneeJnt")`)
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Knee_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_KneeSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_KneeSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_KneeSHJnt.forearm");
		
				parentConstraint  ($mod_rCore + "_KneeJnt")  ($mod_rCore + "_KneeSHJnt");
				parent ($mod_rCore + "_KneeSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_KneeJnt.jointOrient")`;
				setAttr (($mod_rCore + "_KneeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_KneeSHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Knee_CurveSHJnt");
				addAttr -ln "leg"  -at bool ($mod_rCore + "_Knee_CurveSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Knee_CurveSHJnt.leg");
		
				parentConstraint ($mod_rCore + "_Knee_CurveJnt") ($mod_rCore + "_Knee_CurveSHJnt");
				parent ($mod_rCore + "_Knee_CurveSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Knee_CurveJnt.jointOrient")`;
				setAttr (($mod_rCore + "_Knee_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Knee_CurveSHJnt");
			}
		}
		else
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Knee1_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Knee1SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Knee1SHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Knee1SHJnt.forearm");
		
				parentConstraint  ($mod_rCore + "_Knee1Jnt")  ($mod_rCore + "_Knee1SHJnt");
				parent ($mod_rCore + "_Knee1SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Knee1Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Knee1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Knee1SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Knee1_CurveSHJnt");
				addAttr -ln "leg"  -at bool ($mod_rCore + "_Knee1_CurveSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Knee1_CurveSHJnt.leg");
		
				parentConstraint ($mod_rCore + "_Knee1_CurveJnt") ($mod_rCore + "_Knee1_CurveSHJnt");
				parent ($mod_rCore + "_Knee1_CurveSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Knee1_CurveJnt.jointOrient")`;
				setAttr (($mod_rCore + "_Knee1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Knee1_CurveSHJnt");
			}
			
			if (`objExists ($mod_rCore + "_Middle_Curve1Jnt")`)
			{
				$middleCurveJnt = `ls ($mod_rCore + "_Middle_Curve?Jnt")`;
				$sizeMiddleCurveJnt = `size $middleCurveJnt`;
				string $crntMiddleCurve;
				int $crntNum = 1;
				for ($crntMiddleCurve in $middleCurveJnt)
				{
					
					select -cl;
					joint -n ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parentConstraint ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parent ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
					$JointOrient = `getAttr  ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
					setAttr (($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
					
					$crntNum++;
				}
			}
			select -cl;
			if (!`objExists ($mod_rCore + "_Knee2_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Knee2SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Knee2SHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Knee2SHJnt.forearm");
		
				parentConstraint  ($mod_rCore + "_Knee2Jnt")  ($mod_rCore + "_Knee2SHJnt");
				parent ($mod_rCore + "_Knee2SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Knee2Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Knee2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Knee2SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Knee2_CurveSHJnt");
				addAttr -ln "leg"  -at bool ($mod_rCore + "_Knee2_CurveSHJnt");
				setAttr -e-keyable true ($mod_rCore + "_Knee2_CurveSHJnt.leg");
		
				parentConstraint ($mod_rCore + "_Knee2_CurveJnt") ($mod_rCore + "_Knee2_CurveSHJnt");
				parent ($mod_rCore + "_Knee2_CurveSHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Knee2_CurveJnt.jointOrient")`;
				setAttr (($mod_rCore + "_Knee2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Knee2_CurveSHJnt");
			}
		}
    	
		if (`objExists ($mod_rCore + "_Lower_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Lower_Curve?Jnt")`;
			$sizeUpperJnt = `size $upperJnt`;
			string $crntUpper;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				
				select -cl;
				joint -n ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
				$JointOrient = `getAttr  ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		joint -n ($mod_rCore + "_AnkleSHJnt");
		addAttr -ln "foot"  -at bool ($mod_rCore + "_AnkleSHJnt");
		setAttr -e-keyable true ($mod_rCore + "_AnkleSHJnt.foot");

		parentConstraint ($mod_rCore + "_AnkleJnt") ($mod_rCore + "_AnkleSHJnt");
		parent  ($mod_rCore + "_AnkleSHJnt") $parentJnt;
		$JointOrient = `getAttr  ($mod_rCore + "_AnkleJnt.jointOrient")`;
		setAttr (($mod_rCore + "_AnkleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_rCore + "_AnkleSHJnt");
			
		select -cl;
		joint -n ($mod_rCore + "_BallSHJnt");
		addAttr -ln "toeBase"  -at bool ($mod_rCore + "_BallSHJnt");
		setAttr -e-keyable true ($mod_rCore + "_BallSHJnt.toeBase");

		parentConstraint ($mod_rCore + "_BallJnt") ($mod_rCore + "_BallSHJnt");
		parent  ($mod_rCore + "_BallSHJnt") $parentJnt;
		$JointOrient = `getAttr  ($mod_rCore + "_BallJnt.jointOrient")`;
		setAttr (($mod_rCore + "_BallSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_rCore + "_BallSHJnt");
		
		select -cl;
		joint -n ($mod_rCore + "_ToeSHJnt");
		parentConstraint ($mod_rCore + "_ToeJnt") ($mod_rCore + "_ToeSHJnt");
		parent  ($mod_rCore + "_ToeSHJnt") $parentJnt;
		$JointOrient = `getAttr  ($mod_rCore + "_ToeJnt.jointOrient")`;
		setAttr (($mod_rCore + "_ToeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////GENERATE FK CHAIN SH MODULE////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigFkChainSH(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	$allJoints = `ls ("RRM_" + $lPrfx + $core + "_??_??")`;
	$sizeAllJoints = `size $allJoints`;
	$fKChain = `ls ("RRM_" + $lPrfx + $core + "_??_01")`;
	$fKChainSize = `size $fKChain`;
	string $crntFKChain;
	$crntCh = 1;
	$crntJnt = 1;
		
	for ($crntFKChain in $fKChain)                                    
	{
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		string $nPdCh = "";
		if ($crntCh < 10)
		{
			$nPdCh = "0";
		}
		
		$fKJoints = `ls ("RRM_" + $lPrfx + $core + "_" + $nPdCh + $crntCh + "_" + "??")`;
		string $crntFKJoint;
		$crntJnt = 1;
		for ($crntFKJoint in $fKJoints)
		{
			string $nPd = "";
			if ($crntJnt < 10)
			{
				$nPd = "0";
			}
			$nextJnt = ($crntJnt + 1);
			$nPdNext = "";
			if ($nextJnt <10)
			{
				$nPdNext = "0";
			}
			select -cl;
			joint -n ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
			parentConstraint ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
			parent ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt") $parentJnt;
			$JointOrient = `getAttr ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.jointOrient")`;
			setAttr (($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$parentJnt = ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
			
			$crntJnt++;
		}
		$crntCh++;
	}
	
	//RIGHT SIDE////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
		
		$mod_lCore = ($modName + "_" + $lPrfx + $core);
		$mod_rCore = ($modName + "_" + $rPrfx + $core);
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		$allJoints = `ls ("RRM_" + $lPrfx + $core + "_??_??")`;
		$sizeAllJoints = `size $allJoints`;
		$fKChain = `ls ("RRM_" + $lPrfx + $core + "_??_01")`;
		$fKChainSize = `size $fKChain`;
		$crntCh = 1;
		$crntJnt = 1;
			
		for ($crntFKChain in $fKChain)                                    
		{
			$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
			string $nPdCh = "";
			if ($crntCh < 10)
			{
				$nPdCh = "0";
			}
			
			select ;
			$fKProxies = `ls ("RRM_" + $lPrfx + $core + "_" + $nPdCh + $crntCh + "_" + "??")`;
			$crntJnt = 1;
			for ($crntFKJoint in $fKProxies)
			{
				string $nPd = "";
				if ($crntJnt < 10)
				{
					$nPd = "0";
				}
				$nextJnt = ($crntJnt + 1);
				$nPdNext = "";
				if ($nextJnt <10)
				{
					$nPdNext = "0";
				}
				select -cl;
				joint -n ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				parentConstraint ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				parent ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt") $parentJnt;
				$JointOrient = `getAttr ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.jointOrient")`;
				setAttr (($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$parentJnt = ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				
				$crntJnt++;
			}
			$crntCh++;
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////GENERATE HEAD SH MODULE////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigHeadSH(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	

	if (`objExists ($mod_lCore + "_JawJnt")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_JawSHJnt");
		parentConstraint ($mod_lCore + "_JawJnt") ($mod_lCore + "_JawSHJnt");
		parent ($mod_lCore + "_JawSHJnt") $parentJnt;
		$JointOrient = `getAttr ($mod_lCore + "_JawJnt.jointOrient")`;
		setAttr (($mod_lCore + "_JawSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		select -cl;
		joint -n ($mod_lCore + "_JawEndSHJnt");
		parentConstraint ($mod_lCore + "_JawEndJnt") ($mod_lCore + "_JawEndSHJnt");
		parent ($mod_lCore + "_JawEndSHJnt") ($mod_lCore + "_JawSHJnt");
		$JointOrient = `getAttr ($mod_lCore + "_JawEndJnt.jointOrient")`;
		setAttr (($mod_lCore + "_JawEndSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}

	select -cl;
	joint -n ($mod_lCore + "_TopSHJnt");
	parentConstraint ($mod_lCore + "_TopJnt") ($mod_lCore + "_TopSHJnt");
	parent ($mod_lCore + "_TopSHJnt") $parentJnt;
	$JointOrient = `getAttr ($mod_lCore + "_TopJnt.jointOrient")`;
	setAttr (($mod_lCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);

	//RIGHT SIDE
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
    	
		$mod_lCore = ($modName + "_" + $lPrfx + $core);
		$mod_rCore = ($modName + "_" + $rPrfx + $core);
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		if (`objExists ($mod_rCore + "_JawJnt")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_JawSHJnt");
			parentConstraint ($mod_rCore + "_JawJnt") ($mod_rCore + "_JawSHJnt");
			parent ($mod_rCore + "_JawSHJnt") $parentJnt;
			$JointOrient = `getAttr ($mod_rCore + "_JawJnt.jointOrient")`;
			setAttr (($mod_rCore + "_JawSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			select -cl;
			joint -n ($mod_rCore + "_JawEndSHJnt");
			parentConstraint ($mod_rCore + "_JawEndJnt") ($mod_rCore + "_JawEndSHJnt");
			parent ($mod_rCore + "_JawEndSHJnt") ($mod_rCore + "_JawSHJnt");
			$JointOrient = `getAttr ($mod_rCore + "_JawEndJnt.jointOrient")`;
			setAttr (($mod_rCore + "_JawEndSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		}
    	
		select -cl;
		joint -n ($mod_rCore + "_TopSHJnt");
		parentConstraint ($mod_rCore + "_TopJnt") ($mod_rCore + "_TopSHJnt");
		parent ($mod_rCore + "_TopSHJnt") $parentJnt;
		$JointOrient = `getAttr ($mod_rCore + "_TopJnt.jointOrient")`;
		setAttr (($mod_rCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);

	}
}
		
////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE LOOK AT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigLookAtSH(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	//EYE JOINTS
	$lookAts = `ls ("RRM_" + $lPrfx + $core + "_??")`;
	$lookAtNum = `size $lookAts`;
	string $crntLookAt;
	$crntNum = 1;
	for ($crntLookAt in $lookAts)
	{
		string $nPd = "";
		if ($crntNum < 10)
		{
			$nPd = "0";
		}
		select -cl;
		joint -n ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt");
		parentConstraint ($mod_lCore + "_" + $nPd + $crntNum + "Jnt") ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt");
		parent ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt") $parentJnt;
		$JointOrient = `getAttr ($mod_lCore + "_" + $nPd + $crntNum + "Jnt.jointOrient")`;
		setAttr (($mod_lCore + "_" + $nPd + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		$crntNum++;
	}
	
	//RIGHT SIDE		
	if (`objExists ($topNode + ".pair")`)
	{
		$rPrfx = "l_";
		$rPrfx = "r_";
	
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
    	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

		$mod_lCore = ($modName + "_" + $lPrfx + $core);
		$mod_rCore = ($modName + "_" + $rPrfx + $core);
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		//EYE JOINTS
		$lookAts = `ls ("RRM_" + $lPrfx + $core + "_??")`;
		$lookAtNum = `size $lookAts`;
		string $crntLookAt;
		$crntNum = 1;
		for ($crntLookAt in $lookAts)
		{
			string $nPd = "";
			if ($crntNum < 10)
			{
				$nPd = "0";
			}
			select -cl;
			joint -n ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt");
			parentConstraint ($mod_rCore + "_" + $nPd + $crntNum + "Jnt") ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt");
			parent ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt") $parentJnt;
			$JointOrient = `getAttr ($mod_rCore + "_" + $nPd + $crntNum + "Jnt.jointOrient")`;
			setAttr (($mod_rCore + "_" + $nPd + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
}

		
////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE AUX AT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRigAuxiliarySH(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Aux.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core + "_Aux");
	$mod_rCore = ($modName + "_" + $rPrfx + $core + "_Aux");
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	select -cl;
	joint -n ($mod_lCore + "SHJnt");
	parentConstraint ($mod_lCore + "Jnt") ($mod_lCore + "SHJnt");
	parent ($mod_lCore + "SHJnt") $parentJnt;
	$JointOrient = `getAttr ($mod_lCore + "Jnt.jointOrient")`;
	setAttr (($mod_lCore + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);

	//RIGHT SIDE
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Aux.attachNode")`;
    	
		$mod_lCore = ($modName + "_" + $lPrfx + $core + "_Aux");
		$mod_rCore = ($modName + "_" + $rPrfx + $core + "_Aux");
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
    	
		select -cl;
		joint -n ($mod_rCore + "SHJnt");
		parentConstraint ($mod_rCore + "Jnt") ($mod_rCore + "SHJnt");
		parent ($mod_rCore + "SHJnt") $parentJnt;
		$JointOrient = `getAttr ($mod_rCore + "Jnt.jointOrient")`;
		setAttr (($mod_rCore + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
}


global proc RRM_MirrorAttributes(string $modName, string $moduleName)
{
	if (`objExists ($modName + "_l_" + $moduleName + "*Ctrl")`)
	{
		select ;
		$lControls = `ls -type "transform" ($modName + "_l_" + $moduleName + "*Ctrl")`;
		
		for ($lCurrentControl in $lControls)
		{
			if (!`objExists ($lCurrentControl + ".rightControl")`)
			{
				addAttr -ln "rightControl"  -dt "string" $lCurrentControl;
				setAttr -e-keyable true ($lCurrentControl + ".rightControl");
				$name = substituteAllString ($lCurrentControl, ($modName + "_l_"), ("_r_"));
				setAttr -type "string" ($lCurrentControl + ".rightControl") $name;
				setAttr -l true ($lCurrentControl + ".rightControl");
			}
		}
		
		if (`objExists ($modName + "_r_" + $moduleName + "*Ctrl")`)  
		{
			$rControls = `ls -type "transform" ($modName + "_r_" + $moduleName + "*Ctrl")`;
			
			for ($rCurrentControl in $rControls)
			{
				if (!`objExists ($rCurrentControl + ".leftControl")`)
				{
					addAttr -ln "leftControl"  -dt "string" $rCurrentControl;
					setAttr -e-keyable true ($rCurrentControl + ".leftControl");
					$name = substituteAllString ($rCurrentControl, ($modName + "_r_"), ("_l_"));
					setAttr -type "string" ($rCurrentControl + ".leftControl") $name;
					setAttr -l true ($rCurrentControl + ".leftControl");
				}
			}
		}
	}
}

global proc RRM_AddRigName(string $modName, string $modControls[])
{
	for ($crntControl in $modControls)
	{
		addAttr -ln "modRigName"  -dt "string" $crntControl;
		setAttr -e-keyable true ($crntControl + ".modRigName");
		setAttr -type "string" ($crntControl + ".modRigName") $modName;
		setAttr -l true ($crntControl + ".modRigName");
	}
	
	addAttr -ln "modRigConnection"  -dt "string" $modName;
	setAttr -e-keyable true ($modName + ".modRigConnection");
	setAttr -type "string" ($modName + ".modRigConnection") $modName;
	setAttr -l true ($modName + ".modRigConnection");
	
	for ($crntControl in $modControls)
	{
		addAttr -ln "modRigConnection"  -dt "string" $crntControl;
		setAttr -e-keyable true ($crntControl + ".modRigConnection");
		connectAttr -f ($modName + ".modRigConnection") ($crntControl + ".modRigConnection");
		setAttr -l true ($crntControl + ".modRigConnection");
	}
}

global proc RRM_AddControlsSize(string $modControls[])
{
	for ($each in $modControls)
	{
		if (!`objExists ($each + ".nonControl")`)
		{
			addAttr -ln "controlSizeX"  -at double  -dv 1 $each;
			setAttr -e -keyable true ($each + ".controlSizeX");
			setAttr -lock true ($each + ".controlSizeX");

			addAttr -ln "controlSizeY"  -at double  -dv 1 $each;
			setAttr -e -keyable true ($each + ".controlSizeY");
			setAttr -lock true ($each + ".controlSizeY");

			addAttr -ln "controlSizeZ"  -at double  -dv 1 $each;
			setAttr -e -keyable true ($each + ".controlSizeZ");
			setAttr -lock true ($each + ".controlSizeZ");
			
			//ADD MIRROR ATTRIBUTE
			addAttr -ln "isMirrored"  -at double  -dv 1 $each;
			setAttr -e -keyable false ($each + ".isMirrored");
			setAttr ($each + ".isMirrored") 1015;
		}
	}
}

global proc RRM_LockAndHideNonModNodes(string $modName)
{
	$allNodes = `listRelatives -ad ($modName + "_MAINCtrl")`;
	$nurbsCurveShapes = `listRelatives -ad -type "nurbsCurve" ($modName + "_MAINCtrl")`;
	$nurbsCurves = `listRelatives -p $nurbsCurveShapes`;
	$joints = `ls -type "joint" $allNodes`;
	$constraints = `ls -type "constraint" $allNodes`;
	
	select $allNodes ($modName + "_MAINCtrl");
	select -d $nurbsCurves $nurbsCurveShapes $joints $constraints;
	$nonKeyableNodes = `ls -sl`;
	$sizeNonKeyableNodes = `size $nonKeyableNodes`;
	
	global string $gMainProgressBar;
	progressBar -edit
    	-beginProgress
    	-isInterruptable true
    	-status "Finishing up..."
    	-maxValue ($sizeNonKeyableNodes)
    	$gMainProgressBar;
    	
    $crntNum = 1;
    	
	string $crntNode;
	for ($crntNode in $nonKeyableNodes)
	{
		$keyableAttributes = `listAttr -lf -k -v $crntNode`;
		string $crntAttribute;
		for ($crntAttribute in $keyableAttributes)
		{
			if(`attributeExists $crntAttribute $crntNode`)
			{
				setAttr -k 0 -l 1 ($crntNode + "." + $crntAttribute);
			}
		}
		progressBar -edit -step 1 $gMainProgressBar;		
		$crntNum++;
	}
	for ($crntNode in $constraints)
	{
		$keyableAttributes = `listAttr -lf -k -v $crntNode`;
		for ($crntAttribute in $keyableAttributes)
		{
			if(`attributeExists $crntAttribute $crntNode`)
			{
				setAttr -l 1 ($crntNode + "." + $crntAttribute);
			}
		}
		progressBar -edit -step 1 $gMainProgressBar;		
		$crntNum++;
	}		
	$nonKeyableJoints = `ls $joints`;
	string $crntJoint;
	for ($crntJoint in $nonKeyableJoints)
	{
		$keyableAttributes = `listAttr -lf -k -v $crntJoint`;
		string $crntAttribute;
		for ($crntAttribute in $keyableAttributes)
		{
			if(`attributeExists $crntAttribute $crntJoint`)
			{
				setAttr -k 0 ($crntJoint + "." + $crntAttribute);
			}
		}
		progressBar -edit -step 1 $gMainProgressBar;		
		$crntNum++;
	}
	progressBar -edit -endProgress $gMainProgressBar;

}


global proc RRM_SingleHierarchyInterface(string $modName)
{
	string $returnVal_SH_Generate = `confirmDialog
	-title "Do you wish to Generate a Single Hierarchy Joint Set?"
		-message "A single hierarchy is only recommended for use in a game environment.\n-Some features may not work properly.\n-Joints do not stretch, but will maintain volume."
		-button "No"
		-button "Yes"
		-button "Yes, and Create Joint at Origin"
		-defaultButton "No"`;
		
	
	if ($returnVal_SH_Generate == "Yes"||$returnVal_SH_Generate == "Yes, and Create Joint at Origin") 
	{
		print {"\nBUILDING \"" + $modName + "\" SINGLE HIERARCHY...\n"};

		select -hi RRM_MAIN;
		$hierarchy = `ls -sl -type "transform"`;
		string $topNodes[];
		string $crntNode;
           
		//SELECT TOP NODES			
		for ($crntNode in $hierarchy)
		{
		    if (`objExists ($crntNode + ".top")`)
		    {
		    $topNodes = `ls $crntNode $topNodes`;
		    }
		}
		//REORDER
		int $topNodesSize = `size $topNodes`;
		int $crntNum = $topNodesSize;
		
		string $reOrder[];
		while ($topNodesSize > 0)
		{
		$topNodesSize--;
		$reOrder = `ls $reOrder $topNodes[$topNodesSize]`;
		}
		
		//GENERATE RIG
		if ($returnVal_SH_Generate == "Yes")
		{
			RRM_GenerateRigRootSH($modName);
		}
		else
		{
			RRM_GenerateRigRootMainSH($modName);
		}
		string $topNode;
		for ($topNode in $reOrder)
		{
			$modType = `getAttr ($topNode + ".top")`;
			if ($modType == "spline")
			{
				RRM_GenerateRigSplineSH($modName, $topNode);
			}
			else if ($modType == "arm")
			{
				RRM_GenerateRigArmSH($modName, $topNode);
			}
			else if ($modType == "leg")
			{
				RRM_GenerateRigLegSH($modName, $topNode);
			}
			else if ($modType == "fkChain")
			{
				RRM_GenerateRigFkChainSH($modName, $topNode);
			}
			else if ($modType == "head")
			{
				RRM_GenerateRigHeadSH($modName, $topNode);
			}
			else if ($modType == "lookAt")
			{
				RRM_GenerateRigLookAtSH($modName, $topNode);
			}
			else if ($modType == "auxiliary")
			{
				RRM_GenerateRigAuxiliarySH($modName, $topNode);
			}
		}
		//ADD SCALE CONSTRAINT TO ENTIRE RIG
		$allSHJnts = `listRelatives -ad -type "joint" ($modName + "_SHJntGrp")`;
		for ($each in $allSHJnts)
		{
			connectAttr -f ($modName + "_MAINCtrl.scale") ($each + ".scale"); 
		}

		print "\nSINGLE HIERARCHY COMPLETED!\n";
	}
}


////////////////////////////////////////////////////////////////////////////////
//BUTTON PROC
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig(string $modName)
{
	if (`objExists RRM_MAIN`)
	{
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl -type "transform"`;
		$size = `size $hierarchy`;
		if ($size > 2)
		{
			string $topNodes[];
			string $crntNode;

			//SELECT TOP NODES			
			for ($crntNode in $hierarchy)
			{
			    if (`objExists ($crntNode + ".top")`)
			    {
			    	$topNodes = `ls $crntNode $topNodes`;
			    }
			}
			
			int $nodeNum = `size $topNodes`;
			if ($nodeNum > 0)
			{
				select $topNodes;

				global string $gMainProgressBar;
				progressBar -edit
    				-beginProgress
    				-isInterruptable true
    				-status "Generating Rig"
    				-maxValue ($nodeNum + 2)
    				$gMainProgressBar;
    			
				//REORDER
				$topNodesSize = `size $topNodes`;
				$crntNum = $topNodesSize;
				
				string $reOrder[];
				while ($topNodesSize > 0)
				{
					$topNodesSize--;
					$reOrder = `ls $reOrder $topNodes[$topNodesSize]`;
				}
				
				//GENERATE RIG
				RRM_GenerateRigRoot($modName);
				string $topNode;
				int $shoulderCheck = 0;
				int $hipCheck = 0;
				for ($topNode in $reOrder)
				{
					$modType = `getAttr ($topNode + ".top")`;
					$moduleName = `getAttr ($topNode + ".core")`;
					if ($modType == "spline")
					{
						progressBar -edit -step 1 -status "Building Spline" $gMainProgressBar;
						RRM_GenerateRigSpline($modName, $moduleName, $topNode);
					}    
					else if ($modType == "arm")
					{
						progressBar -edit -step 1 -status "Building Arm" $gMainProgressBar;
						RRM_GenerateRigArm($modName, $moduleName, $topNode);
						$shoulderCheck = 1;
					}
					else if ($modType == "leg")
					{
						progressBar -edit -step 1 -status "Building Leg" $gMainProgressBar;
						RRM_GenerateRigLeg($modName, $moduleName, $topNode);
						$hipCheck = 1;
					}
					else if ($modType == "fkChain")
					{
						progressBar -edit -step 1 -status "Building FK Chain" $gMainProgressBar;
						RRM_GenerateRigFkChain($modName, $moduleName, $topNode);
					}
					else if ($modType == "head")
					{
						progressBar -edit -step 1 -status "Building Head" $gMainProgressBar;
						RRM_GenerateRigHead($modName, $moduleName, $topNode);
					}
					else if ($modType == "lookAt")
					{
						progressBar -edit -step 1 -status "Building Look-At" $gMainProgressBar;
						RRM_GenerateRigLookAt($modName, $moduleName, $topNode);
					}
					else if ($modType == "auxiliary")
					{
						progressBar -edit -step 1 -status "Building Auxiliary" $gMainProgressBar;
						RRM_GenerateRigAuxiliary($modName, $moduleName, $topNode);
					}
						
					//ADD MIRROR OBJECT ATTRIBUTE
					RRM_MirrorAttributes($modName, $moduleName);
				}
				
				$modControls = `ls -type "transform" ($modName + "_*Ctrl")`;
				
				//ADD RIG NAME TO CONTROLS
				RRM_AddRigName($modName, $modControls);
				
				//ADD CORE CONTROL NAME
				RRM_ControlName($modName, $modControls);
				
				//ADD CONTROL SIZE TO CONTROLS
				RRM_AddControlsSize($modControls);
				
				//CREATE LAYERS
				//LAYER
				progressBar -edit -step 1 -status "Building Layers" $gMainProgressBar;
				
				createDisplayLayer -n ($modName + "_JointsLayer") -number 1 -empty;	
				createDisplayLayer -n ($modName + "_ControlsLayer") -number 1 -empty;
				
				select ($modName + "_*Ctrl");
				select -d ($modName + "_MAINCtrl");
				editDisplayLayerMembers -noRecurse ($modName + "_ControlsLayer") `ls -sl`;
				
				
				progressBar -edit -step 1 -status "Building Layers" $gMainProgressBar;
				select ($modName + "_*Jnt");
				if ($shoulderCheck == 1)
				{
					select -d -hierarchy ($modName + "*ShoulderJnt");
				}
				if ($hipCheck == 1)
				{
					if (`objExists ($modName + "*KneeJnt")`)
					{
						select -d -hierarchy ($modName + "*KneeJnt");
					}
					else
					{
						select -d -hierarchy ($modName + "*Knee1Jnt");
					}
				}
				$joints = `ls -sl`;
				
				editDisplayLayerMembers -noRecurse ($modName + "_JointsLayer") `ls -sl`;
				
				progressBar -edit -endProgress $gMainProgressBar;
				//MAKE ALL NODES UNKEYABLE
				RRM_LockAndHideNonModNodes($modName);

				RRM_SingleHierarchyInterface($modName);
				
				select ($modName + "_MAINCtrl");
			}
			else
			{
			string $returnVal_Generate = `confirmDialog
			-title "Your Rig Has No Modules"
			-message "You must create modules and attach them to your rig.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
			}
		}
		else
		{
			string $returnVal_Generate = `confirmDialog
			-title "Your Rig Has No Modules"
			-message "You must create modules and attach them to your rig.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
		-title "No Rig Exists"
		-message "You must first create a Proxy rig to RRM_Generate a final rig from.\n"
		-button "OK"
		-defaultButton "OK"
		-cancelButton "OK"
		-icon "critical"`;
	}
	if (`objExists ($modName + "_MAINCtrl")`)
	{
		select ($modName + "_MAINCtrl");
	}
	
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;
}

///PROMPTS
global proc RRM_GenerateRigPrompts(string $modName)
{
	//string $modName = `textField -q -text RRM_TextFieldCharName`;
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the rig in character Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Rig's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Rig's Name is not Unique"
			-message "A rig already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		//CHECK IF NODE EDITOR IS OPEN
		string $nodeEditor[] = `getPanel -scriptType nodeEditorPanel `;
		
		for ($editor in $nodeEditor )
		{
			string $tokens[];
			string $control = `scriptedPanel -q -ctl $editor`;
		
			if ( $control != "" )
			{
				if ( 0 < `tokenize $control "|" $tokens` )
				{
					print ( "Window for Node Editor: " + $tokens[0] + "\n" );
				  
					string $NodeEditorUI = `confirmDialog
						-title "Close Node Editor Before Proceeding?"
						-message "The Node Editor is open.\nGenerating a rig with the node editor opened will cause the rig to take much longer to RRM_Generate \n"
						-button "Close Node Editor"
						-button "Ignore"
						-button "Cancel"
						-defaultButton "Close Node Editor"
						-dismissString "Ignore"
						-cancelButton "Ignore"`;
						//-icon "critical"`;
						
					if ($NodeEditorUI == "Close Node Editor")
					{
						deleteUI -window nodeEditorPanel2Window;
					}
				}
		  	}
		}
		
		RRM_GenerateRig($modName);
		if (`objExists ($modName + "_MAINCtrl")`)
		{
			RRM_ColorControls($modName);
			if (`objExists RRM_ProxiesLayer`)
			{
				setAttr RRM_ProxiesLayer.visibility 0;
			}
		}
	}
	//LOAD RIG NAME INTO TEXT FIELD
	textFieldButtonGrp -e -tx $modName RRM_LoadRigTextFieldButtonGrp;
	
	select -cl;
}

///////DEPENDENCIES
global proc RRM_ElbowNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_ElbowJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_ElbowNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_ElbowNum;
	}
}

global proc RRM_KneeNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_KneeJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_KneeNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_KneeNum;
	}
}

global proc RRM_ElbowEditNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_ElbowEditJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_ElbowEditNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_ElbowEditNum;
	}
}

global proc RRM_KneeEditNumLock()
{
	$crntSetting = `radioButtonGrp -q -select RRM_KneeEditJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_KneeEditNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_KneeEditNum;
	}
}

global proc RRM_ToggleTemplate()
{
	$crntSetting = `checkBox -q -v RRM_TemplateCheckBox`;
	if ($crntSetting == 1)
	{
		optionMenu -e -enable 1 RRM_TemplateType;
	}
	else
	{
		optionMenu -e -enable 0 RRM_TemplateType;
	}
}

global proc RRM_ToggleTransferParent()
{
	$crntSetting = `radioButtonGrp -q -select RRM_TransferSelectionButton`;
	if ($crntSetting == 1)
	{
		checkBox -e -enable 0 RRM_TransferParent;
	}
	else
	{
		checkBox -e -enable 1 RRM_TransferParent;
	}
}

//DELETE PROXY RIG
global proc RRM_DeleteProxyRig()
{
	string $confirmDeleteProxies = `confirmDialog
		-title "Delete Proxies"
		-message "Are you sure you want to delete your proxy rig?\n"
		-button "Delete Proxies"
		-button "Cancel"
		-defaultButton "Cancel"
		-dismissString "Cancel"
		-cancelButton "Cancel"`;
		//-icon "critical"`;
		
	if ($confirmDeleteProxies == "Delete Proxies")
	{
		select -hi RRM_MAIN;
		$rigHierarchy = `ls -sl`;
		lockNode -lock off $rigHierarchy;
		delete RRM_MAIN;
		
		if (`objExists RRM_ProxiesLayer`)
		{
			delete RRM_ProxiesLayer;
		}
	}
}


//STANDARD JOINT SELECTION
global proc RRM_SelectStandardJoints(string $modName)
{
	select ($modName + "_*Jnt");
	if (`objExists ($modName + "_ROOTSHJnt")`)
	{
		select -d ($modName + "_*SHJnt");
	}
	$allStandardJoints = `ls -sl`;
	string $skinningJoints[];
	for ($each in $allStandardJoints)
	{
		$drawStyle = `getAttr ($each + ".drawStyle")`;
		$visibility = `getAttr ($each + ".visibility")`;

		if ($drawStyle == 0 && $visibility == 1)
		{
			$skinningJoints = `ls $skinningJoints $each`;
		}
	}
	select $skinningJoints;
}

//SINGLE HIERARCHY JOINT SELECTION
global proc RRM_SelectSingleHierarchyJoints(string $modName)
{
	select ($modName + "_*SHJnt");
}


///SELECT JOINTS
global proc RRM_LoadRig()
{
	$selection = `ls -sl`;
	$selectionSize = `size $selection`;
	if ($selectionSize > 0)
	{
		if (`objExists ($selection[0] + ".modRigConnection")`)
		{
			$rigName = `getAttr ($selection[0] + ".modRigConnection")`;
			textFieldButtonGrp -e -tx $rigName RRM_LoadRigTextFieldButtonGrp;
		}
		else
		{warning "Selected Object is not a Rapid Rig Modular Control";}
	}
	else
	{warning "Nothing Selected. Please Select a Rapid Rig Modular Control";}
}

global proc RRM_SelectJoints(string $modName)
{
	if (`objExists ($modName + "_ROOTSHJnt")`)
	{
		string $returnVal_Skin = `confirmDialog
		-title "Select Skinning Joints"
		-message "Which joints do you wish to select?"
		-button "Standard"
		-button "Single Hierarchy"
		-button "Cancel"
		-defaultButton "Cancel"
		-cancelButton "Cancel"`;
	
		if ($returnVal_Skin == "Standard")
		{
			RRM_SelectStandardJoints($modName);
			print "STANDARD JOINTS SELECTED! NOW SELECT THE GEOMETRY YOU WANT TO ATTACH TO THE RIGrp.\n";
		}
	
		if ($returnVal_Skin == "Single Hierarchy")
		{
			RRM_SelectSingleHierarchyJoints($modName);
			print "SINGLE HIERARCHY JOINTS SELECTED! NOW SELECT THE GEOMETRY YOU WANT TO ATTACH TO THE RIGrp.\n";
		}
	}
	else if (`objExists ($modName + "_ROOTJnt")`)
	{
		RRM_SelectStandardJoints($modName);
		print "SUCCESS! NOW SELECT THE GEOMETRY YOU WANT TO ATTACH TO THE RIGrp.\n";		
	}
	else
	{
		error "NO JOINTS HAVE BEEN CREATED YET!\n";
	}
}

global proc RRM_CreateCharacterSet(int $subCharSet)
{
	$selection = `ls -sl`;
	$selectionSize = `size $selection`;
	if ($selectionSize == 1)
	{
		//CHECK IF MAINC IS SELECTED
		if (`objExists ($selection[0] + ".isMain")`)
		{
			//CREATE CHARACTER SET
			$rigName = `getAttr ($selection[0] + ".modRigName")`;
			if (!`objExists ($rigName + "_CharSet")`)
			{
				character -em -name ($rigName + "_CharSet") -excludeVisibility;
				if ($subCharSet == 0)
				{
					$curveHierarchy = `listRelatives -ad -type "nurbsCurve" $selection[0]`;
					$hierarchy = `listRelatives -p $curveHierarchy`;
					for ($each in $hierarchy)
					{
						if (`objExists ($each + ".modControlName")` && !`objExists ($each + ".nonControl")`)
						{
							character -add ($rigName + "_CharSet") $each;
							print ("Adding \"" + $each + "\" to " + ($rigName + "_CharSet") + ".\n");
						}
					}
				}
				else
				{
					//CREATE SUB CHARACTER SETS
					select -hi $selection[0];
					$hierarchy = `ls -sl -type "transform"`;
					$hierarchy = `listRelatives -ad -type "transform" $selection[0]`;
					
					//FIND MODULE TOP GROUPS
					$children = `listRelatives -c $selection[0]`;
					string $modules[];
					for ($eachChild in $children)
					{
						if (`objExists ($eachChild + ".topNode")`)
						{
							$modules = `ls $modules $eachChild`;
						}
					}					
					
					//print $modules;
					for ($each in $modules)
					{
						int $i;
						character -em -name ($each + "_CharSet") -excludeVisibility;
						character -add ($rigName + "_CharSet") ($each + "_CharSet");
						
						$curveHierarchy = `listRelatives -ad -type "nurbsCurve" $selection[0]`;
						$hierarchy = `listRelatives -p $curveHierarchy`;
						for ($eachControl in $hierarchy)
						{
							if (`objExists ($eachControl + ".modControlName")` && !`objExists ($eachControl + ".nonControl")`)
							{
								$existingChar = `listConnections -d 0 -t "character" $eachControl`;
								$charSize = `size $existingChar`;
								if ($charSize == 0)
								{
									character -add ($each + "_CharSet") $eachControl;
									print ("Adding \"" + $eachControl + "\" to " + ($each + "_CharSet") + ".\n");
								}
							}
						}
					}
				}
			}
			else
			{
				warning ("A character set already exists for \"" + $rigName + "\".");
			}
		}
	}
	else if ($selectionSize > 1)
	{
		warning "Please select only the MAINC of your rig";
	}
	else
	{
		warning "You must select the MAINC of your rig";
	}
	select $selection;
}

//////////////////////////CONTROLLER RESIZING////////////////////////////////////////
global proc RRM_ControlEnableDisableMirror()
{
    $checkVal = `radioButtonGrp -q -select RRM_ControlScaleSelection`;
    if ($checkVal == 3)
    {
        checkBox -edit -en 0  RRM_ControlMirror;
    }
    else
    {
        checkBox -edit -en 1  RRM_ControlMirror;
    }
}
global proc RRM_ControlEnableDisableUniformScales()
{
    $checkVal = `checkBox -q -value RRM_ControlUniformScale`;
    if ($checkVal == 0)
    {
        checkBoxGrp -edit -en1 1 -en2 1 -en3 1 RRM_ControlScaleAxes;
    }
    else if ($checkVal == 1)
    {
        checkBoxGrp -edit -en1 0 -en2 0 -en3 0 RRM_ControlScaleAxes;
    }
}



global proc RRM_ControlScale(float $RRM_ControlScaleChange, int $selectionType, int $modScaleMirror, int $modUniformScaleAxes, int $RRM_ControlScaleAxis1, int $RRM_ControlScaleAxis2, int $RRM_ControlScaleAxis3)
{
	//GO THROUGH CURVES
	$selection = `ls -sl`;
	$selectionSize = `size $selection`;
	$controls = `ls -sl`;
	//string $controls[];
	string $tempControls[];
	string $modRigName;
	string $each;
	
	
	if ($selectionSize > 0)
	{
		for ($each in $selection)
		{
			if (`objExists ($selection[0] + ".modRigName")`)
			{
				$modRigName = `getAttr ($each + ".modRigName")`; 
				if ($selectionType == 1 && $modScaleMirror == 1)
				{
					if ($modScaleMirror == 1)
					{
						if (`objExists ($each + ".rightControl")`)
						{
							$oppControl = `getAttr ($each + ".rightControl")`;
							$oppControl = ($modRigName + $oppControl);
							$controls = `ls $controls $oppControl`;
						}
						else if (`objExists ($each + ".leftControl")`)
						{
							$oppControl = `getAttr ($each + ".leftControl")`;
							$oppControl = ($modRigName + $oppControl);
							$controls = `ls $controls $oppControl`;
						}
					}
				}
				else if ($selectionType == 2)
				{
					for ($each in $selection)
					{
						if (`objExists ($each + ".modRigName")`)
						{
							$modRigName = `getAttr ($each + ".modRigName")`; 
							//GET BRANCHES
							$coreName = `getAttr ($each + ".modCoreName")`;
							$crntBranch = ($modRigName + $coreName + "Grp");
							$controls = `ls $controls $crntBranch`;
							//GET MIRRORED BRANCHES
							if ($modScaleMirror == 1)
							{
								if (`objExists ($each + ".rightControl")`)
								{
									$oppControl = `getAttr ($each + ".rightControl")`;
									$oppCoreName = `getAttr ($modRigName + $oppControl + ".modCoreName")`;
									$oppBranch = ($modRigName + $oppCoreName + "Grp");
									$controls = `ls $controls $oppBranch`;
								}
								else if (`objExists ($each + ".leftControl")`)
								{
									$oppControl = `getAttr ($each + ".leftControl")`;
									$oppCoreName = `getAttr ($modRigName + $oppControl + ".modCoreName")`;
									$oppBranch = ($modRigName + $oppCoreName + "Grp");
									$controls = `ls $controls $oppBranch`;
								}
							}
						}
					}
				}
				else if ($selectionType == 3)
				{
					for ($each in $selection)
					{
						if (`objExists ($each + ".modRigName")`)
						{
							$modRigName = `getAttr ($each + ".modRigName")`; 
							//GET RIGrp NAMES
							$controls = `ls $controls $modRigName`;
						}
					}
				}
			}
			else
				{warning ($each + " IS NOT A VALID CONTROL. SKIPPING.");}
		}
	}
	else
		{warning "NOTHING SELECTED. PLEASE SELECT A VALID RRM CONTROL";}

				
	if ($selectionType == 2||$selectionType == 3)
	{
		select -hi $controls;
		$controlsHierarchy = `ls -sl -type "nurbsCurve"`;
		select $controlsHierarchy;
		pickWalk -d up;
		$controls = `ls -sl`;
		for ($each in $controls)
		{
			if (!`objExists ($each + ".nonControl")`)
			{
				$tempControls = `ls $tempControls $each`;
			}
		}
		$controls = `ls $tempControls`;
	}
				
	for ($each in $controls)
	{
		//CHECK NODE TYPE
		if (`objExists ($each + ".modRigName")`)
		{
			//SCALE
			float $controlScaleX = 1;
			float $controlScaleY = 1;
			float $controlScaleZ = 1;
			if ($modUniformScaleAxes == 1)
			{
				$controlScaleX = $RRM_ControlScaleChange;
				$controlScaleY = $RRM_ControlScaleChange;
				$controlScaleZ = $RRM_ControlScaleChange;
			}
			else
			{
				if ($RRM_ControlScaleAxis1 == 1)
				{
					$controlScaleX = $RRM_ControlScaleChange;
				}
				if ($RRM_ControlScaleAxis2 == 1)
				{
					$controlScaleY = $RRM_ControlScaleChange;
				}
				if ($RRM_ControlScaleAxis3 == 1)
				{
					$controlScaleZ = $RRM_ControlScaleChange;
				}
			}
			//GET SHAPES
			$worldSpace = `xform -q -ws -rp $each`;
			$curveShapes = `listRelatives -shapes $each`;
			string $eachShape;
			for ($eachShape in $curveShapes)
			{
				$cvs = `ls ($eachShape + ".cv[*]")`;
				if (!`objExists ($each + ".kneeLock")`)
				{
					scale -r -p $worldSpace[0] $worldSpace[1] $worldSpace[2] $controlScaleX $controlScaleY $controlScaleZ $cvs;
				}
				else
				{
					scale -r -p $worldSpace[0] 0 $worldSpace[2] $controlScaleX $controlScaleY $controlScaleZ $cvs;
				}						
			}
			//UPDATE SIZE ATTRIBUTE
			setAttr -l false ($each + ".controlSizeX");
			setAttr -l false ($each + ".controlSizeY");
			setAttr -l false ($each + ".controlSizeZ");
			float $valX = `getAttr ($each + ".controlSizeX")`;
			float $valY = `getAttr ($each + ".controlSizeY")`;
			float $valZ = `getAttr ($each + ".controlSizeZ")`;
			setAttr ($each + ".controlSizeX") ($valX * $controlScaleX);
			setAttr ($each + ".controlSizeY") ($valY * $controlScaleY);
			setAttr ($each + ".controlSizeZ") ($valZ * $controlScaleZ);
			setAttr -l true ($each + ".controlSizeX");
			setAttr -l true ($each + ".controlSizeY");
			setAttr -l true ($each + ".controlSizeZ");
		}
	}
	select $selection;
}


//////////////////////////SAVE CONTROL SHAPES////////////////////////////////////////
global proc RRM_WriteControlShapes()
{
	$initialSelection = `ls -sl`;
	$controls = `ls -sl -type "transform"`;
	$controlsSize = `size $controls`;
	if ($controlsSize > 0)
	{
		//GET ALL CONTROLS
		if (`objExists ($controls[0] + ".modRigName")`)
		{
			string $mayaFolder;
		
			fileBrowserDialog -mode 1
			-fileCommand ( "RRM_SaveControlShapes \"" + $mayaFolder + "\"" )
			-actionName "Save";
		}
		else
		{
			string $returnVal_Generate = `confirmDialog
			-title "No RRM Control Selected"
			-message "You must first select a control from your modular rig that you wish to save the transforms from.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
		-title "Nothing Selected"
		-message "You must first select a control from your modular rig that you wish to load the transforms to.\n"
		-button "OK"
		-defaultButton "OK"
		-cancelButton "OK"
		-icon "critical"`;
	}
	select $initialSelection;
}

global proc RRM_SaveControlShapes(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;

	$selection = `ls -sl`;
	$modRigName = `getAttr ($selection[0] + ".modRigName")`;
	select -hi ($modRigName + "_MAINCtrl");
	
	$controls = `ls -sl -type "transform"`;
	for ($each in $controls)
	{
		if (`objExists ($each + ".controlSizeX")` && `objExists ($each + ".modRigName")`)
		{
			//GET NAME OF CONTROL WITHOUT RIGrp NAME
			$shapes = `listRelatives -shapes $each`;
			
			for ($eachShape in $shapes)
			{
				if (`objExists ($eachShape + ".cv[0]")`)
				{
					fprint $fileID ("if (`objExists " + $eachShape + "`) {");
					int $numSpans = `getAttr ($eachShape + ".spans")`;
					int $degree   = `getAttr ($eachShape + ".degree")`;
					int $form     = `getAttr ($eachShape + ".form")`;
				
					int $numCVs   = $numSpans + $degree;
				
					// Adjust for periodic curve:
					if ( $form == 2 ) $numCVs -= $degree;
					
					int $i = 0;
					while ($i <= $numCVs)
					{
						$pos = `xform -q -os -t ($eachShape + ".cv[" + $i + "]")`;
						fprint $fileID ("move -os " + $pos[0] + " " + $pos[1] + " " + $pos[2] + " " + ($eachShape + ".cv[" + $i + "]; "));
						$i++;
					}
					$overrideColor = `getAttr ($eachShape + ".overrideColor")`;
					fprint $fileID ("setAttr " + $eachShape + ".overrideColor " + $overrideColor + "; ");
					fprint $fileID ("} else {warning (\"" + $eachShape + " does not exist. Skipping\");}\n");
				}
			}
		}
	}
	fclose $fileID;
	
	print ("\nFILE SUCCESSFULLY SAVED TO: "+ $result + "\n");
}

global proc RRM_ReadControlShapes()
{
 	string $mayaFolder2;
	fileBrowserDialog -mode 0
	-fileCommand ( "RRM_LoadControlShapes \"" + $mayaFolder2 + "\"" )
	-actionName "Load";
}

global proc RRM_LoadControlShapes(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING SHAPES FROM "+$result2+"\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}


//////////////////////////OVERRIDE COLOR////////////////////////////////////////

global proc RRM_ControlOverrideColor(int $colorVal)
{
	$selection = `ls -sl -type "transform"`;
	for ($each in $selection)
	{
		if (`objExists ($each + ".modRigName")`)
		{
			$shapes = `listRelatives -fullPath -shapes $each`;
			for ($eachShape in $shapes)
			{
				setAttr ($eachShape + ".overrideColor") $colorVal;
			}
		}
	}
	select $selection;
}

//DELETE RIG
global proc RRM_DeleteRig(string $rigName, int $keep)
{
	if ($keep == 1)
	{
		parent -w ($rigName + "_SHJntGrp");
		select -hi ($rigName + "_SHJntGrp");
		$SHJoints = `ls -sl -type "joint"`;
		string $each;
		for ($each in $SHJoints)
		{
			delete -constraints $each;
		}
	}
	
	select -cl;
	select -hi $rigName;
	$dagNodes = `ls -sl`;
	select -d $dagNodes;
	$nonDagNodes = `ls -sl`;

		
	//DELETE NODES
	delete $rigName;
	for ($each in $nonDagNodes)
	{
		if (`objExists $each`)
		{
			delete $each;
		}
	}

	//EXTRA UTILITY NODES
	$MD_Nodes = `ls -type "multiplyDivide" ($rigName + "_*")`;
	$Blend_Nodes = `ls -type "blendColors" ($rigName + "_*")`;
	$Condition_Nodes = `ls -type "condition" ($rigName + "_*")`;
	$Additive_Nodes = `ls -sl -type "plusMinusAverage" ($rigName + "_*")`;
	
	$Util_Nodes = `ls $MD_Nodes $Blend_Nodes $Condition_Nodes $Additive_Nodes`;
	//int $i = 0;
	//while ($i < 30)
	//{
	//	for ($each in $Util_Nodes)
	//	{
	//		$connections = `listConnections -s off $each`;
	//		$numConnections = `size $connections`;
	//		if ($numConnections <= 1)
	//		{
	//			select $Util_Nodes;
	//			select -d $each;
	//			$Util_Nodes = `ls -sl`;
	//			delete $each;
	//			$Util_NodesSize = `size $Util_Nodes`;
	//			if ($Util_NodesSize == 0)
	//			{
	//				$i = 30;
	//			}
	//		}
	//	}
	//	$i++;
	//}
	delete $Util_Nodes;
	
	//LAYERS
	if (`objExists ($rigName + "_SHJointsLayer")`)
	{
		delete ($rigName + "_SHJointsLayer");
	}
	if (`objExists ($rigName + "_GeoLayer")`)
	{
		delete ($rigName + "_GeoLayer");
	}
	if (`objExists ($rigName + "_ControlsLayer")`)
	{
		delete ($rigName + "_ControlsLayer");
	}
	if (`objExists ($rigName + "_JointsLayer")`)
	{
		delete ($rigName + "_JointsLayer");
	}
	
	//MATERIALS
	if (`objExists ($rigName + "_geoColor01")`)
	{
		delete ($rigName + "_geoColor01");
	}
	if (`objExists ($rigName + "_geoColor02")`)
	{
		delete ($rigName + "_geoColor02");
	}
	if (`objExists ($rigName + "_EyeWhites")`)
	{
		delete ($rigName + "_EyeWhites");
	}
	if (`objExists ($rigName + "_Pupils")`)
	{
		delete ($rigName + "_Pupils");
	}
}


global proc RRM_DeleteRigUI()
{
	$selection = `ls -sl`;
	$selectSize = `size $selection`;
	
	if ($selectSize == 1)
	{
		if (`objExists ($selection[0] + ".modRigName")`)
		{
			$modRigName = `getAttr ($selection[0] + ".modRigName")`;
			
			if (!`objExists ($modRigName + "_ROOTSHJnt")`)
			{
				string $returnVal_DeleteRig = `confirmDialog
				-title ("Are you sure you want to delete \"" + ($modRigName) + "\" rig?")
				-message ("This will delete the entire rig and anything you may have added to the \"" + ($modRigName) + "\" hierarchy. You may not be able to undo.")
				-button "Proceed"
				-button "Cancel"
				-defaultButton "Cancel"
				-cancelButton "Cancel"`;
				
				if ($returnVal_DeleteRig == "Proceed") 
				{
					print ("DELETING \"" + ($modRigName) + "\"...\n");
					RRM_DeleteRig($modRigName, 0);
					print ("\"" + ($modRigName) + "\" DELETED\n");
				}
			}
			else
			{
				string $returnVal_DeleteRig = `confirmDialog
				-title ("Are you sure you want to delete \"" + ($modRigName) + "\" rig?")
				-message ("This will delete the entire rig and anything you may have added to the \"" + ($modRigName) + "\" hierarchy. You may not be able to undo.")
				-button "Proceed"
				-button "Proceed, Keep SH Joints"
				-button "Cancel"
				-defaultButton "Cancel"
				-cancelButton "Cancel"`;
				
				if ($returnVal_DeleteRig == "Proceed") 
				{
					print ("DELETING \"" + ($modRigName) + "\"...\n");
					RRM_DeleteRig($modRigName, 0);
					print ("\"" + ($modRigName) + "\" DELETED\n");
				}
				if ($returnVal_DeleteRig == "Proceed, Keep SH Joints") 
				{
					print ("DELETING \"" + ($modRigName) + "\"...\n");
					RRM_DeleteRig($modRigName, 1);
					print ("\"" + ($modRigName) + "\" DELETED. SINGLE HIERARCHY JOINTS PRESERVED\n");
				}
			}				
		}
		else
		{
			confirmDialog
			-title "Warning: Select \"MAINC\""
			-message "You need to select a control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
		}
	}
	else if ($selectSize == 0)
	{
			confirmDialog
			-title "Warning: Nothing Selected"
			-message "You need to select a control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
	else
	{
			confirmDialog
			-title "Warning: More Than One Object Selected"
			-message "Please select only one control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
}


//////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_SH_RenameHead()
{
	$headJoint = `ls -sl`;
	$headJointCheck = `nodeType $headJoint[0]`;
	
	if ($headJointCheck == "joint")
	{
		rename $headJoint[0] "Head";
	}
	else
	{
		warning "Selected object is not a joint";
	}
	select $headJoint;
}

global proc RRM_SH_RenameHips()
{
	$ROOTJoint = `ls -sl`;
	$ROOTJointCheck = `nodeType $ROOTJoint[0]`;
	
	if ($ROOTJointCheck == "joint")
	{
		rename $ROOTJoint[0] "Hips";
		select "Hips";
	}
	else
	{
		warning "Selected object is not a joint";
		select $ROOTJoint;
	}
}

global proc RRM_SH_RenameSpline()
{
	$splineJoint = `ls -sl`;
	$splineJointCheck = `nodeType $splineJoint[0]`;
	int $hierarchySize;
	
	if ($splineJointCheck == "joint")
	{
		if (`objExists ($splineJoint[0] + ".splineStart")`)
		{
			select -hi $splineJoint;
			$splineHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $splineHierarchy`;
			int $splineEnd;
			int $i;
			string $splineJoints[];// = $splineJoint[0];
			string $iString;
			
			while ($i < $hierarchySize)
			{
				if (!`objExists ($splineHierarchy[$i] + ".splineEnd")`)
				{
					$iString = $i;
					if ($i == 0)
					{
						rename $splineHierarchy[$i] ("Spine");
					}
					else
					{
						rename $splineHierarchy[$i] ("Spine" + $iString);
					}
				}
				else
				{
					$iString = $i;
					rename $splineHierarchy[$i] ("Spine" + $iString);
					$i=100;
				}
				$i++;
			}
			select "Spine";
		}
		else
		{
			warning "Selected object is not the first joint of a spline";
			select $splineJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $splineJoint;
	}
}

global proc RRM_SH_RenameNeck()
{
	$splineJoint = `ls -sl`;
	$splineJointCheck = `nodeType $splineJoint[0]`;
	int $hierarchySize;
	
	if ($splineJointCheck == "joint")
	{
		if (`objExists ($splineJoint[0] + ".splineStart")`)
		{
			select -hi $splineJoint;
			$splineHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $splineHierarchy`;
			int $splineEnd;
			int $i;
			string $splineJoints[];// = $splineJoint[0];
			string $iString;
			
			while ($i < $hierarchySize)
			{
				if (!`objExists ($splineHierarchy[$i] + ".splineEnd")`)
				{
					$iString = $i;
					if ($i == 0)
					{
						rename $splineHierarchy[$i] ("Neck");
					}
					else
					{
						rename $splineHierarchy[$i] ("Neck" + $iString);
					}
				}
				else
				{
					$iString = $i;
					rename $splineHierarchy[$i] ("Neck" + $iString);
					$i=100;
				}
				$i++;
			}
			select "Neck";
		}
		else
		{
			warning "Selected object is not the first joint of a spline";
			select $splineJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $splineJoint;
	}
}

global proc RRM_SH_RenameLeftArm()
{
	$clavicleJoint = `ls -sl`;
	$clavicleJointCheck = `nodeType $clavicleJoint[0]`;
	int $hierarchySize;
	
	if ($clavicleJointCheck == "joint")
	{
		if (`objExists ($clavicleJoint[0] + ".shoulder")`)
		{
			select -hi $clavicleJoint;
			$armHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $armHierarchy`;
			int $i = 1;
			
			rename $clavicleJoint[0] "LeftShoulder";
			while ($i < $hierarchySize)
			{
				if (`objExists ($armHierarchy[$i])`)
					{
					if (`objExists ($armHierarchy[$i] + ".arm")`)
					{
						rename $armHierarchy[$i] "LeftArm";
					}
					if (`objExists ($armHierarchy[$i] + ".forearm")`)
					{
						rename $armHierarchy[$i] "LeftForeArm";
					}
					if (`objExists ($armHierarchy[$i] + ".hand")`)
					{
						rename $armHierarchy[$i] "LeftHand";
					}
				}
				$i++;
			}
			select "LeftShoulder";
		}
		else
		{
			warning "Selected joint is not the first joint of a arm";
			select $clavicleJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $clavicleJoint;
	}
}

global proc RRM_SH_RenameRightArm()
{
	$clavicleJoint = `ls -sl`;
	$clavicleJointCheck = `nodeType $clavicleJoint[0]`;
	int $hierarchySize;
	
	if ($clavicleJointCheck == "joint")
	{
		if (`objExists ($clavicleJoint[0] + ".shoulder")`)
		{
			select -hi $clavicleJoint;
			$armHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $armHierarchy`;
			int $i = 1;
			
			rename $clavicleJoint[0] "RightShoulder";
			while ($i < $hierarchySize)
			{
				if (`objExists ($armHierarchy[$i])`)
					{
					if (`objExists ($armHierarchy[$i] + ".arm")`)
					{
						rename $armHierarchy[$i] "RightArm";
					}
					if (`objExists ($armHierarchy[$i] + ".forearm")`)
					{
						rename $armHierarchy[$i] "RightForeArm";
					}
					if (`objExists ($armHierarchy[$i] + ".hand")`)
					{
						rename $armHierarchy[$i] "RightHand";
					}
				}
				$i++;
			}
			select "RightShoulder";
		}
		else
		{
			warning "Selected joint is not the first joint of a arm";
			select $clavicleJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $clavicleJoint;
	}
}

global proc RRM_SH_RenameLeftLeg()
{
	$hipJoint = `ls -sl`;
	$hipJointCheck = `nodeType $hipJoint[0]`;
	int $hierarchySize;
	
	if ($hipJointCheck == "joint")
	{
		if (`objExists ($hipJoint[0] + ".upLeg")`)
		{
			select -hi $hipJoint;
			$legHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $legHierarchy`;
			int $i = 1;
			string $legJoints[];
			
			rename $hipJoint[0] "LeftUpLeg";
			while ($i <= $hierarchySize)
			{
				if (`objExists ($legHierarchy[$i])`)
				{
					if (`objExists ($legHierarchy[$i] + ".leg")`)
					{
						rename $legHierarchy[$i] "LeftLeg";
					}
					if (`objExists ($legHierarchy[$i] + ".foot")`)
					{
						rename $legHierarchy[$i] "LeftFoot";
					}
					if (`objExists ($legHierarchy[$i] + ".toeBase")`)
					{
						rename $legHierarchy[$i] "LeftToeBase";
					}
				}
				$i++;
			}
			select "LeftUpLeg";
		}
		else
		{
			warning "Selected joint is not the first joint of a leg";
			select $hipJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $hipJoint;
	}
}

global proc RRM_SH_RenameRightLeg()
{
	$hipJoint = `ls -sl`;
	$hipJointCheck = `nodeType $hipJoint[0]`;
	int $hierarchySize;
	
	if ($hipJointCheck == "joint")
	{
		if (`objExists ($hipJoint[0] + ".upLeg")`)
		{
			select -hi $hipJoint;
			$legHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $legHierarchy`;
			int $i = 1;
			string $legJoints[];
			
			rename $hipJoint[0] "RightUpLeg";
			while ($i <= $hierarchySize)
			{
				if (`objExists ($legHierarchy[$i])`)
				{
					if (`objExists ($legHierarchy[$i] + ".leg")`)
					{
						rename $legHierarchy[$i] "RightLeg";
					}
					if (`objExists ($legHierarchy[$i] + ".foot")`)
					{
						rename $legHierarchy[$i] "RightFoot";
					}
					if (`objExists ($legHierarchy[$i] + ".toeBase")`)
					{
						rename $legHierarchy[$i] "RightToeBase";
					}
				}
				$i++;
			}
			select "RightUpLeg";
		}
		else
		{
			warning "Selected joint is not the first joint of a leg";
			select $hipJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $hipJoint;
	}
}

global proc RRM_GetVersionNumber()
{
	$selection = `ls -sl`;
	$selectSize = `size $selection`;
	
	if ($selectSize == 1)
	{
		if (`objExists ($selection[0] + ".versionNumber")`)
		{
			$rigName = `getAttr ($selection[0] + ".modRigName")`;
			$rigVersionNumber = `getAttr ($selection[0] + ".versionNumber")`;
			
			string $returnVal_DeleteRig = `confirmDialog
			-title ("The rig \"" + ($rigName) + "\" is version: " + $rigVersionNumber)
			-message ("Click the \"Go To Rapid Rig Web Page\" button to see if you have the latest version.")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"`;
		}
		else
		{
			confirmDialog
			-title "Warning: Select \"MAINC\""
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
		}
	}
	else if ($selectSize == 0)
	{
			confirmDialog
			-title "Warning: Nothing Selected"
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
	else
	{
			confirmDialog
			-title "Warning: More Than One Object Selected"
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
}

global proc RRM_GoToCreativeCrash()
{
	launch -web "http://www.creativecrash.com/maya/script/-rapid-rig-modular-procedural-auto-rig-for-maya";
}
//////////////////////////////////////////////////////////////////
////////////////////////Main Window///////////////////////////////
//////////////////////////////////////////////////////////////////

global proc RRM_CreateProxyMainGUI()
{
	string $form = `formLayout`;
	string $tabs = `tabLayout -cr false RRM_RigTab`;
	
	//TAB 1////////////////////////////////////////////////////////////////////////
	rowColumnLayout -nc 2 -cw 1 385 -cw 2 385 RRM_ProxySteps;
	//STEP 1.1: Name
		frameLayout -label "Step 1.1: Create Proxy Module Base"
			-width 375
			RRM_ProxyCreateProxyBaseFrameLayout;
			
		columnLayout RRM_ProxyCreateProxyBaseColumnLayout;
			
		rowColumnLayout -nc 2 -columnWidth 1 110 -columnWidth 2 180;
			checkBox -label "Use Template:"
			-v 0 -cc RRM_ToggleTemplate
			RRM_TemplateCheckBox;
			optionMenu -w 120
			-en 0
			RRM_TemplateType;
			menuItem -label "Bi-Ped (human)";
			menuItem -label "Quadruped";
			menuItem -label "Arachnid";
			menuItem -label "Bird";
			setParent RRM_ProxyCreateProxyBaseColumnLayout;

		columnLayout;
			button -label "Create" -w 378 -bgc 0.7 0.7 0.7
			-command "RRM_CreateProxyMainProxy(`checkBox -q -v RRM_TemplateCheckBox`)";

			setParent RRM_ProxyCreateProxyBaseColumnLayout;
		
	string $RRM_ProxyTabs = `tabLayout -cr false -h 545 RRM_ProxyTabs`;
	//STEP 1.2
	columnLayout RRM_AddModules;
		frameLayout -label "Step 1.2: Add Modules"
		RRM_AddModulesFrameLayout;
			scrollLayout
				-w 376
				-h 499
        		-horizontalScrollBarThickness 16
        		-verticalScrollBarThickness   16
        		addModScrollLayout;
        		
        columnLayout RRM_AddModulesColumnLayout;

		
	//RIBBON SPLINE
		frameLayout -label "Ribbon Spline Options (Spine, Neck)"
			-width 350
			-collapsable 1
			-bgc 0.114 0.356 0.451
			RRM_SplineOptionsFrameLayout;
			
			columnLayout RRM_SplineOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_SplineButton" -aie 1 RRM_TextFieldSplineName;
        
        setParent..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 2
			-max 100
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4
			RRM_SplineNum;

		columnLayout -cw 200 -cat "left" 0;
	    checkBox
			-label "Mirror Module"
			-value 0
			RRM_SplineMirror;
			
		button -w 325 -label "Create Spline" -bgc 0.114 0.356 0.451
		
		-command "RRM_SplinePrompts(\
		`textField -q -text RRM_TextFieldSplineName`,\
		`intSliderGrp -q -v RRM_SplineNum`,\
		`checkBox -q -v RRM_SplineMirror`);"
		RRM_SplineButton;
		
		setParent RRM_AddModulesColumnLayout;
	
	//ARM
		frameLayout -label "Arm Options"
			-width 350
			-collapsable 1
			-bgc 0 .275 .098
			RRM_ArmOptionsFrameLayout;
			
		columnLayout RRM_ArmOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_ArmButton" -aie 1 RRM_TextFieldArmName;
        
        setParent RRM_ArmOptionsColumnLayout;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_UpperArmNum;
			
		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_ForearmNum;
			
		columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "One Elbow Joint" "Two Elbow Joints"
		-sl 1 -cc RRM_ElbowNumLock RRM_ElbowJoints;

		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_ElbowNum;
			
		columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 3
		/*-label "Three Buttons"*/ -labelArray3 "Left" "Pair" "Right"
		-sl 2 RRM_ArmMirror;
    
		columnLayout -cw 350 -cat "left" 0;
		button -w 325 -label "Create Arm" -bgc 0 .275 .098
		
		-command "RRM_ArmPrompts(\
		`textField -q -text RRM_TextFieldArmName`,\
		`intSliderGrp -q -v RRM_UpperArmNum`,\
		`intSliderGrp -q -v RRM_ForearmNum`,\
		`intSliderGrp -q -v RRM_ElbowNum`,\
		`radioButtonGrp -q -select RRM_ElbowJoints`,\
		`radioButtonGrp -q -select RRM_ArmMirror`);"		
		RRM_ArmButton;
		
		setParent RRM_AddModulesColumnLayout;
		
		
	//LEG
		frameLayout -label "Leg Options"
			-width 350
			-collapsable 1
			-bgc .631 .188 .412
			RRM_LegOptionsFrameLayout;
			
			columnLayout RRM_LegOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_LegButton" -aie 1 RRM_TextFieldLegName;
        
        setParent..;


		columnLayout -cw 200 -cat "left" 5;
		$RRM_UpperLegNum = `intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_UpperLegNum`;
			
		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_LowerLegNum;
			
		columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "One Knee Joint" "Two Knee Joints"
		-sl 1 -cc RRM_KneeNumLock RRM_KneeJoints;

		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_KneeNum;
			
			columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "Single" "Pair"
		-sl 2 RRM_LegMirror;
    
		columnLayout -cw 350 -cat "left" 0;
		button -w 325 -label "Create Leg" -bgc .631 .188 .412
		
		-command "RRM_LegPrompts(\
		`textField -q -text RRM_TextFieldLegName`,\
		`intSliderGrp -q -v RRM_UpperLegNum`,\
		`intSliderGrp -q -v RRM_LowerLegNum`,\
		`intSliderGrp -q -v RRM_KneeNum`,\
		`radioButtonGrp -q -select RRM_KneeJoints`,\
		`radioButtonGrp -q -select RRM_LegMirror`);"
		RRM_LegButton;
		
		setParent RRM_AddModulesColumnLayout;

		
	//FK CHAINS
		frameLayout -label "FK Chain Options (Fingers, Toes, Tail, Tentacle, Antenna)"
			-width 350
			-collapsable 1
			-bgc .784 0 .784
			RRM_FKChainOptionsFrameLayout;
			
			columnLayout RRM_FKChainOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_FKChainButton" -aie 1 RRM_TextFieldFKChainName;
        
        setParent..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Chains"
			-field true
			-cal 1 center
			-cw 1 90
			-value 5 RRM_FkChain_Chains;
			
		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 1
			-label "Joints per Chain"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4 RRM_FkChain_JointsPerChain;
			
		columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "X Outward" "+Y" "+Z" -sl 1 RRM_FkChainDirection;
		radioButtonGrp -numberOfRadioButtons 3
		-shareCollection RRM_FkChainDirection
		-labelArray3 "X Inward" "-Y" "-Z" RRM_FkChainDirection2;
		
			
		columnLayout -cw 200 -cat "left" 5;
	    checkBox
			-label "Mirror Module"
			-value 1
			RRM_FkMirror;
    
		columnLayout -cw 350 -cat "left" 0;
		button -w 325 -label "Create FK Chain" -bgc .784 0 .784
		
		-command "RRM_FKChainPrompts(\
		`textField -q -text RRM_TextFieldFKChainName`,\
		`intSliderGrp -q -v RRM_FkChain_Chains`,\
		`intSliderGrp -q -v RRM_FkChain_JointsPerChain`,\
		`checkBox -q -v RRM_FkMirror`,\
		`radioButtonGrp -q -select RRM_FkChainDirection`,\
		`radioButtonGrp -q -select RRM_FkChainDirection2`);"
		RRM_FKChainButton;
		
		setParent RRM_AddModulesColumnLayout;

	
	//HEAD
		frameLayout -label "Head"
			-width 350
			-collapsable 1
			-bgc .608 0 .157
			RRM_HeadOptionsFrameLayout;
			
		columnLayout RRM_HeadOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_HeadButton" -aie 1 RRM_TextFieldHeadName;
        
        setParent..;
			
		columnLayout -cw 200 -cat "left" 10;
	    checkBox
			-label "Jaw"
			-value 1
			RRM_Jaw;
			
		columnLayout -cw 200 -cat "left" -1;
	    checkBox
			-label "Mirror Module"
			-value 0
			RRM_HeadMirror;
    
		columnLayout -cw 350 -cat "left" 0;
		button -w 325 -label "Create Head" -bgc .608 0 .157
		
		-command "RRM_HeadPrompts(\
		`textField -q -text RRM_TextFieldHeadName`,\
		`checkBox -q -v RRM_Jaw`,\
		`checkBox -q -v RRM_HeadMirror`);"
		RRM_HeadButton;
		
		setParent RRM_AddModulesColumnLayout;
		
	//LOOK-AT
		frameLayout -label "Look-At Joints (Eyes, etc)"
			-width 350
			-collapsable 1
			-bgc .435 .188 .631
			RRM_LookAtOptionsFrameLayout;
			
		columnLayout RRM_LookAtOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_LookAtButton" -aie 1 textFieldLookAtModName;
        
        setParent RRM_LookAtOptionsColumnLayout;
                

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 1 lookAtModJoints;
			
		columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "X Outward" "+Y" "+Z" -sl 3 RRM_LookAtDirection;
		radioButtonGrp -numberOfRadioButtons 3
		-shareCollection RRM_LookAtDirection
		-labelArray3 "X Inward" "-Y" "-Z" RRM_LookAtDirection2;
		
		columnLayout -cw 200 -cat "left" 5;
	    checkBox
			-label "Mirror Module"
			-value 1
			lookAtModMirror;
    
		columnLayout -cw 350 -cat "left" 0;
		button -w 325 -label "Create Look-At" -bgc .435 .188 .631
		
		-command "RRM_LookAtPrompts(\
		`textField -q -text textFieldLookAtModName`,\
		`intSliderGrp -q -v lookAtModJoints`,\
		`checkBox -q -v lookAtModMirror`,\
		`radioButtonGrp -q -select RRM_LookAtDirection`,\
		`radioButtonGrp -q -select RRM_LookAtDirection2`);"
		RRM_LookAtButton;
		
		setParent RRM_AddModulesColumnLayout;

	//AUXILIARY
		frameLayout -label "Auxiliary Joints (Single Joint)"
			-width 350
			-collapsable 1
			-bgc .639 .416 .169
			RRM_AuxiliaryOptionsFrameLayout;
			
		columnLayout RRM_AuxiliaryOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_AuxiliaryButton" -aie 1 textFieldAuxiliaryModName;
        
		setParent RRM_AuxiliaryOptionsColumnLayout;

		columnLayout -cw 200 -cat "left" 5;
	    checkBox
			-label "Mirror Module"
			-value 1
			AuxiliaryModMirror;
			
		columnLayout -cw 350 -cat "left" 0;
		button -w 325 -label "Create Auxiliary" -bgc .639 .416 .169

		-command "RRM_AuxiliaryPrompts(\
		`textField -q -text textFieldAuxiliaryModName`,\
		`checkBox -q -v AuxiliaryModMirror`);"
		RRM_AuxiliaryButton;

		setParent RRM_AuxiliaryOptionsColumnLayout;

        setParent RRM_ProxyTabs;

	
	//STEP 1.3
	columnLayout RRM_EditModules;
		frameLayout -label "Step 1.3: Edit Modules" RRM_EditModuleFrameLayout;
			scrollLayout
				-w 376
				-h 499
        		-horizontalScrollBarThickness 16
        		-verticalScrollBarThickness   16
        		-bgc .45 .45 .45
        		RRM_EditScrollFrameLayout;
        		
        	columnLayout RRM_EditScrollColumnLayout;
		
	//EDIT SPLINE
		frameLayout -label "Edit Ribbon Splines"
			-width 350
			-collapsable 1
			-bgc 0.114 0.356 0.451
			RRM_EditSplineFrameLayout;
			
			columnLayout RRM_EditSplineColumnLayout;
	
	    columnLayout;
        textFieldButtonGrp -label " Spline Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"spline\" )" RRM_EditLoadsplineTextField;


		setParent ..;
		
		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 2
			-max 99
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4
			RRM_SplineEditNum;
			
		setParent ..;
		columnLayout;
		button -label "Apply Edits to Loaded Spline" -w 340 -bgc 0.114 0.356 0.451 -command RRM_EditSpline;

		
		setParent RRM_EditScrollColumnLayout;
	
	//EDIT ARM
		frameLayout -label "Edit Arms"
			-width 350
			-collapsable 1
			-bgc 0 .275 .098
			RRM_EditArmsFrameLayout;
			
		columnLayout RRM_EditArmsColumnLayout;
	

	    columnLayout;
        textFieldButtonGrp -label " Arm Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"arm\" )" RRM_EditLoadarmTextField;


		setParent ..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 upperArmModEditNum;
			
		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 forearmModEditNum;
			
		columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 2
		-labelArray2 "One Elbow Joint" "Two Elbow Joints"
		-sl 1 -cc RRM_ElbowEditNumLock RRM_ElbowEditJoints;

		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_ElbowEditNum;
		
		setParent ..;
		columnLayout -cw 350 -cat "left" 0;
		button -label "Apply Edits to Loaded Arm" -w 340 -bgc 0 .275 .098 -command RRM_EditArm;
		
		setParent RRM_EditScrollColumnLayout;
		
	//EDIT LEGS
		frameLayout -label "Edit Legs"
			-width 350
			-collapsable 1
			-bgc .631 .188 .412
			RRM_EditLegsFrameLayout;
			
		columnLayout RRM_EditLegsColumnLayout;
	
		columnLayout -cw 350 -cat "left" 0;
        textFieldButtonGrp -label " Leg Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"leg\" )" RRM_EditLoadlegTextField;


		setParent ..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 upperLegModEditNum;
			
		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 lowerLegModEditNum;
			
		columnLayout -cw 200 -cat "left" 0;
		radioButtonGrp -numberOfRadioButtons 2
		-labelArray2 "One Knee Joint" "Two Knee Joints"
		-sl 1 -cc RRM_KneeEditNumLock RRM_KneeEditJoints;

		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_KneeEditNum;
		
		setParent ..;
		columnLayout;
		button -label "Apply Edits to Loaded Leg" -w 340 -bgc .631 .188 .412 -command RRM_EditLeg;
		
		setParent RRM_EditScrollColumnLayout;
		
		
	//EDIT FK CHAINS
		frameLayout -label "Edit FK Chains"
			-width 350
			-collapsable 1
			-bgc .784 0 .784
			RRM_EditFKChainFrameLayout;
			
		columnLayout RRM_EditFKChainColumnLayout;
	

		columnLayout -cw 350 -cat "left" 0;
        textFieldButtonGrp -label " Fk Chain Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"fkChain\" )" RRM_EditLoadfkChainTextField;
        
        setParent..;


		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Chains"
			-field true
			-cal 1 center
			-cw 1 90
			-value 5 fkChainModEditChains;
			
		columnLayout -cw 200 -cat "left" 0;
		intSliderGrp
			-min 1
			-label "Joints per Chain"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4 fkChainModEditJointsPerChain;
			
		columnLayout -cw 350 -cat "left" 0;
		button -w 340 -label "Apply Edits to Loaded FK Chain" -bgc .784 0 .784 -command RRM_EditFkChain;
		
		setParent RRM_EditScrollColumnLayout;

	
	//EDIT HEAD
		frameLayout -label "Edit Head"
			-width 350
			-collapsable 1
			-bgc 0.529 0.162 0.199
			RRM_EditHeadFrameLayout;
	
	    columnLayout;
        textFieldButtonGrp -label " Head Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"head\" )" RRM_EditLoadheadTextField;

		button -label "Toggle Jaw" -w 340 -bgc 0.529 0.162 0.199 -command RRM_EditHead;
		
		setParent RRM_EditScrollColumnLayout;
	
		
	//EDIT LOOK-AT
		frameLayout -label "Edit Look-Ats"
			-width 350
			-collapsable 1
			-bgc .435 .188 .631
			RRM_EditLookAtFrameLayout;
	
	    columnLayout;
        textFieldButtonGrp -label " Look-At Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent(\"lookAt\" )" RRM_EditLoadlookAtTextField;

        
		intSliderGrp
			-min 1
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 1 lookAtModEditJoints;
			
		button -label "Apply Edits to Loaded Look-At" -w 340 -bgc .435 .188 .631 -command RRM_EditLookAt;

		
		setParent RRM_EditScrollColumnLayout;
		setParent..;

		
        
        tabLayout -edit -h 545 -tabLabel RRM_AddModules "Create Modules" -tabLabel RRM_EditModules "Edit Modules" $RRM_ProxyTabs;
        
        setParent RRM_ProxySteps;

    
    //STEP 2.1 CHANGE PROXY COLOURS
    columnLayout RRM_ModifyProxies;
		frameLayout -label "Step 2.1 Override Selected Proxy Branch Color" -bgc .25 .25 .25 RRM_ControlColorOverrides;
		rowColumnLayout -nc 16 -bgc .25 .25 .25 -w 384;
		button -bgc  .471 .471 .471		-label "D" -w 24 -ann "0"  -c "RRM_ProxyOverrideColor(00)";
		button -bgc  0 0 0				-label ""  -w 24 -ann "1"  -c "RRM_ProxyOverrideColor(01)";
		button -bgc  .251 .251 .251		-label ""  -w 24 -ann "2"  -c "RRM_ProxyOverrideColor(02)";
		button -bgc  .502 .502 .502		-label ""  -w 24 -ann "3"  -c "RRM_ProxyOverrideColor(03)";
		button -bgc  .608 0 .157		-label ""  -w 24 -ann "4"  -c "RRM_ProxyOverrideColor(04)";
		button -bgc  0 .016 .376		-label ""  -w 23 -ann "5"  -c "RRM_ProxyOverrideColor(05)";
		button -bgc  0 0 1				-label ""  -w 23 -ann "6"  -c "RRM_ProxyOverrideColor(06)";
		button -bgc  0 .275 .098		-label ""  -w 23 -ann "7"  -c "RRM_ProxyOverrideColor(07)";
		button -bgc  .149 0 .263		-label ""  -w 23 -ann "8"  -c "RRM_ProxyOverrideColor(08)";
		button -bgc  .784 0 .784		-label ""  -w 23 -ann "9"  -c "RRM_ProxyOverrideColor(09)";
		button -bgc  .541 .282 .2		-label ""  -w 24 -ann "10" -c "RRM_ProxyOverrideColor(10)";
		button -bgc  .247 .137 .122		-label ""  -w 24 -ann "11" -c "RRM_ProxyOverrideColor(11)";
		button -bgc  .6 .149 0			-label ""  -w 24 -ann "12" -c "RRM_ProxyOverrideColor(12)";
		button -bgc  1 0 0				-label ""  -w 24 -ann "13" -c "RRM_ProxyOverrideColor(13)";
		button -bgc  0 1 0				-label ""  -w 24 -ann "14" -c "RRM_ProxyOverrideColor(14)";
		
		button -bgc  0 .255 .6			-label ""  -w 24 -ann "15" -c "RRM_ProxyOverrideColor(15)";
		button -bgc  1 1 1				-label ""  -w 24 -ann "16" -c "RRM_ProxyOverrideColor(16)";
		button -bgc  1 1 0				-label ""  -w 24 -ann "17" -c "RRM_ProxyOverrideColor(17)";
		button -bgc  .392 .863 1		-label ""  -w 24 -ann "18" -c "RRM_ProxyOverrideColor(18)";
		button -bgc  .263 1 .639		-label ""  -w 24 -ann "23" -c "RRM_ProxyOverrideColor(23)";
		button -bgc  1 .69 .69			-label ""  -w 23 -ann "20" -c "RRM_ProxyOverrideColor(20)";
		button -bgc  .967 .675 .475		-label ""  -w 23 -ann "21" -c "RRM_ProxyOverrideColor(21)";
		button -bgc  1 1 .388			-label ""  -w 23 -ann "22" -c "RRM_ProxyOverrideColor(22)";
		button -bgc  0 .6 .329			-label ""  -w 23 -ann "23" -c "RRM_ProxyOverrideColor(23)";
		button -bgc  .631 .412 .188		-label ""  -w 23 -ann "24" -c "RRM_ProxyOverrideColor(24)";
		button -bgc  .624 .631 .188		-label ""  -w 23 -ann "25" -c "RRM_ProxyOverrideColor(25)";
		button -bgc  .408 .631 .188		-label ""  -w 23 -ann "26" -c "RRM_ProxyOverrideColor(26)";
		button -bgc  .188 .631 .365		-label ""  -w 24 -ann "27" -c "RRM_ProxyOverrideColor(27)";
		button -bgc  .188 .631 .631		-label ""  -w 24 -ann "28" -c "RRM_ProxyOverrideColor(28)";
		button -bgc  .188 .404 .631		-label ""  -w 24 -ann "29" -c "RRM_ProxyOverrideColor(29)";
		button -bgc  .435 .188 .631		-label ""  -w 24 -ann "30" -c "RRM_ProxyOverrideColor(30)";
		button -bgc  .631 .188 .412		-label ""  -w 24 -ann "31" -c "RRM_ProxyOverrideColor(31)";

		setParent RRM_ModifyProxies;
	

	//STEP 2.2 RENAME MODULE
		frameLayout -label "Step 2.2: Rename Selected Module"
			-width 384
			-bgc -.35 .35 .35
			RRM_RenameModFrameLayout;
	
	    columnLayout 
	    -bgc .35 .35 .35
	    RRM_RenameModColumnLayout;
    
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 120 -columnWidth 2 258;
    
	    text -label "Module's New Name: ";
		textField -enterCommand "setFocus RRM_RenameButton" -aie 1 textFieldRenameName;
		
	    setParent RRM_RenameModColumnLayout;
	    
	    columnLayout;
	    				
		button -label "Rename Selected Module" -w 368 -command "RRM_ClonePrompts(\
		`textField -q -text textFieldRenameName`,\
		0, 0);"
		RRM_RenameButton;
		
		setParent RRM_ModifyProxies;
  
		
	//STEP 2.3 CLONE MODULE
		frameLayout -label "Step 2.3: Clone Selected Module"
			-width 384
			-bgc .25 .25 .25
			RRM_CloneModFrameLayout;
	
	    columnLayout
	    -bgc .25 .25 .25 RRM_CloneModColumnLayout;

	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 132 -columnWidth 2 246;

	    text -label "Cloned Module's Name: ";
		textField -enterCommand "setFocus RRM_CloneButton" -aie 1 textFieldCloneName;
		
	    setParent RRM_CloneModColumnLayout;
	    
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 128 -columnWidth 2 248;
	    	
	    checkBox
			-label "Include branches"
			-value 1
			RRM_CloneBranchCheckBox;
			
		button -label "Clone Selected Module" -w 185 -command "RRM_ClonePrompts(\
		`textField -q -text textFieldCloneName`,\
		`checkBox -q -v RRM_CloneBranchCheckBox`,1);"
		RRM_CloneButton;
		
		setParent RRM_ModifyProxies;
      

		//STEP 2.4 RE-TARGET
		frameLayout -label "Step 2.4: Attach Module to New Node"
			-width 384
			-bgc .35 .35 .35
			RRM_RetargetModFrameLayout;
		
		columnLayout -bgc .35 .35 .35;
        textFieldButtonGrp -label " New Attach Module:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 114 220 80 -bc RRM_LoadNewModuleAttachNode RRM_LoadNewModuleAttachNodeTextField;
        button -label "Attach Selected Modules to New Module" -w 376
        -command "RRM_AttachToNewModule (`textFieldButtonGrp -q -text RRM_LoadNewModuleAttachNodeTextField`)";
      
			setParent RRM_ModifyProxies;
			
		//STEP 2.5 DELETE MODULE
		frameLayout -label "Step 2.5: Delete Module"
			-width 384
			-bgc .25 .25 .25
			RRM_DeleteModFrameLayout;
	
		//DELETE
		columnLayout -bgc .25 .25 .25;
		button -label "Delete Selected Module and Branches" -w 379 -bgc .5 0.0 0.0 -command RRM_DeleteBranchPrompts;
		setParent RRM_ModifyProxies;
		
		//STEP 2.6 POSE
		frameLayout -label "Step 2.6: Pose Proxy Rig (Does not affect ROOT or Parent nodes)"
			-width 384
			-bgc .35 .35 .35
			RRM_PoseProxyFrameLayout;
	
		columnLayout -cw 200 -cat "left" 0 -bgc .35 .35 .35;
		radioButtonGrp -numberOfRadioButtons 3
		/*-label "Three Buttons"*/ -labelArray3 "Selected" "Branch" "All"
		-sl 1 RRM_ResetSelection;
		
		rowColumnLayout -nc 3 -cw 1 126 -cw 2 127 -cw 3 126;
			button -label "Right to Left"
			-command "RRM_RightToLeftProxies (`radioButtonGrp -q -select RRM_ResetSelection`)"
			RRM_RightToLeftProxies;
			button -label "Reset"
			-command "RRM_ResetProxies (`radioButtonGrp -q -select RRM_ResetSelection`)"
			RRM_ResetProxies;		
			button -label "Left to Right"
			-command "RRM_LeftToRightProxies (`radioButtonGrp -q -select RRM_ResetSelection`)"
			RRM_LeftToRightProxies;
	
			setParent RRM_ModifyProxies;

			
	//STEP 2.7 PINNING
		frameLayout -label "Step 2.7: Pinning (pinned modules are not influenced by parent)"
			-width 384
			-bgc .25 .25 .25
			RRM_PinProxyFrameLayout;
				
			rowColumnLayout -nc 2 -cw 1 189 -cw 2 189 -bgc .25 .25 .25;
			button -label "Pin Module" -bgc 0.780 0.330 0.330
			-command "RRM_PinProxies(1, 0)";
			button -label "Unpin Module" -bgc 0.330 0.420 0.780
			-command "RRM_PinProxies(0, 1)";		
	
			setParent RRM_ModifyProxies;
	
	
	//STEP 2.8 TRANSFER
		frameLayout -label "Step 2.8: Transfer Transforms  *Select Target Then Destination*"
			-width 384
			-bgc .35 .35 .35
			RRM_TransferProxyTransformsFrameLayout;
			
		columnLayout 
		-bgc .35 .35 .35 RRM_TransferProxyTransformsColumnLayout;
	
		rowColumnLayout -nc 2 -cw 1 220 -cw 2 150
		-bgc .35 .35 .35;
			$selectedOrBranch = `radioButtonGrp -numberOfRadioButtons 2
			-labelArray2 "Selected" "Branch"
			-sl 1
			-cc RRM_ToggleTransferParent
			RRM_TransferSelectionButton`;
			
			$transferParentCheck = `checkBox -v 0 -label "Include Parent" -ed 0 RRM_TransferParent`;
		
			setParent RRM_TransferProxyTransformsColumnLayout;
		columnLayout ;//-cw 370 -cat "left" 5;
			button -label "Transfer"
			-width 378
			-bgc .35 .35 .35
			-command "RRM_TransferModTransforms"
			RRM_TransferModTransformsButton;

		setParent RRM_ModifyProxies;

			
		//STEP 2.9 SAVE LOAD
		frameLayout -label "Step 2.9: Save/Load Proxy Transforms"
			-width 384
			-bgc .25 .25 .25
			RRM_SaveLoadProxyTransformsFrameLayout;
				
			rowColumnLayout -nc 2 -cw 1 189 -cw 2 189
			-bgc .25 .25 .25;
			button -label "Save Transforms"       
			-command "RRM_WritePathProxyTransforms";
			button -label "Load Transforms"
			-command "RRM_ReadPathProxyTransform";		
	
			setParent RRM_ModifyProxies;
			
			
		//STEP 2.10 SAVE LOAD
		frameLayout -label "Step 2.10: Save/Load Proxy Setup"
			-width 384
			-bgc .35 .35 .35
			RRM_SaveLoadProxySetupFrameLayout;
				
			rowColumnLayout -nc 2 -cw 1 189 -cw 2 189
			-bgc .35 .35 .35;
			button -label "Save Setup"       
			-command "RRM_WritePathProxySetup";
			button -label "Load Setup"
			-command "RRM_ReadPathProxySetup";		
	
			
			setParent RRM_RigTab;
	
	
	//TAB 2////////////////////////////////////////////////////////////////////////
	rowColumnLayout -nc 2 -cw 1 355 -cw 2 415 RRM_RigSteps;
	//STEP 3.1
		frameLayout -label "Step 3.1: Character Name"
			-width 355 RRM_GenerateRigFrameLayout;
			
		columnLayout RRM_GenerateRigColumnLayout;
		
		columnLayout -cw 355 -cat "left" 1;
		$charModName = `textField
			-width 345 RRM_TextFieldCharName`;
			
			setParent RRM_GenerateRigColumnLayout;

		
	//STEP 3.2
		frameLayout -label "Step 3.2: Create Character Rig"
			-width 355
			RRM_CreateRigFrameLayout;
	
			button -bgc .30 .65 .30 -label "Generate Modular Rig"
			-command "RRM_GenerateRigPrompts(`textField -q -text RRM_TextFieldCharName`)"
			RRM_GenerateRigPromptsButton;
	
			setParent RRM_GenerateRigColumnLayout;
	
	//STEP 3.3
		frameLayout -label "Step 3.3: Skin Geometry to Rig"
			-width 355
			RRM_SelectSkinningJointsFrameLayout;
		
			columnLayout RRM_SelectSkinningJointsColumnLayout;
	
			textFieldButtonGrp -buttonLabel "Load Rig"
			-cal 1 "left"
			-columnWidth2 290 70
			-ann "Select a control of the Rapid Rig you want to load"
			-buttonCommand "RRM_LoadRig"
			RRM_LoadRigTextFieldButtonGrp;
			
			columnLayout -cw 355 -cat "left" 5;
			
			setParent..;

			button -w 350 -label "Select Skinning Joints"
			-command "RRM_SelectJoints(`textFieldButtonGrp -q -tx RRM_LoadRigTextFieldButtonGrp`)"
			RRM_SelectJointsButton;
	
		setParent RRM_GenerateRigColumnLayout;
		
	//STEP 3.4
	frameLayout -label "Step 3.4: Character Set Creation"
		-width 355
		RRM_CreateCharacterSetFrameLayout;
		
		columnLayout RRM_CreateCharacterSetColumnLayout;
		checkBox -label "Create Subcharacter Set for Each Module" RRM_SubCharacterCheckBox;
		
		button -w 350 -label "Create Character Set"
			-ann "Select MAINC of the Rig you want to create the character set for."
			-command "RRM_CreateCharacterSet(`checkBox -q -v RRM_SubCharacterCheckBox`)"
			RRM_CreateCharacterSetButton;		
	
		setParent RRM_RigSteps;

	//STEP 4.1
		columnLayout "RRM_Tab2_RightColumn";
		frameLayout -label "Step 4.1: Resize Controllers"
			-width 415
			RRM_ResizeControllersFrameLayout;
			
		columnLayout -cw 415 -cat "left" 0;

        rowColumnLayout -nc 2 -cw 1 340 -cw 2 75;
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "Selected" "Branch" "All"
		-sl 1
		-cc RRM_ControlEnableDisableMirror
		RRM_ControlScaleSelection;
		
		checkBox -label "Mirror"
		-v 1 -enable 1 RRM_ControlMirror;
		setParent..;		

		columnLayout -cal "left";
		checkBox -label "Uniform Scale"
		-v 1 -enable 1
		-cc RRM_ControlEnableDisableUniformScales
		RRM_ControlUniformScale;
		
		checkBoxGrp -numberOfCheckBoxes 3
		-label "Local Axes:"
		-labelArray3 "X" "Y" "Z"
		-valueArray3 1 1 1
		-en1 0 -en2 0 -en3 0
		RRM_ControlScaleAxes;
		
		
		floatSliderGrp -label "Scale Factor:" -field true
		-min 0.1 -max 2 -fieldMaxValue 10 -value 1
		-precision 3
		RRM_ControlScaleChange;
		setParent..;
		columnLayout;
		button -label "Scale Control(s)"
		-width 410
		-command "RRM_ControlScale(`floatSliderGrp -query -value RRM_ControlScaleChange`,\
		`radioButtonGrp -q -select RRM_ControlScaleSelection`,\
		`checkBox -q -v RRM_ControlMirror`,\
		`checkBox -q -v RRM_ControlUniformScale`,\
		`checkBoxGrp -q -value1 RRM_ControlScaleAxes`,\
		`checkBoxGrp -q -value2 RRM_ControlScaleAxes`,\
		`checkBoxGrp -q -value3 RRM_ControlScaleAxes`);"
		RRM_ControlScaleButton;
		
		setParent RRM_Tab2_RightColumn;
		
	//STEP 4.2: SAVE CONTROLS
		frameLayout -label "Step 3.5: Save & Load Control Shapes and Colors" -width 415 RRA_SaveLoadControlShapes;
		rowColumnLayout -nc 2;
		button -label "Save Shapes and Colors" -w 206 -c "RRM_WriteControlShapes";
		button -label "Load Shapes and Colors" -w 206 -c "RRM_ReadControlShapes";
		
		setParent RRM_Tab2_RightColumn;
		
	//STEP 4.3
		frameLayout -label "Step 3.6: Override Control Color" RRM_ControlColorOverrides;
		rowColumnLayout -nc 16;
		button -bgc  .471 .471 .471		-label "D" -w 25 -ann "0"  -c "RRM_ControlOverrideColor(00)";
		button -bgc  0 0 0				-label ""  -w 25 -ann "1"  -c "RRM_ControlOverrideColor(01)";
		button -bgc  .251 .251 .251		-label ""  -w 25 -ann "2"  -c "RRM_ControlOverrideColor(02)";
		button -bgc  .502 .502 .502		-label ""  -w 25 -ann "3"  -c "RRM_ControlOverrideColor(03)";
		button -bgc  .608 0 .157		-label ""  -w 25 -ann "4"  -c "RRM_ControlOverrideColor(04)";
		button -bgc  0 .016 .376		-label ""  -w 25 -ann "5"  -c "RRM_ControlOverrideColor(05)";
		button -bgc  0 0 1				-label ""  -w 25 -ann "6"  -c "RRM_ControlOverrideColor(06)";
		button -bgc  0 .275 .098		-label ""  -w 25 -ann "7"  -c "RRM_ControlOverrideColor(07)";
		button -bgc  .149 0 .263		-label ""  -w 25 -ann "8"  -c "RRM_ControlOverrideColor(08)";
		button -bgc  .784 0 .784		-label ""  -w 25 -ann "9"  -c "RRM_ControlOverrideColor(09)";
		button -bgc  .541 .282 .2		-label ""  -w 25 -ann "10" -c "RRM_ControlOverrideColor(10)";
		button -bgc  .247 .137 .122		-label ""  -w 25 -ann "11" -c "RRM_ControlOverrideColor(11)";
		button -bgc  .6 .149 0			-label ""  -w 25 -ann "12" -c "RRM_ControlOverrideColor(12)";
		button -bgc  1 0 0				-label ""  -w 25 -ann "13" -c "RRM_ControlOverrideColor(13)";
		button -bgc  0 1 0				-label ""  -w 25 -ann "14" -c "RRM_ControlOverrideColor(14)";
		button -bgc  0 .255 .6			-label ""  -w 25 -ann "15" -c "RRM_ControlOverrideColor(15)";
		button -bgc  1 1 1				-label ""  -w 25 -ann "16" -c "RRM_ControlOverrideColor(16)";
		button -bgc  1 1 0				-label ""  -w 25 -ann "17" -c "RRM_ControlOverrideColor(17)";
		button -bgc  .392 .863 1		-label ""  -w 25 -ann "18" -c "RRM_ControlOverrideColor(18)";
		button -bgc  .263 1 .639		-label ""  -w 25 -ann "19" -c "RRM_ControlOverrideColor(19)";
		button -bgc  1 .69 .69			-label ""  -w 25 -ann "20" -c "RRM_ControlOverrideColor(20)";
		button -bgc  .967 .675 .475		-label ""  -w 25 -ann "21" -c "RRM_ControlOverrideColor(21)";
		button -bgc  1 1 .388			-label ""  -w 25 -ann "22" -c "RRM_ControlOverrideColor(22)";
		button -bgc  0 .6 .329			-label ""  -w 25 -ann "23" -c "RRM_ControlOverrideColor(23)";
		button -bgc  .631 .412 .188		-label ""  -w 25 -ann "24" -c "RRM_ControlOverrideColor(24)";
		button -bgc  .624 .631 .188		-label ""  -w 25 -ann "25" -c "RRM_ControlOverrideColor(25)";
		button -bgc  .408 .631 .188		-label ""  -w 25 -ann "26" -c "RRM_ControlOverrideColor(26)";
		button -bgc  .188 .631 .365		-label ""  -w 25 -ann "27" -c "RRM_ControlOverrideColor(27)";
		button -bgc  .188 .631 .631		-label ""  -w 25 -ann "28" -c "RRM_ControlOverrideColor(28)";
		button -bgc  .188 .404 .631		-label ""  -w 25 -ann "29" -c "RRM_ControlOverrideColor(29)";
		button -bgc  .435 .188 .631		-label ""  -w 25 -ann "30" -c "RRM_ControlOverrideColor(30)";
		button -bgc  .631 .188 .412		-label ""  -w 25 -ann "31" -c "RRM_ControlOverrideColor(31)";
		
			
			setParent RRM_RigSteps;
			setParent ..;
	//TAB 3////////////////////////////////////////////////////////////////////////	
	rowColumnLayout -nc 2 -cw 1 355 -cw 2 415 RRM_RigExtras;
	
		frameLayout -label "Step 5.1: Delete the Proxy Rig"
			-width 355
			RRM_DeleteProxyRigFrameLayout;
			
		columnLayout RRM_DeleteProxyRigColumnLayout;

			
			//STEP 5.1
			button -label "Delete Proxies" -w 354
			-bgc .8 0.25 0.25
			-ann "This will delete your proxy rig once you have no further use for it."
			-command "RRM_DeleteProxyRig"
			RRM_DeleteProxyRigButton;
			
			
			setParent RRM_DeleteProxyRigColumnLayout;
			
			//STEP 5.2
		frameLayout -label "Step 5.2: Select Any Control to Delete the Entire Rig"
			-width 355
			RRM_DeleteModularRigFrameLayout;
			
		button -label "Delete Rig"
		-bgc .8 0.25 0.25
		-annotation "Select a control of your rig and click this button to delete that rig."
		-command "RRM_DeleteRigUI"
		RRM_DeleteRigUIButton;
		
		setParent RRM_DeleteProxyRigColumnLayout;

		//STEP 5.3
		frameLayout -label "Rapid Rig Info"
			-width 355
			RRM_RapidRigInfoFrameLayout;
			
		columnLayout -cw 355;

		columnLayout -cw 50 -cat "left" 5;
		button -w 355 -label "RRM Version Number"
		-annotation "Select the Main Control and click this button to see what version your rig is."
		-command "RRM_GetVersionNumber"
		RRM_GetVersionNumberButton;
		
		button -w 355 -label "Go To \"Rapid Rig: Modular\" Web Page"
		-annotation "Go to the CreativecCrash webpage for Rapid Rig: Modular."
		-command "RRM_GoToCreativeCrash"
		RRM_GoToCreativeCrashButton;
		
		
		text -label "\n\n\n\n                email me with questions and feedback:\n\n                             dustin@rapidrig.com\n\n\n" -align "left";
	
	
		//STEP 6
			setParent RRM_DeleteProxyRigColumnLayout;
			setParent RRM_RigExtras;
			frameLayout -label "Rename Single Hierarchy to Match Motionbuilder Naming"
			-w 415 RRM_RenameSHJointsFrameLayout;
			
			rowColumnLayout -nc 2 -cw 1 205 -cw 2 205;
			button -label "Rename Head" -ann "Select a joint to rename to Head" -c RRM_SH_RenameHead;
			button -label "Rename Neck" -ann "Select the first joint of a chain to rename to Neck" -c RRM_SH_RenameNeck;
			button -label "Rename Spine" -ann "Select the first joint of a chain to rename to Spine" -c RRM_SH_RenameSpline;
			button -label "Rename Hips"  -ann "Select a joint to rename to Hips" -c RRM_SH_RenameHips;
			button -label "Rename Left Arm"  -ann "Select clavicle joint of an Arm" -c RRM_SH_RenameLeftArm;
			button -label "Rename Right Arm" -ann "Select clavicle joint of an Arm" -c RRM_SH_RenameRightArm;
			button -label "Rename Left Leg"  -ann "Select hip joint of a Leg" -c RRM_SH_RenameLeftLeg;
			button -label "Rename Right Leg" -ann "Select hip joint of a Leg" -c RRM_SH_RenameRightLeg;
			
			setParent ..;
			
	
	tabLayout -edit -tabLabel RRM_ProxySteps "Setup Proxies" /*-tabLabel RRM_EditProxy "Modify Proxies"*/ -tabLabel RRM_RigSteps "Generate Rig" -tabLabel RRM_RigExtras "Extras" $tabs;

		int $top, $left, $value[2];
		$value = `scrollLayout -query -scrollAreaValue addModScrollLayout`;
		$top = $value[0];
		$left = $value[1];
}


//MAIN PROCEDURE FOR WINDOW
global proc RapidRig_Modular()                                        
{
	if (`window -exists RRM_Window`) 
	{
		deleteUI RRM_Window; 
	}
	window -title "Rapid Rig: Modular 1.5.2"
		-wh 375 212
		-rtf on
		-mnb false
		-mxb false
		-s 1
		RRM_Window;
	
	RRM_CreateProxyMainGUI();
	
	showWindow RRM_Window;
	window -e -w 375 -h 212 RRM_Window;
}

RapidRig_Modular();
